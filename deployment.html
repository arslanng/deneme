<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">GraphQL</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          <li><a class="dropdown-item" href="GraphQL.html" target="_blank">GraphQL</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#docker">Docker</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsDocker">Docker Nedir? Nasıl Kullanılır?</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#dockerSetup">Docker Kurulumu</a>
                      <a class="nav-link ms-4 my-1" href="#dockerHub">DockerHub</a>
                      <a class="nav-link ms-4 my-1" href="#dockerImage">İmage Çekme ve Açma</a>
                      <a class="nav-link ms-4 my-1" href="#dockerContainerName">Container İsimlendirme (--name)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerContainerRm">Container Silme (rm) ve Image Silme (rmi)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerTag">Tag Nedir?</a>
                      <a class="nav-link ms-4 my-1" href="#dockerDetachAttachLog">Detach mode (-d), Attach mode (attach) ve Log</a>
                      <a class="nav-link ms-4 my-1" href="#dockerIt">İnteraktif Terminal (-it)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerPortMapping">Port Mapping (-p)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerVolumeMapping">Volume Mapping (-v)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerInspect">docker inspect &lt;...></a>
                      <a class="nav-link ms-4 my-1" href="#dockerEnvironmentVariable">Environment Variable (-e) ve Linkleme (--link)</a>
                    </nav>
                  </nav>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#dockerNetwork">Docker Network Türleri</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#dockerUserCustomNetwork">Kullanıcı Tanımlı Network</a>
                      <a class="nav-link ms-4 my-1" href="#dockerSameNetworkAppTalk">Uygulama Örneği: Aynı Network Üzerinden Containerların Konuşması (NodeJs - MongoDB)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerMyImage">Kendimize Ait Image Oluşturmak</a>
                      <a class="nav-link ms-4 my-1" href="#dockerNodeBaseImage">Uygulama 2 - Aynı İşi Hazır Node BaseImage İle Yapmak</a>
                      <a class="nav-link ms-4 my-1" href="#dockerNodeServer">Uygulama 3 - Node Server</a>
                      <a class="nav-link ms-4 my-1" href="#dockerSimplePhp">Uygulama 4 - Simple PHP App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerMondoTodo">Uygulama 5 - Mondo Todo App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerCMDandENTERYPOINT">CMD ve ENTERYPOINT</a>
                      <a class="nav-link ms-4 my-1" href="#dockerUbuntuSleeper">Uygulama 6 - Ubuntu Sleeper</a>
                    </nav>
                  </nav>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#dockerComposeLesson">Docker Compose ile Servis Yönetimi</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#dockerPythonApp">Uygulama 7 - Python App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerVueApp">Uygulama 8 - Vue App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerPurine">Her Şeyi Silmek (docker container prune)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerCompose">Docker Compose</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm1">Örnek - 1: Tek Service</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm2">Örnek - 2: Multiple Service</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm3">Örnek - 3: Upload Edilen Dosyanın Saklanması</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm4">Örnek - 4: Variable Environment kullanmak</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm5">Örnek - 5: Çalışmak İçin Diğer Containerların Çalışmasına İhtiyaç Duymak</a>
                    </nav>
                  </nav>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#linuxDockerSetupProductionLginx">Linux'a Docker Kurulumu,<br>Production,Nginx</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#">xxx</a>
                    </nav>
                  </nav>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div class="row" id="docker">
              <h1>Docker</h1>
              <p>
                Hoconın dökümantasyonu <a href="https://github.com/gkandemi/docker">https://github.com/gkandemi/docker</a>
              </p>
              <div class="row" id="whatIsDocker">
                <h2>Docker Nedir? Nasıl Kullanılır?</h2>
                <p>
                  Proses izolasyonu sağlar. Çalıştırılan programın ortamı, ortamın da uygulamayı etkilemesini engeller.
                </p>
                <p>
                  <b>Container</b> kendine ait prosesleri, servisleri ve ağı olan. Aymı işletim sistemi veya virtual machine (VM) üzerinde çalışan, diğer ortamlardan izole edilmiş ortamlardır.
                </p>
                <p>
                  Docker, container ile işletim sistemi kerneli arasında bağlantıyı sağlar. 
                </p>
                <p>
                  Docker container işini kolaylaştırmak için bize birçok high level araç sunar.
                </p>
                <p>
                  Docker LXC container türü kullanır. 
                </p>
                <p>
                  Windows üzerine docker yüklendiğinde Docker araya otomatik olarak linux VM yükler ve containerları kendisinin yüklediği linux VM üzerinden yönetir.
                </p>
                <p>
                  Container çalışan yapılardır. Kaynak kod image içinde.
                </p>
                <p>
                  <b>image</b> içinde birçok yapıyı barındırabilir. Containerin nasıl çalışacağını anlatır. image çalıştırıldığında container oluşturur. Bu image dosyaları genelde bulutta tutulur. Docker için genelde <a href="https://hub.docker.com/">Docker Hub</a> kullanılır. İmageı çalıştırdığımızda elde ettiğimiz proses containerdır. İmage çalışmayı durdurduğunda container ortadan kalkar.
                </p>
                <p>
                  <b>DockerHub</b> üzerinden ubuntu indirmek için <code>docker pull ubuntu</code>. docker imajından ubuntu çalıştırmak için <code>docker run ubuntu</code> bilgisayarda yoksa image dosyasını kendisi çeker ve çalıştırır. 
                </p>

                <h3 id="dockerSetup">Docker Kurulumu</h3>
                <p>
                  <a href="https://www.docker.com/get-started/">docker.com</a> adresinden indir ve kur.
                </p>

                <h3 id="dockerHub">DockerHub</h3>
                <p>
                  <a href="https://hub.docker.com/">https://hub.docker.com/</a>
                </p>
                <p>
                  dockerhub>"Explore" filtrelemede 
                  <ul>
                    <li>"verified publisher": kendi yayıncısı tarafından dockerize edildiği ve yüklendiği image dosyaları.</li>
                    <li>"offical images": büyük şirketlerin ürünlerinin docker tarafından dockerize edildiği ve yüklendiği image dosyaları.</li>
                  </ul>
                </p>

                <h3 id="dockerImage">İmage Çekme ve Açma</h3>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker pull ubuntu</pre> yazdık. Dockerhub üzerinden ubuntuyu çekti
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker pull mongo</pre> yazdık. Dockerhub üzerinden mongoyu çekti
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker images</pre> yazdığımızda indirmiş olduğumuz docker images listelenir
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run redis</pre> yazdığımızda redis lokalde varsa çalışır. Yoksa image indirilir ve çalıştırılır. Çalıştığını terminalde görürüz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run ubuntu</pre> ile ubuntu çalışır ama hemen geri kapanır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run ubuntu sleep 5</pre> ile ubuntu açılır 5 sn bekler ve kapanır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -it ubuntu</pre> ile ubuntu açılır ve içinde işlem yapılabilir. <code>-it</code> interaktif terminal anlamında.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker ps</pre> veya <pre class="prettyprint ms-0">docker conlainer ls</pre> ayakta olan containerları gösterir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker ps -a</pre> veya <pre class="prettyprint ms-0">docker ps --all</pre> veya <pre class="prettyprint ms-0">docker conlainer ls -a</pre> ayakta olan olmayan tüm containerları gösterir
                </p>

                <h3 id="dockerContainerName">Container İsimlendirme (--name)</h3>
                <p>
                  <pre class="prettyprint ms-0">docker run -it --name bash_ubuntu ubuntu</pre> olarak yazdığızda container <b>bash_ubuntu</b> adını alır ve isim altında ayarları da kaydedilir. <pre class="prettyprint ms-0">docker start bash_ubuntu</pre> yazarak ismini ve özelliklerini kaydettiğimiz container ayağa kaldırılır. Terminalde kaybolur. Arka planda çalışır. <pre class="prettyprint ms-0">docker stop bash_ubuntu</pre> ile kapatılır.
                </p>
                <p>
                  <code>docker stop &lt;container-name></code> kısmında &lt;container-name> yerine &lt;container-id> nin baştan ilk 2 ve daha fazla karakteri girilerek de durdurma işlemi yapılabilir. container id lerin ilk kısmında çakışma olursa daha çok karakter girmek gerekir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker ps -a</pre> ile listelediğimiz herhangi bir container bu yöntemle açılabilir ve kapatılabilir.
                </p>

                <h3 id="dockerContainerRm">Container Silme (rm) ve Image Silme (rmi)</h3>

                <h4>Container Silme (rm)</h4>
                <p>
                  <pre class="prettyprint ms-0">docker ps -a</pre> ile listelenenleri silmek için <pre class="prettyprint ms-0">docker rm &lt;container-name></pre> yazarak tek tek silebiliriz. <code>docker start</code> ve <code>docker stop</code> kodlarındaki gibi name yerine idnin başı yazılabilir. Id veya name boşluk bırakılarak birden fazla yazılabilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker container rm $(docker container ls -aq)</pre> tüm idleri silme fonksiyonuna taşıyarak tüm containerları siler.
                </p>

                <h4>Image Silme (rmi)</h4>
                <p>
                  <pre class="prettyprint ms-0">docker images</pre> ile listelenenleri silmek için <pre class="prettyprint ms-0">docker rmi &lt;image-name></pre> yazarak tek tek silebiliriz.
                </p>

                <h3 id="dockerTag">Tag Nedir?</h3>
                <p>
                  sürüm?
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run redis:5</pre> redisin 5. sürümünü indirir ve çalıştırır.
                </p>
                  <pre class="prettyprint ms-0">docker image tag &lt;image name veya id> &lt;new tag name></pre> ile images name değiştirilir.
                <p>
                  <pre class="prettyprint ms-0">docker image tag ubuntu my_ubuntu</pre> ile my_ubuntu adında bir ubuntu kopyası elde ederiz.
                </p>

                <h3 id="dockerDetachAttachLog">Detach mode (-d), Attach mode (attach) ve Log</h3>
                <p>
                  <b>Detach mode</b>: Çalıştırılan imageın oluşturduğu container arka planda çalışsın.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -d redis</pre>
                </p>
                <p>
                  <b>Attach mode</b>: detach modda çalışan uygulamayı öne getirir
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker attach &lt;container id veya name></pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker attach bold_meitner</pre> ile bold_meitner isimli container öne getirilir.
                </p>
                <p>
                  <b>Log</b>: detach modda çalışan uygulamanın verdiği logları görmek için kullanılır.
                  <pre class="prettyprint ms-0">docker container logs &lt;container id veya name></pre>
                </p>

                <h3 id="dockerIt">İnteraktif Terminal (-it)</h3>
                <p>
                  kullanıcı girişli bir uygulamanız varsa kullanıcı girişini (interaktif terminal) açabilmek için -it flagi kulanılır.
                  <pre class="prettyprint ms-0">docker run -it gkandemir/interactive-terminal-app</pre>
                </p>

                <h3 id="dockerPortMapping">Port Mapping (-p)</h3>
                <p>
                  <pre class="prettyprint ms-0">docker run -p Dış_port:iç_port image_name</pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -d 27018:27017 mongo</pre> dışarıdan biz bağlandığımızda 27018 portunu kullanır. docker içinde ise default portu olan 27017 kullanılır. mongoDBCompass <code>mongodb://localhost:27018</code> ile bu mongoya bağlanabilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run gkandemir/node-app</pre> yazdığımızda terminalde <pre class="prettyprint ms-0">Example app listening at http://localhost:3000 </pre> yazar ancak biz buna web tarayıcımızdan erişemeyiz. Çünkü 3000 portu docker içi için geçerlidir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -p 3001:3000 gkandemir/node-app</pre> yazdığımızda dış portu olan 3001 portuna web tarayıcıya "http://localhost:3001/" yazarak ulaşabiliriz.
                </p>
                <p>
                  Birden fazla container birden fazla portta eş zamanlı çalıştırabiliriz.
                </p>

                <h3 id="dockerVolumeMapping">Volume Mapping (-v)</h3>
                <p>
                  Dockerhost üzerinde containerlar stateless olarak çalışır. Yani içindeki bilgileri kayıt etmez. Container durduğunda içindeki bilgiler silinir.
                </p>
                <p>
                  Kaydedilecek bilgiler için <b>volume</b> kullanılır. Bir containerı ayağa kaldırdığımızda kayıt edilecek klasörün adresini docker host üzerinden bildiririz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -v /opt/data:/data/db mongo</pre> data/db içinde değişiklik olduğunda host içinde opt/data içine kaydet. Çalışırken de buradaki datayı al.
                </p>
                <p>
                  hangi dosyanın veri tutuğunu ve kaydedilmesi gerektiğini dökümantasyondan bulabiliriz.
                </p>
                <p>
                  docker içinde datanın tutulduğu klasörün docker desktop tarafından bilinen ve izin verilmiş bir klasör olması gerekiyor. (windowsta buna gerek yok. Herhangi bir dizini kabul ediyor.)
                  <pre class="prettyprint ms-0">docker run -v /myData/data:/data/db mongo</pre>
                </p>
                <p>
                  Bizim kullandığımız docker versiyonunda volume almaya gerek var mı emin değilim. Her container açtığımda zaten Docker Desktop üzerinde bir volume açılıyor gibi. Belki image her container haline getirilirken bu veriyi de alması için kullanılyor olabilir.
                </p>

                <h3 id="dockerInspect">docker inspect &lt;...></h3>
                <p>
                  <b>container</b> hakkında bilgi almak için <pre class="prettyprint ms-0"> docker inspect &lt;container name veya id></pre> yazıyoruz.
                </p>
                <p>
                  Gelen ekranda "HostConfig" > "Binds" kısmında array olarak volume alınacak dosyalar mevcut. "HostConfig" > "PortBindings" port yönlendirmesini verir.
                </p>
                <p>
                  "Config" > "ExposedPosts" docker içindeki portu verir. "NetworkSettings" > "Ports" iç ve dış portunu verir.
                </p>

                <p>
                  <b>image</b> hakkında bilgi almak için <pre class="prettyprint ms-0"> docker inspect &lt;image name veya id></pre> yazıyoruz.
                </p>

                <h3 id="dockerEnvironmentVariable">Environment Variable (-e) ve Linkleme (--link)</h3>
                <p>
                  <pre class="prettyprint ms-0">docker run -e MYSQL_ROOT_PASSWORD=test123 -d mysql</pre>
                  -e den sonraki kısım environment variable
                </p>

                <h4>MySQL - phpmyadminproject</h4>
                <p>
                  <pre class="prettyprint ms-0">docker pull phpmyadmin/phpmyadmin</pre> ile phpmyadmin image indirildi. mysql ile bunu bağlayacağız.
                </p>
                <p>
                  Önce bağlanılacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=test123 -d mysql</pre>
                </p>
                <p>
                  Sonra bağlanacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name pmyadmin -p 8000:80 --link mysql-server:db -d phpmyadmin/phpmyadmin</pre> <code>--link</code> ten sonra bağlanacağı container name ve <code>:</code> sonrası bağlanacağı alias(takma ad) yazılır. Bu kısım dökümantasyonda verilir.
                </p>
                <p>
                  Tarayıcıda <a href="http://localhost:8000/">http://localhost:8000/</a> yazıp phpmyadmin açılır. kullanıcı adı: root, pass: test123 yazılarak mysql databasee bağlanılır.
                </p>

                <h4>Volume eklenmiş örnek</h4>

                <p>
                  Önce bağlanılacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name mysql-server -p 3306:3306 -v /opt/data:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=test123 -d mysql</pre>
                </p>
                <p>
                  Sonra bağlanacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name pmyadmin -p 8000:80 --link mysql-server:db -d phpmyadmin/phpmyadmin</pre> <code>--link</code> ten sonra bağlanacağı container name ve <code>:</code> sonrası bağlanacağı alias(takma ad) yazılır. Bu kısım dökümantasyonda verilir.
                </p>
                <p>
                  Tarayıcıda <a href="http://localhost:8000/">http://localhost:8000/</a> yazıp phpmyadmin açılır. kullanıcı adı: root, pass: test123 yazılarak mysql databasee bağlanılır.
                </p>
              </div>
              <div class="row" id="dockerNetwork">
                <h2>Docker Network Türleri</h2>
                <p>
                  Dockerda 3 tür default network var: bridge, none, host
                </p>
                <p>
                  <b>bridge network</b>: default olarak kaldırılan image ile aldığımız neteork. Containerlar birbirine bir gateaway üzerinden bağlanıyor.
                </p>
                <p>
                  <b>none network</b>: dışarıdan erişilememesi için tanımlanmış network. Örn: <code>docker run mongo --network=none</code>
                </p>
                <p>
                  <b>host network</b>: docker host üzerinden sadece port numarası eklenerek ulaşılan network Örn: <code>docker run mongo --network=host</code>
                </p>

                <h3 id="dockerUserCustomNetwork">Kullanıcı Tanımlı Network</h3>
                <p>
                  Kullanıcının kendisinin tanımladığı network örn: <code>docker network create --driver bridge --subnet 182.18.0.0/16 --gateway 182.18.0.1 todo-app-network</code>
                </p>

                <p>
                  <pre class="prettyprint ms-0">docker network ls</pre> veya <pre class="prettyprint ms-0">docker network list</pre> ile tüm network görüntülenebilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker network rm &lt;network-name veya id></pre> ile network silinebilir.
                </p>
                <p>
                  Normalde mongoDB gibi bir databasei uygulamamıza bağlarken 
                  <pre class="prettyprint ms-0">
...
await Mongoose.connect("mongodb://localhost:27017/todos")
...
                  </pre>
                  daki gibi localhost veya sabit bir ip kullanılır. Docker içinde her çalışmada ip sabit kalmadığından biz bunun yerine container name kullanırız.
                  <pre class="prettyprint ms-0">
...
await Mongoose.connect("mongodb://mongo-server:27017/todos")
...
                  </pre>
                </p>

                <h3 id="dockerSameNetworkAppTalk">Uygulama Örneği: Aynı Network Üzerinden Containerların Konuşması (NodeJs - MongoDB)</h3>

                <p>
                  <pre class="prettyprint ms-0">docker pull gkandemir/todo-app</pre> ile hocanın bu iş için oluşturduğu uygulamayı çektik.
                </p>
                <p>
                  Önce networkü oluşturuyoruz: <pre class="prettyprint ms-0">docker network create --driver bridge --subnet 182.18.0.1/24 --gateway 182.18.0.1 custom-network</pre> <code>--driver</code> ile türünü belirttik. <code>--subnet</code> ile çalışma aralığını <code>--gateway</code> ile gatewayini belirttik. En son <code>custom-network</code> ise bizim ona verdiğimiz adı belirtti.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker inspect &lt;id></pre> ile oluşan networkü inceleyebiliriz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --name mongo-server --net custom-network -d mongo</pre> <code>--name mongo-server</code> kısmı uygulamamızda kullanacağımız container name ile aynı olmalı. <code>--net custom-network</code> bağlanacağı networkü seçtik.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --net custom-network -p 3000:3000 gkandemir/todo-app</pre> <code>--net custom-network</code> ile ağa bağlandık. Dışarıdan da ulaşabilmek için <code>-p 3000:3000</code> ile port mapping yaptık.
                </p>
                <p>
                  postman ile http://localhost:3000 üzerinden bağlanıp data gönderebiliyoruz.
                </p>
                <p>
                  Bu bağlantıyı link yöntemi ile yapsaydık kod içinde alias tanımlamak gerekecekti.
                </p>

                <h3 id="dockerMyImage">Kendimize Ait Image Oluşturmak</h3>
                <p>
                  <pre class="prettyprint ms-0">docker pull ubuntu:18.04</pre> ile ubuntu v18.04 çekildi.
                  <pre class="prettyprint ms-0">docker run -it ubuntu:18.04</pre> ile ubuntu container içine girildi.
                </p>
                <p>
                  ubuntu içinde terminale <pre class="prettyprint ms-0">apt-get update</pre> yazarak güncellemeler yapıldı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">apt-get install curl -y</pre> ile curl kuruldu.
                  <pre class="prettyprint ms-0">curl -sL https://deb.nodesource.com/setup_10.x | bash</pre> ile node.js indirildi. <pre class="prettyprint ms-0">apt-get install nodejs -y</pre> ile indirilen nodejs kuruldu.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
cd opt
mkdir node-app
cd node-app
                  </pre> ile bir dosya oluşturuldu ve içine girildi.
                </p>
                <p>
                  <pre class="prettyprint ms-0">echo 'console.log("nodejsapp from ubuntu ...");' > index.js</pre> ile index.js dosyası oluşturuldu ve içine <code>console.log("nodejsapp from ubuntu ...");</code> yazıldı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">node index.js</pre> yazdığımızda terminalde <pre class="prettyprint ms-0">nodejsapp from ubuntu ...</pre> yazısı belirdi. Bu da bize node.jsin ubuntuda düzgün çalıştığını gösterdi.
                </p>
                <p>
                  ubuntuda <pre class="prettyprint ms-0">history</pre> yazınca o zamana kadar ubuntu terminalinde yaptıklarımızı listeler.
                  <pre class="prettyprint ms-0">
1  apt-get update
2  apt-get install curl -y
3  curl -sL https://deb.nodesource.com/setup_10.x | bash
4  apt-get install nodejs -y
5  ls
6  cd opt
7  ls
8  mkdir node-app
9  ls
10  cn note-app
11  cd note-app
12  ls
13  cd node-app
14  echo 'console.log("nodejsapp from ubuntu ...");' > index.js
15  ls
16  node index.js
17  history
                  </pre>
                </p>

                <h4>Image Dosyasını Hazırlamak</h4>
                <p>
                  Bir proje klasörü oluşturduk ve içinde index.js
                  <pre class="prettyprint ms-0">
console.log("Hello from ubuntu")
                  </pre> ve Dockerfile dosyası daha önce aldığımız <q>histori</q>ye göre oluşturuldu.
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install curl -y
RUN curl -sL https://deb.nodesource.com/setup_10.x | bash
RUN apt-get install nodejs -y
COPY . /opt/node-app/
# Yukarıdaki kısım imageden container oluşturmak için
# aşağıdaki kısım oluşan containerın çalışma anında çalışacak kısım.
# CMD [ "node", "/opt/node-app/index.js" ]
WORKDIR /opt/node-app/
CMD [ "node", "index.js" ]
                  </pre>
                  oluşturuldu. 
                </p>
                <p>
                  Dockerfile dosyasında önce containerın açılacağı image <code>FROM</code> ile belirlendi. Sonra bunun içindeki işlemler <code>RUN</code> ile oluşturuldu. <code>COPY . /opt/node-app/</code> komutu ile bu dizindeki tüm dosyalar container içinde belirtilen yere eklendi. Bu kısım image -> container işlemi için gerekli.
                </p>
                <p>
                  <code>WORKDIR</code> ile bundan sonra çalışılacak dizin belirlendi. <code>CMD [ "node", "index.js" ]</code> ile container çalışmaya başladığında yapacağı iş tanımlandı.
                </p>

                <h4>Image almak</h4>
                <p>
                  Proje dosyasında terminal açıldı.
                  <pre class="prettyprint ms-0">docker build .</pre> işlemi bende hata verdi. <pre class="prettyprint ms-0">docker system prune</pre> ile dockerı tamamen temizleyip tetkrar deneyince oldu :D
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker images</pre> yazınca bizim oluşturduğumuz image de listeleniyor.
                </p>
                <p>
                  isim vermek için <pre class="prettyprint ms-0">docker build . -t simple-node-app</pre>
                </p>
                <p>
                  Dockerfile içindeki her işlem adımı docker içerisinde layer olarak tutulur. Başka bir image için aynı şeye gerek olduğunda işlem oradan kopyalanır. Bu nedenle zaten dockerımızda olan bir işlem yapıldığında çok hızlı yapar.
                </p>

                <h4>ENV ile Çalışmak</h4>
                <p>index.js aşağıdaki gibi güncellendi.
                  <pre class="prettyprint ms-0">
console.log("Hello from ubuntu")
console.log("env =>", process.env.channel)
                  </pre>
                </p>
                <p>
                  Dockerfile içine ENV olarak eklendi.
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install curl -y
RUN curl -sL https://deb.nodesource.com/setup_10.x | bash
RUN apt-get install nodejs -y
COPY . /opt/node-app/
# 
ENV channel=kablosuzkedi
# Yukarıdaki kısım imageden container oluşturmak için
# aşağıdaki kısım oluşan containerın çalışma anında çalışacak kısım.
# CMD [ "node", "/opt/node-app/index.js" ]
WORKDIR /opt/node-app/
CMD [ "node", "index.js" ]
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker build . -t simple-node-app</pre>
                  ile tekrar build alınır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run simple-node-app</pre> ile çalıştırıldı ve treminalde aşağıdaki çıktı alındı.
                  <pre class="prettyprint ms-0">
Hello from ubuntu
env => kablosuzkedi
                  </pre>
                </p>
                <p>
                  Dockerfile doldururken en üstte muhakkak baseimage olmalı.
                </p>

                <h3 id="dockerNodeBaseImage">Uygulama 2 - Aynı İşi Hazır Node BaseImage İle Yapmak</h3>
                <p>
                  Yeni bir proje klasörü oluşturuldu ve index.js önceki projeden kopyalandı
                </p>
                <p>
                  Dockerfile
                  <pre class="prettyprint ms-0">
FROM node
WORKDIR /opt/node-app
COPY . .
ENV channel=kablosuzkedi
CMD [ "node", "index.js" ]
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker build . -t simple-node-app-2</pre> ile image oluşturulur.
                </p>
                <p>
                  image dosyası 1.1 GB. Bıyutu daha önce kendimizin ubuntu ile yaptığından daha büyük. Bu nedenle node versiyonunu 16-slim ile değiştirdik.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-app
COPY . .
ENV channel=kablosuzkedi
CMD [ "node", "index.js" ]
                  </pre>
                </p>
                <p>
                  Önceki image silindi <pre class="prettyprint ms-0">docker rmi simple-node-app-2</pre> ve yeniden image alındı
                  <pre class="prettyprint ms-0">docker build . -t simple-node-app-2</pre>
                </p>
                <p>
                  İmage dosyamız şimdi 179MB :D
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run simple-node-app-2</pre> yazdığımızda terminalde
                  <pre class="prettyprint ms-0">
Hello from ubuntu
env => kablosuzkedi
                  </pre>
                  cevabı alındı.
                </p>

                <h3 id="dockerNodeServer">Uygulama 3 - Node Server</h3>
                <p>
                  Yeni bir proje klasörü oluşturuldu ve içine App.js eklendi.
                  <pre class="prettyprint ms-0">
const express = require("express");
const app = express();
const PORT = process.env.PORT || 3000;

app.get("/", (req, res) => {
  res.send("hello world");
});

app.listen(PORT, () => {
  console.log(`Example app listening at http://localhost:${PORT}`);
});
                  </pre>
                </p>
                <p>
                  npm paketlerini kullanabilmek için terminale <pre class="prettyprint ms-0">npm init -y</pre> yazdık. Sonra express modülünü indirmek için <pre class="prettyprint ms-0">npm install --save express</pre> yazıldı.
                </p>
                <p>
                  Bu hali ile çalıştırdığımızda server lokalde çalışıyor.
                </p>
                <p>
                  image alırken "node_modules" klasörünü da kopyalamamak için ".dockerignore" klasörü oluşturuldu ve içine
                  <pre class="prettyprint ms-0">node_modules/</pre> yazıldı.
                </p>
                <p>
                  Dockerfile dosyası oluşturuldu.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-server
COPY . .
RUN npm install
CMD ["node", "app.js"
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run simple-node-server</pre> ile image container haline gelir ve çalıştırılır. Terminalde <pre class="prettyprint ms-0">Example app listening at http://localhost:3000</pre> çıktısı alınır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -p 3001:3000 simple-node-server</pre> ile dışarıya port açılır ve <a href="http://localhost:3001/">http://localhost:3001/</a> üzerinden görülebilir.
                </p>
                
                <h3 id="dockerSimplePhp">Uygulama 4 - Simple PHP App</h3>
                <p>
                  Yeni bir uygulama klasörü oluşturduk. İçinde index.php dosyası oluşturduk.
                  <pre class="prettyprint ms-0">
&lt;?php
    echo "PHP Uygulamasını Dockerize Etmek...";
?>
                  </pre>
                  Dockerfile dosyası oluşturup içine:
                  <pre class="prettyprint ms-0">
FROM php:7-apache
COPY index.php /var/www/html/index.php
EXPOSE 80
CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
                  </pre>
                  yazıldı.
                </p>
                <p>
                  Proje klasöründe terminale <pre class="prettyprint ms-0">docker build . -t simple-php-app</pre> yazılarak image oluşturuldu.
                  <pre class="prettyprint ms-0">docker run -p 8080:80 simple-php-app</pre> diyerek uygulama up edilir. <a href="http://localhost:8080/">http://localhost:8080/</a> üzerinden de görüntülenebilir.
                </p>

                <h3 id="dockerMondoTodo">Uygulama 5 - Mondo Todo App</h3>
                <p>
                  Yeni bir proje klasörü açtık ve hocanın hazır kodlarını kullandık.
                </p>
                <p>
                  App.js
                  <pre class="prettyprint ms-0">
const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const app = express();
const { TodoModel } = require("./TodoModel");
const Mongoose = require("mongoose");
const PORT = process.env.PORT || 3000;

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());

app.get("/", (req, res) => {
  TodoModel.find({})
    .then((todoList) => res.status(200).json(todoList))
    .catch((e) => res.status(500).json(e));
});

app.post("/todo", (req, res) => {
  const todo = new TodoModel({
    ...req.body,
    created_at: new Date(),
  });

  todo
    .save()
    .then((savedTodo) => res.status(200).json(savedTodo))
    .catch((e) => res.status(400).json(e));
});

app.listen(PORT, async () => {
  console.log(`Sunucu çalışıyor... ${PORT} | MongoDB'ye bağlanılacak..`);
  await Mongoose.connect("mongodb://mongo-alias:27017/todos", {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
  console.log("MongoDB'ye bağlantı başarılı!");
});
                  </pre>
                  TodoModel.js
                  <pre class="prettyprint ms-0">
const Mongoose = require("mongoose");

const todoSchema = new Mongoose.Schema({
  title: String,
  description: String,
  completed: Boolean,
  created_at: Date,
});

module.exports = {
  TodoModel: Mongoose.model("todo", todoSchema),
};
                  </pre>
                  package.json 
                  <pre class="prettyprint ms-0">
{
  "name": "node-mongo",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "mongoose": "^5.11.13"
  },
  "devDependencies": {
    "nodemon": "^2.0.7"
  }
}
                  </pre>
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">npm i</pre> yazıp bağımlılıkları indirdik. 
                </p>
                <p>
                  .dockerignore dosyasına <pre class="prettyprint ms-0">node_modules/</pre> yazdık. 
                </p>
                <p>
                  Dockerfile dosyasına
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-todo-app
COPY . .
ENV PORT=4000
EXPOSE 4000
RUN npm install
CMD ["node", "app.js"]
                  </pre>
                  yazdık.
                </p>
                <p>
                  proje klasörünü terminalde açıp <pre class="prettyprint ms-0">docker build . -t todo-app</pre> yazarak image aldık.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --name mongo-server -p 27017:27017 -d mongo</pre> ile mongo server ayağa kaldırıldı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --link mongo-server:mongo-alias -p 4000:4000 todo-app</pre> <code>--link mongo-server:mongo-alias</code> kısmında mongo-server adındaki containera bağlan, bu bağlantı senin kodunda mongo-alias olarak geçiyor dedik. app.js kodunu incelersek orada <code>await Mongoose.connect("mongodb://mongo-alias:27017/todos"...)</code> kullanımını görürüz.
                </p>

                <h3 id="dockerCMDandENTERYPOINT">CMD ve ENTERYPOINT</h3>
                <p>
                  <b>CMD</b> Container ayağa kalktığında çalışacak fonksiyon. CMD tam bir fonksiyondur. Container çalıştığında çalışır. CMD override edilebilir.
                </p>
                <p>
                  <b>ENTERYPOINT</b> sadece executable komut içerir. Komutun parametresini çalışma anında bizden bekler. Yoksa çalışmaz. Varsayılan değer atamak için Dockerfile içinde hemen altında CMD ile varsayılan değer belirtilebilir.
                </p>
                <p>
                  Container yapılacak bir işlem varsa açık kalır yoksa kapanır. 
                </p>

                <h3 id="dockerUbuntuSleeper">Uygulama 6 - Ubuntu Sleeper</h3>

                <h4>v.1</h4>
                <p>
                  Yeni proje klasörü aç. Dockerfile dosyası
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04
CMD ["sleep", "4"] 
#  Bu yazım şeklinde 1. komut executable (çalıştırılabilir) olmalı. Devamında array olarak parametreler girilir.

# CMD sleep 4
# Bu yazımda direk çalıştırılacak kod yazılır.
                  </pre>
                </p>
                <p>
                  Proje klasöründe <pre class="prettyprint ms-0">docker build -t ubuntu-sleeper .</pre> yazılarak image oluşturulur ve <pre class="prettyprint ms-0">docker run ubuntu-sleeper</pre>yazarsak cotainer 4 sn açık kalır. sonra kendini kapatır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run ubuntu-sleeper sleep 10</pre> yazarsak 10 sn sonra container kapanır. <code>run</code> komutunda container adından sonra girilen komut <code>cmd</code> ile girdiğimiz yere override olur (üzerine yazılır).
                </p>

                <h4>v.2</h4>
                <p>
                  Dockerfile dosyası
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04

ENTRYPOINT [ "sleep" ]
                  </pre>
                  terminalde <pre class="prettyprint ms-0">docker build -t ubuntu-sleeper .</pre> yazılarak image oluşturulur ve <pre class="prettyprint ms-0">docker run ubuntu-sleeper 5</pre>yazarsak cotainer 5 sn açık kalır. sonra kendini kapatır. <pre class="prettyprint ms-0">docker run ubuntu-sleeper</pre> yazarsak terminal bize 
                  <pre class="prettyprint ms-0">
sleep: missing operand
Try 'sleep --help' for more information.
                  </pre> döner.
                </p>
                <p>
                  <code>ENTERYPOINT</code> terminalden gelen veriyle çalışır. Buna defaut değer atamak için hemen altında <code>CMD</code> kullanılır.
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04

ENTRYPOINT [ "sleep" ]
CMD ["4"]
                  </pre> 
                  Terminale değer girilmezse default olarak 4 alır.
                </p>
              </div>
              <div class="row" id="dockerComposeLesson">
                <h2>Docker Compose ile Servis Yönetimi</h2>
                <p>
                  Birden fazla container ayağa kaldırıp birlikte kullanma işlemlerinde docker compose kullanılır. 
                </p>
                <p>
                  Hoca docker compose a girmeden 2 Dockerfile örneği daha yapmak istiyor. Biz de öyle yaparız :D
                </p>

                <h3 id="dockerPythonApp">Uygulama 7 - Python App</h3>
                <p>
                  Yeni bir proje klasörü içine hocanın hazırlamış olduğu src/server.py dosyasını
                  <pre class="prettyprint ms-0">
from flask import Flask
server = Flask(__name__)

@server.route("/")
def hello():
    return "Hello World!"

if __name__ == "__main__":
    server.run(host='0.0.0.0')
                  </pre>
                  ve dependencies.txt dosyasını 
                  <pre class="prettyprint ms-0">
Flask==2.2.3
                  </pre>
                  ekledik.
                </p>
                <p>
                  Dockerfile dosyasını
                  <pre class="prettyprint ms-0">
FROM python:3.8-slim
WORKDIR /server
COPY dependencies.txt .
RUN pip install -r dependencies.txt
COPY src/ .
CMD ["python", "./server.py"]
                  </pre>
                  olarak yazdık.
                </p>
                <p>
                  Proje dosyasında terminale <pre class="prettyprint ms-0">docker build . -t python-app</pre> yazarak image oluşturduk. <pre class="prettyprint ms-0">docker run -p 3000:5000 python-app</pre> ile uygulama ayağa kaldırıldı.
                </p>

                <h3 id="dockerVueApp">Uygulama 8 - Vue App</h3>
                <p>
                  Hocanın hazırladığı örneği proje klasörümüze kopyaladık.
                </p>
                <p>
                  Dockerfile
                  <pre class="prettyprint ms-0">
FROM node:14-slim
WORKDIR /vue-app
COPY app/ .
RUN npm install
RUN npm install -g live-server
RUN npm run build
EXPOSE 8080
CMD [ "live-server", "dist" ]
                  </pre>
                </p>
                <p>
                  Proje dosyasında terminale <pre class="prettyprint ms-0">docker build . -t vue-app</pre> yazarak image alındı. <pre class="prettyprint ms-0">docker run -p 9000:8080 vue-app</pre> ile app ayağa kaldırıldı. <a href="http://localhost:9000/">http://localhost:9000/</a> ile uygulamaya ulaşılabiliyor.
                </p>

                <h3 id="dockerPurine">Her Şeyi Silmek (docker container prune)</h3>
                <p>
                  <code>docker contaşner prune</code> ile tüm containerlar silinir.
                </p>
                <p>
                  <code>docker images prune</code> ile tüm images silinir. <code>docker volume prune</code> ile de tüm volume silinir. Bu kalıp diğer bileşenlerde de uygulanabilir.
                </p>

                <h3 id="dockerCompose">Docker Compose</h3>
                <p>
                  Birden fazla container ayağa kaldırıp birlikte kullanma işlemlerinde docker compose kullanılır.
                </p>
                <p>
                  Docker compose için proje klasörümüzde docker-compose.yml adında bir dosya oluşturuyoruz. .yml YMAL file dosya uzantısıdır. Bilgi aktarımı için kullanılır. JSON ve xml e göre daha kolay ve basit bir kullanımı var. Key: value düzeni ile yazılır. value array ise <q>-</q> işareti ile alt alta yazılır. Subkey bir iç çıkıntıda yazılır. Bu nedenle intent (çıkıntı) kavramı çok önemli.
                </p>
                <p>
                  İlk önce <q>version</q> keyi yazılır. Dockerın hangi sürümünün kullanılacağını belirler. Bu yapılacak işlemleri etkiler.
                </p>
                <p>
                  sonra <q>services</q> altına çalıştırılacak containerlar yazılır.
                </p>

                <h3 id="dockerExm1">Örnek - 1: Tek Service</h3>
                <p>
                  önceki projelerde yaptığımız node server içindeki app.js, package.json ve package-lock.json proje klasörümüzde app klasörüne kopyalandı. Dockerfile ise direk proje klasörümüze kopyalandı. 
                </p>
                <p>
                  docker-compose.yml dosyası:
                  <pre class="prettyprint ms-0">
version: '3.4'
services:
  node-server: 
    container_name: my-server
    build: .
    ports: 
      - 3001:3000
                  </pre>
                  Dockerfile dosyası bazı işleri docker-compose.yml üzerine taşıdığımız için ve bazı klasörlerin yeri değiştiği için tekrar düzenlendi.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-server
COPY app/ .
RUN npm install
CMD ["node", "app.js"]
                  </pre>
                </p>
                <p>
                  Proje dizininde terminale <pre class="prettyprint ms-0">docker-compose build</pre> diyerek build aldırılır.
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker images</pre> yazdığımızda bizi <q>1-node-server-node-server</q> adında bir image karşılar. Burada ilk kısım klasörün adı (1-node-server) ikinci kısım da servisin adı (docker-compose.yml -> services: node-server: ...)
                </p>
                <p>
                  Proje dizininde terminale <pre class="prettyprint ms-0">docker-compose up</pre> diyerek çalıştırılır. Daha önce build alınmadıysa build alır ve sonra çalıştırır
                </p>

                <h3 id="dockerExm2">Örnek - 2: Multiple Service</h3>
                <p>
                  5-node-mongo-todo projesindeki Dockerfile yeni projemizin kök dizinine, app.js, package.json package-lock.js ve TodoModel.js yeni ptojenin app klasörüne eklendi.
                </p>
                <p>
                  Dockerfile dosyası aşağıdaki gibi düzenlendi.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-todo-app
COPY app/ .
RUN npm install
CMD ["node", "app.js"]
                  </pre>
                </p>
                <p>
                  docker-compose.yml dosyası:
                  <pre class="prettyprint ms-0">
version: '3.4'
services: 
  todo-app:
    container_name: dc-todo-app
    build: .
    ports:
      - 3000:3000
  mongodb: 
    image: mongo
    ports: 
      - 27017:27017
    volumes:
      - todo-app-data:/data/db
volumes: 
  todo-app-data:
                  </pre>
                </p>
                <p>
                  docker-compose ile volume eklerken container seviyesindeki volume name ana seviyede de belirtilmeli.
                </p>
                <p>
                  app/app.js içinde mondoDB bağlantısı için docker-compose.yml içindeki servis adı (mongodb) kullanılır.
                  <pre class="prettyprint ms-0">
app.listen(PORT, async () => {
  ...
  await Mongoose.connect("mongodb://mongodb:27017/todos", {
    ...
  });
  ...
});
                  </pre>
                </p>
                <p>
                  Değişiklik yaptığımızda <code>docker-compose up</code> yapmadan önce <code>docker-compose build</code> ile build almak gerekir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker-compose down</pre> projeyi durdurmanın en doğru yoludur. containerları tek tek kapatmak hataya neden olabilir.
                </p>

                <h3 id="dockerExm3">Örnek - 3: Upload Edilen Dosyanın Saklanması</h3>
                <p>
                  Hocanın uygulamasını proje klasörümüze app klaaörü içine ekledik.
                </p>
                <p>
                  Proje klasöründe Dockerfile dosyası eklendi.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /uploader-app
COPY app/. .
RUN npm i
EXPOSE 3000
CMD [ "node", "server.js" ]
                  </pre>
                  docker-compose.yml dosyası
                  <pre class="prettyprint ms-0">
version: "3.4"
services:
  uploader-app:
    build: .
    ports:
      - 3000:3000
    volumes:
      - uploader-app-uploads:/uploads
volumes:
  uploader-app-uploads:
                  </pre>
                  volume olarak dosyaların uygulamada yüklendiği "uploads" klasörünü gösterdik.
                </p>

                <h3 id="dockerExm4">Örnek - 4: Variable Environment kullanmak</h3>
                <p>
                  Bu seferki ürünü sadece docker-compose.yml ile oluşturduk. <a href="https://hub.docker.com/_/wordpress">hub.docker.com -> wordpress</a> dökümantasyonundan faydalandık.
                  <pre class="prettyprint ms-0">
version: '3.4'
services:
  wordpress:
    image: wordpress
    ports:
      - 8080:80
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: bloguser
      WORDPRESS_DB_PASSWORD: test123
      WORDPRESS_DB_NAME: blogdb
    volumes:
      - wordpress:/var/www/html
  db:
    image: mysql:5.7
    restart: always
    environment:
      MYSQL_DATABASE: blogdb
      MYSQL_USER: bloguser
      MYSQL_PASSWORD: test123
      MYSQL_RANDOM_ROOT_PASSWORD: "1"
    volumes:
      - db:/var/lib/mysql
volumes:
  wordpress:
  db:
                  </pre>
                </p>
                <code>services: db: </code> ile database oluşturuldu. db ismine dikkat. bunu diğer serviste <code>WORDPRESS_DB_HOST: db</code> olarak kullandık. 
                
                <h3 id="dockerExm5">Örnek - 5: Çalışmak İçin Diğer Containerların Çalışmasına İhtiyaç Duymak</h3>
                
                <p>
                  Bu projenin dosyalarını hoca paylaşmamış sadece docker-compose.yml üzerinde konuştuk.
                  <pre class="prettyprint ms-0">
version: '3,4'
services:
  twitter-app:
    build: .
    ports:
      - 3000:3000
    depends_on:
      - mongodb
      - redis
  mongodb:
    image: mongo:latest
    ports:
      - 27017:27017
    volumes:
      - data:/data/db
  redis:
    image: redis
    ports:
      - 6379:6379
volumes:
  data:
                  </pre>
                </p>
                <p>
                  <code>depends_on:</code> altına verilen servisler o servisin çalışması için gerekenleri tanımlar. Önce onlar çalışır. Sonra içine yazıldığı container çalışır.
                </p>
              </div>
              <div class="row">
                <h2>linuxDockerSetupProductionLginx</h2>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>