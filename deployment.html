<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">GraphQL</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          <li><a class="dropdown-item" href="GraphQL.html" target="_blank">GraphQL</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#docker">Docker</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsDocker">Docker Nedir? Nasıl Kullanılır?</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#dockerSetup">Docker Kurulumu</a>
                      <a class="nav-link ms-4 my-1" href="#dockerHub">DockerHub</a>
                      <a class="nav-link ms-4 my-1" href="#dockerImage">İmage Çekme ve Açma</a>
                      <a class="nav-link ms-4 my-1" href="#dockerContainerName">Container İsimlendirme (--name)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerContainerRm">Container Silme (rm) ve Image Silme (rmi)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerTag">Tag Nedir?</a>
                      <a class="nav-link ms-4 my-1" href="#dockerDetachAttachLog">Detach mode (-d), Attach mode (attach) ve Log</a>
                      <a class="nav-link ms-4 my-1" href="#dockerIt">İnteraktif Terminal (-it)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerPortMapping">Port Mapping (-p)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerVolumeMapping">Volume Mapping (-v)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerInspect">docker inspect &lt;...></a>
                      <a class="nav-link ms-4 my-1" href="#dockerEnvironmentVariable">Environment Variable (-e) ve Linkleme (--link)</a>
                    </nav>
                  </nav>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#dockerNetwork">Docker Network Türleri</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#dockerUserCustomNetwork">Kullanıcı Tanımlı Network</a>
                      <a class="nav-link ms-4 my-1" href="#dockerSameNetworkAppTalk">Uygulama Örneği: Aynı Network Üzerinden Containerların Konuşması (NodeJs - MongoDB)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerMyImage">Kendimize Ait Image Oluşturmak</a>
                      <a class="nav-link ms-4 my-1" href="#dockerNodeBaseImage">Uygulama 2 - Aynı İşi Hazır Node BaseImage İle Yapmak</a>
                      <a class="nav-link ms-4 my-1" href="#dockerNodeServer">Uygulama 3 - Node Server</a>
                      <a class="nav-link ms-4 my-1" href="#dockerSimplePhp">Uygulama 4 - Simple PHP App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerMondoTodo">Uygulama 5 - Mondo Todo App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerCMDandENTERYPOINT">CMD ve ENTERYPOINT</a>
                      <a class="nav-link ms-4 my-1" href="#dockerUbuntuSleeper">Uygulama 6 - Ubuntu Sleeper</a>
                    </nav>
                  </nav>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#dockerComposeLesson">Docker Compose ile Servis Yönetimi</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#dockerPythonApp">Uygulama 7 - Python App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerVueApp">Uygulama 8 - Vue App</a>
                      <a class="nav-link ms-4 my-1" href="#dockerPurine">Her Şeyi Silmek (docker container prune)</a>
                      <a class="nav-link ms-4 my-1" href="#dockerCompose">Docker Compose</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm1">Örnek - 1: Tek Service</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm2">Örnek - 2: Multiple Service</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm3">Örnek - 3: Upload Edilen Dosyanın Saklanması</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm4">Örnek - 4: Variable Environment kullanmak</a>
                      <a class="nav-link ms-4 my-1" href="#dockerExm5">Örnek - 5: Çalışmak İçin Diğer Containerların Çalışmasına İhtiyaç Duymak</a>
                    </nav>
                  </nav>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#linuxDockerSetupProductionLginx">Linux'a Docker Kurulumu,<br>Production,Nginx</a>
                    <nav class="nav nav-pills flex-column">
                      <a class="nav-link ms-4 my-1" href="#dockerCloudExm1">Örnek 1: Docker Compose ile Wordpress Site Ayağa Kaldırma.</a>
                      <a class="nav-link ms-4 my-1" href="#dockerCloudNginxReverseProxy">Nginx kurulumu ve Reverse Proxy tanımı</a>
                      <a class="nav-link ms-4 my-1" href="#dockerCloudExm2">Örnek 2: Docker Compose ile Aynı Hostta Asana Clone Ayağa Kaldırma.</a>
                    </nav>
                  </nav>
                  <a class="nav-link" href="#kubernetes">Kubernetes</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#enterKubernetes">Kubernetes'e Giriş</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesMaster">Master'a Genel Bakış</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesNode">Node'a Genel Bakış</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesHowWork">Kubernetes'in Çalışma Prensipleri</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesSetup1">Kubernetes Kuruyoruz-1</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesSetupMaster">Kubernetes Kuruyoruz-Master</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesSetupNode">Kubernetes Kuruyoruz-Node</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesTraffic">NodePort - ClusterIP - LoadBalancer - Ingress</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesDaemonset">Daemonset ve Kullanımı</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesImperativeDeclarative">Imperative ve Declarative Yöntemler</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesPod">Pod Yaşam Döngüsü ve Probe'lar</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesCrusterLog">Cluster'da Loglama</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesReplication">Replication Yöntemlerine Genel Bakış</a>
                    <a class="nav-link ms-3 my-1" href="#kubernetesKubectlFirsDeployment">Kubectl ve İlk Deployment</a>
                  </nav>
                  <a class="nav-link" href="#heroku">Heroku yerine Deta.Space</a>
                  <a class="nav-link" href="#diger">Diğer Eğitimlerdeki Deployment Örnekleri</a>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div class="row" id="docker">
              <h1>Docker</h1>
              <p>
                Hocanın dökümantasyonu <a href="https://github.com/gkandemi/docker">https://github.com/gkandemi/docker</a>
              </p>
              <div class="row" id="whatIsDocker">
                <h2>Docker Nedir? Nasıl Kullanılır?</h2>
                <p>
                  Proses izolasyonu sağlar. Çalıştırılan programın ortamı, ortamın da uygulamayı etkilemesini engeller.
                </p>
                <p>
                  <b>Container</b> kendine ait prosesleri, servisleri ve ağı olan. Aymı işletim sistemi veya virtual machine (VM) üzerinde çalışan, diğer ortamlardan izole edilmiş ortamlardır.
                </p>
                <p>
                  Docker, container ile işletim sistemi kerneli arasında bağlantıyı sağlar. 
                </p>
                <p>
                  Docker container işini kolaylaştırmak için bize birçok high level araç sunar.
                </p>
                <p>
                  Docker LXC container türü kullanır. 
                </p>
                <p>
                  Windows üzerine docker yüklendiğinde Docker araya otomatik olarak linux VM yükler ve containerları kendisinin yüklediği linux VM üzerinden yönetir.
                </p>
                <p>
                  Container çalışan yapılardır. Kaynak kod image içinde.
                </p>
                <p>
                  <b>image</b> içinde birçok yapıyı barındırabilir. Containerin nasıl çalışacağını anlatır. image çalıştırıldığında container oluşturur. Bu image dosyaları genelde bulutta tutulur. Docker için genelde <a href="https://hub.docker.com/">Docker Hub</a> kullanılır. İmageı çalıştırdığımızda elde ettiğimiz proses containerdır. İmage çalışmayı durdurduğunda container ortadan kalkar.
                </p>
                <p>
                  <b>DockerHub</b> üzerinden ubuntu indirmek için <code>docker pull ubuntu</code>. docker imajından ubuntu çalıştırmak için <code>docker run ubuntu</code> bilgisayarda yoksa image dosyasını kendisi çeker ve çalıştırır. 
                </p>

                <h3 id="dockerSetup">Docker Kurulumu</h3>
                <p>
                  <a href="https://www.docker.com/get-started/">docker.com</a> adresinden indir ve kur.
                </p>

                <h3 id="dockerHub">DockerHub</h3>
                <p>
                  <a href="https://hub.docker.com/">https://hub.docker.com/</a>
                </p>
                <p>
                  dockerhub>"Explore" filtrelemede 
                  <ul>
                    <li>"verified publisher": kendi yayıncısı tarafından dockerize edildiği ve yüklendiği image dosyaları.</li>
                    <li>"offical images": büyük şirketlerin ürünlerinin docker tarafından dockerize edildiği ve yüklendiği image dosyaları.</li>
                  </ul>
                </p>

                <h3 id="dockerImage">İmage Çekme ve Açma</h3>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker pull ubuntu</pre> yazdık. Dockerhub üzerinden ubuntuyu çekti
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker pull mongo</pre> yazdık. Dockerhub üzerinden mongoyu çekti
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker images</pre> yazdığımızda indirmiş olduğumuz docker images listelenir
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run redis</pre> yazdığımızda redis lokalde varsa çalışır. Yoksa image indirilir ve çalıştırılır. Çalıştığını terminalde görürüz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run ubuntu</pre> ile ubuntu çalışır ama hemen geri kapanır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run ubuntu sleep 5</pre> ile ubuntu açılır 5 sn bekler ve kapanır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -it ubuntu</pre> ile ubuntu açılır ve içinde işlem yapılabilir. <code>-it</code> interaktif terminal anlamında.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker ps</pre> veya <pre class="prettyprint ms-0">docker conlainer ls</pre> ayakta olan containerları gösterir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker ps -a</pre> veya <pre class="prettyprint ms-0">docker ps --all</pre> veya <pre class="prettyprint ms-0">docker conlainer ls -a</pre> ayakta olan olmayan tüm containerları gösterir
                </p>

                <h3 id="dockerContainerName">Container İsimlendirme (--name)</h3>
                <p>
                  <pre class="prettyprint ms-0">docker run -it --name bash_ubuntu ubuntu</pre> olarak yazdığızda container <b>bash_ubuntu</b> adını alır ve isim altında ayarları da kaydedilir. <pre class="prettyprint ms-0">docker start bash_ubuntu</pre> yazarak ismini ve özelliklerini kaydettiğimiz container ayağa kaldırılır. Terminalde kaybolur. Arka planda çalışır. <pre class="prettyprint ms-0">docker stop bash_ubuntu</pre> ile kapatılır.
                </p>
                <p>
                  <code>docker stop &lt;container-name></code> kısmında &lt;container-name> yerine &lt;container-id> nin baştan ilk 2 ve daha fazla karakteri girilerek de durdurma işlemi yapılabilir. container id lerin ilk kısmında çakışma olursa daha çok karakter girmek gerekir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker ps -a</pre> ile listelediğimiz herhangi bir container bu yöntemle açılabilir ve kapatılabilir.
                </p>

                <h3 id="dockerContainerRm">Container Silme (rm) ve Image Silme (rmi)</h3>

                <h4>Container Silme (rm)</h4>
                <p>
                  <pre class="prettyprint ms-0">docker ps -a</pre> ile listelenenleri silmek için <pre class="prettyprint ms-0">docker rm &lt;container-name></pre> yazarak tek tek silebiliriz. <code>docker start</code> ve <code>docker stop</code> kodlarındaki gibi name yerine idnin başı yazılabilir. Id veya name boşluk bırakılarak birden fazla yazılabilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker container rm $(docker container ls -aq)</pre> tüm idleri silme fonksiyonuna taşıyarak tüm containerları siler.
                </p>

                <h4>Image Silme (rmi)</h4>
                <p>
                  <pre class="prettyprint ms-0">docker images</pre> ile listelenenleri silmek için <pre class="prettyprint ms-0">docker rmi &lt;image-name></pre> yazarak tek tek silebiliriz.
                </p>

                <h3 id="dockerTag">Tag Nedir?</h3>
                <p>
                  sürüm?
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run redis:5</pre> redisin 5. sürümünü indirir ve çalıştırır.
                </p>
                  <pre class="prettyprint ms-0">docker image tag &lt;image name veya id> &lt;new tag name></pre> ile images name değiştirilir.
                <p>
                  <pre class="prettyprint ms-0">docker image tag ubuntu my_ubuntu</pre> ile my_ubuntu adında bir ubuntu kopyası elde ederiz.
                </p>

                <h3 id="dockerDetachAttachLog">Detach mode (-d), Attach mode (attach) ve Log</h3>
                <p>
                  <b>Detach mode</b>: Çalıştırılan imageın oluşturduğu container arka planda çalışsın.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -d redis</pre>
                </p>
                <p>
                  <b>Attach mode</b>: detach modda çalışan uygulamayı öne getirir
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker attach &lt;container id veya name></pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker attach bold_meitner</pre> ile bold_meitner isimli container öne getirilir.
                </p>
                <p>
                  <b>Log</b>: detach modda çalışan uygulamanın verdiği logları görmek için kullanılır.
                  <pre class="prettyprint ms-0">docker container logs &lt;container id veya name></pre>
                </p>

                <h3 id="dockerIt">İnteraktif Terminal (-it)</h3>
                <p>
                  kullanıcı girişli bir uygulamanız varsa kullanıcı girişini (interaktif terminal) açabilmek için -it flagi kulanılır.
                  <pre class="prettyprint ms-0">docker run -it gkandemir/interactive-terminal-app</pre>
                </p>

                <h3 id="dockerPortMapping">Port Mapping (-p)</h3>
                <p>
                  <pre class="prettyprint ms-0">docker run -p Dış_port:iç_port image_name</pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -d 27018:27017 mongo</pre> dışarıdan biz bağlandığımızda 27018 portunu kullanır. docker içinde ise default portu olan 27017 kullanılır. mongoDBCompass <code>mongodb://localhost:27018</code> ile bu mongoya bağlanabilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run gkandemir/node-app</pre> yazdığımızda terminalde <pre class="prettyprint ms-0">Example app listening at http://localhost:3000 </pre> yazar ancak biz buna web tarayıcımızdan erişemeyiz. Çünkü 3000 portu docker içi için geçerlidir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -p 3001:3000 gkandemir/node-app</pre> yazdığımızda dış portu olan 3001 portuna web tarayıcıya "http://localhost:3001/" yazarak ulaşabiliriz.
                </p>
                <p>
                  Birden fazla container birden fazla portta eş zamanlı çalıştırabiliriz.
                </p>

                <h3 id="dockerVolumeMapping">Volume Mapping (-v)</h3>
                <p>
                  Dockerhost üzerinde containerlar stateless olarak çalışır. Yani içindeki bilgileri kayıt etmez. Container durduğunda içindeki bilgiler silinir.
                </p>
                <p>
                  Kaydedilecek bilgiler için <b>volume</b> kullanılır. Bir containerı ayağa kaldırdığımızda kayıt edilecek klasörün adresini docker host üzerinden bildiririz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -v /opt/data:/data/db mongo</pre> data/db içinde değişiklik olduğunda host içinde opt/data içine kaydet. Çalışırken de buradaki datayı al.
                </p>
                <p>
                  hangi dosyanın veri tutuğunu ve kaydedilmesi gerektiğini dökümantasyondan bulabiliriz.
                </p>
                <p>
                  docker içinde datanın tutulduğu klasörün docker desktop tarafından bilinen ve izin verilmiş bir klasör olması gerekiyor. (windowsta buna gerek yok. Herhangi bir dizini kabul ediyor.)
                  <pre class="prettyprint ms-0">docker run -v /myData/data:/data/db mongo</pre>
                </p>
                <p>
                  Bizim kullandığımız docker versiyonunda volume almaya gerek var mı emin değilim. Her container açtığımda zaten Docker Desktop üzerinde bir volume açılıyor gibi. Belki image her container haline getirilirken bu veriyi de alması için kullanılyor olabilir.
                </p>

                <h3 id="dockerInspect">docker inspect &lt;...></h3>
                <p>
                  <b>container</b> hakkında bilgi almak için <pre class="prettyprint ms-0"> docker inspect &lt;container name veya id></pre> yazıyoruz.
                </p>
                <p>
                  Gelen ekranda "HostConfig" > "Binds" kısmında array olarak volume alınacak dosyalar mevcut. "HostConfig" > "PortBindings" port yönlendirmesini verir.
                </p>
                <p>
                  "Config" > "ExposedPosts" docker içindeki portu verir. "NetworkSettings" > "Ports" iç ve dış portunu verir.
                </p>

                <p>
                  <b>image</b> hakkında bilgi almak için <pre class="prettyprint ms-0"> docker inspect &lt;image name veya id></pre> yazıyoruz.
                </p>

                <h3 id="dockerEnvironmentVariable">Environment Variable (-e) ve Linkleme (--link)</h3>
                <p>
                  <pre class="prettyprint ms-0">docker run -e MYSQL_ROOT_PASSWORD=test123 -d mysql</pre>
                  -e den sonraki kısım environment variable
                </p>

                <h4>MySQL - phpmyadminproject</h4>
                <p>
                  <pre class="prettyprint ms-0">docker pull phpmyadmin/phpmyadmin</pre> ile phpmyadmin image indirildi. mysql ile bunu bağlayacağız.
                </p>
                <p>
                  Önce bağlanılacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=test123 -d mysql</pre>
                </p>
                <p>
                  Sonra bağlanacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name pmyadmin -p 8000:80 --link mysql-server:db -d phpmyadmin/phpmyadmin</pre> <code>--link</code> ten sonra bağlanacağı container name ve <code>:</code> sonrası bağlanacağı alias(takma ad) yazılır. Bu kısım dökümantasyonda verilir.
                </p>
                <p>
                  Tarayıcıda <a href="http://localhost:8000/">http://localhost:8000/</a> yazıp phpmyadmin açılır. kullanıcı adı: root, pass: test123 yazılarak mysql databasee bağlanılır.
                </p>

                <h4>Volume eklenmiş örnek</h4>

                <p>
                  Önce bağlanılacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name mysql-server -p 3306:3306 -v /opt/data:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=test123 -d mysql</pre>
                </p>
                <p>
                  Sonra bağlanacak olan çalıştırılır. <pre class="prettyprint ms-0">docker run --name pmyadmin -p 8000:80 --link mysql-server:db -d phpmyadmin/phpmyadmin</pre> <code>--link</code> ten sonra bağlanacağı container name ve <code>:</code> sonrası bağlanacağı alias(takma ad) yazılır. Bu kısım dökümantasyonda verilir.
                </p>
                <p>
                  Tarayıcıda <a href="http://localhost:8000/">http://localhost:8000/</a> yazıp phpmyadmin açılır. kullanıcı adı: root, pass: test123 yazılarak mysql databasee bağlanılır.
                </p>
              </div>
              <div class="row" id="dockerNetwork">
                <h2>Docker Network Türleri</h2>
                <p>
                  Dockerda 3 tür default network var: bridge, none, host
                </p>
                <p>
                  <b>bridge network</b>: default olarak kaldırılan image ile aldığımız neteork. Containerlar birbirine bir gateaway üzerinden bağlanıyor.
                </p>
                <p>
                  <b>none network</b>: dışarıdan erişilememesi için tanımlanmış network. Örn: <code>docker run mongo --network=none</code>
                </p>
                <p>
                  <b>host network</b>: docker host üzerinden sadece port numarası eklenerek ulaşılan network Örn: <code>docker run mongo --network=host</code>
                </p>

                <h3 id="dockerUserCustomNetwork">Kullanıcı Tanımlı Network</h3>
                <p>
                  Kullanıcının kendisinin tanımladığı network örn: <code>docker network create --driver bridge --subnet 182.18.0.0/16 --gateway 182.18.0.1 todo-app-network</code>
                </p>

                <p>
                  <pre class="prettyprint ms-0">docker network ls</pre> veya <pre class="prettyprint ms-0">docker network list</pre> ile tüm network görüntülenebilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker network rm &lt;network-name veya id></pre> ile network silinebilir.
                </p>
                <p>
                  Normalde mongoDB gibi bir databasei uygulamamıza bağlarken 
                  <pre class="prettyprint ms-0">
...
await Mongoose.connect("mongodb://localhost:27017/todos")
...
                  </pre>
                  daki gibi localhost veya sabit bir ip kullanılır. Docker içinde her çalışmada ip sabit kalmadığından biz bunun yerine container name kullanırız.
                  <pre class="prettyprint ms-0">
...
await Mongoose.connect("mongodb://mongo-server:27017/todos")
...
                  </pre>
                </p>

                <h3 id="dockerSameNetworkAppTalk">Uygulama Örneği: Aynı Network Üzerinden Containerların Konuşması (NodeJs - MongoDB)</h3>

                <p>
                  <pre class="prettyprint ms-0">docker pull gkandemir/todo-app</pre> ile hocanın bu iş için oluşturduğu uygulamayı çektik.
                </p>
                <p>
                  Önce networkü oluşturuyoruz: <pre class="prettyprint ms-0">docker network create --driver bridge --subnet 182.18.0.1/24 --gateway 182.18.0.1 custom-network</pre> <code>--driver</code> ile türünü belirttik. <code>--subnet</code> ile çalışma aralığını <code>--gateway</code> ile gatewayini belirttik. En son <code>custom-network</code> ise bizim ona verdiğimiz adı belirtti.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker inspect &lt;id></pre> ile oluşan networkü inceleyebiliriz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --name mongo-server --net custom-network -d mongo</pre> <code>--name mongo-server</code> kısmı uygulamamızda kullanacağımız container name ile aynı olmalı. <code>--net custom-network</code> bağlanacağı networkü seçtik.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --net custom-network -p 3000:3000 gkandemir/todo-app</pre> <code>--net custom-network</code> ile ağa bağlandık. Dışarıdan da ulaşabilmek için <code>-p 3000:3000</code> ile port mapping yaptık.
                </p>
                <p>
                  postman ile http://localhost:3000 üzerinden bağlanıp data gönderebiliyoruz.
                </p>
                <p>
                  Bu bağlantıyı link yöntemi ile yapsaydık kod içinde alias tanımlamak gerekecekti.
                </p>

                <h3 id="dockerMyImage">Kendimize Ait Image Oluşturmak</h3>
                <p>
                  <pre class="prettyprint ms-0">docker pull ubuntu:18.04</pre> ile ubuntu v18.04 çekildi.
                  <pre class="prettyprint ms-0">docker run -it ubuntu:18.04</pre> ile ubuntu container içine girildi.
                </p>
                <p>
                  ubuntu içinde terminale <pre class="prettyprint ms-0">apt-get update</pre> yazarak güncellemeler yapıldı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">apt-get install curl -y</pre> ile curl kuruldu.
                  <pre class="prettyprint ms-0">curl -sL https://deb.nodesource.com/setup_10.x | bash</pre> ile node.js indirildi. <pre class="prettyprint ms-0">apt-get install nodejs -y</pre> ile indirilen nodejs kuruldu.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
cd opt
mkdir node-app
cd node-app
                  </pre> ile bir dosya oluşturuldu ve içine girildi.
                </p>
                <p>
                  <pre class="prettyprint ms-0">echo 'console.log("nodejsapp from ubuntu ...");' > index.js</pre> ile index.js dosyası oluşturuldu ve içine <code>console.log("nodejsapp from ubuntu ...");</code> yazıldı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">node index.js</pre> yazdığımızda terminalde <pre class="prettyprint ms-0">nodejsapp from ubuntu ...</pre> yazısı belirdi. Bu da bize node.jsin ubuntuda düzgün çalıştığını gösterdi.
                </p>
                <p>
                  ubuntuda <pre class="prettyprint ms-0">history</pre> yazınca o zamana kadar ubuntu terminalinde yaptıklarımızı listeler.
                  <pre class="prettyprint ms-0">
1  apt-get update
2  apt-get install curl -y
3  curl -sL https://deb.nodesource.com/setup_10.x | bash
4  apt-get install nodejs -y
5  ls
6  cd opt
7  ls
8  mkdir node-app
9  ls
10  cn note-app
11  cd note-app
12  ls
13  cd node-app
14  echo 'console.log("nodejsapp from ubuntu ...");' > index.js
15  ls
16  node index.js
17  history
                  </pre>
                </p>

                <h4>Image Dosyasını Hazırlamak</h4>
                <p>
                  Bir proje klasörü oluşturduk ve içinde index.js
                  <pre class="prettyprint ms-0">
console.log("Hello from ubuntu")
                  </pre> ve Dockerfile dosyası daha önce aldığımız <q>histori</q>ye göre oluşturuldu.
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install curl -y
RUN curl -sL https://deb.nodesource.com/setup_10.x | bash
RUN apt-get install nodejs -y
COPY . /opt/node-app/
# Yukarıdaki kısım imageden container oluşturmak için
# aşağıdaki kısım oluşan containerın çalışma anında çalışacak kısım.
# CMD [ "node", "/opt/node-app/index.js" ]
WORKDIR /opt/node-app/
CMD [ "node", "index.js" ]
                  </pre>
                  oluşturuldu. 
                </p>
                <p>
                  Dockerfile dosyasında önce containerın açılacağı image <code>FROM</code> ile belirlendi. Sonra bunun içindeki işlemler <code>RUN</code> ile oluşturuldu. <code>COPY . /opt/node-app/</code> komutu ile bu dizindeki tüm dosyalar container içinde belirtilen yere eklendi. Bu kısım image -> container işlemi için gerekli.
                </p>
                <p>
                  <code>WORKDIR</code> ile bundan sonra çalışılacak dizin belirlendi. <code>CMD [ "node", "index.js" ]</code> ile container çalışmaya başladığında yapacağı iş tanımlandı.
                </p>

                <h4>Image almak</h4>
                <p>
                  Proje dosyasında terminal açıldı.
                  <pre class="prettyprint ms-0">docker build .</pre> işlemi bende hata verdi. <pre class="prettyprint ms-0">docker system prune</pre> ile dockerı tamamen temizleyip tetkrar deneyince oldu :D
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker images</pre> yazınca bizim oluşturduğumuz image de listeleniyor.
                </p>
                <p>
                  isim vermek için <pre class="prettyprint ms-0">docker build . -t simple-node-app</pre>
                </p>
                <p>
                  Dockerfile içindeki her işlem adımı docker içerisinde layer olarak tutulur. Başka bir image için aynı şeye gerek olduğunda işlem oradan kopyalanır. Bu nedenle zaten dockerımızda olan bir işlem yapıldığında çok hızlı yapar.
                </p>

                <h4>ENV ile Çalışmak</h4>
                <p>index.js aşağıdaki gibi güncellendi.
                  <pre class="prettyprint ms-0">
console.log("Hello from ubuntu")
console.log("env =>", process.env.channel)
                  </pre>
                </p>
                <p>
                  Dockerfile içine ENV olarak eklendi.
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install curl -y
RUN curl -sL https://deb.nodesource.com/setup_10.x | bash
RUN apt-get install nodejs -y
COPY . /opt/node-app/
# 
ENV channel=kablosuzkedi
# Yukarıdaki kısım imageden container oluşturmak için
# aşağıdaki kısım oluşan containerın çalışma anında çalışacak kısım.
# CMD [ "node", "/opt/node-app/index.js" ]
WORKDIR /opt/node-app/
CMD [ "node", "index.js" ]
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker build . -t simple-node-app</pre>
                  ile tekrar build alınır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run simple-node-app</pre> ile çalıştırıldı ve treminalde aşağıdaki çıktı alındı.
                  <pre class="prettyprint ms-0">
Hello from ubuntu
env => kablosuzkedi
                  </pre>
                </p>
                <p>
                  Dockerfile doldururken en üstte muhakkak baseimage olmalı.
                </p>

                <h3 id="dockerNodeBaseImage">Uygulama 2 - Aynı İşi Hazır Node BaseImage İle Yapmak</h3>
                <p>
                  Yeni bir proje klasörü oluşturuldu ve index.js önceki projeden kopyalandı
                </p>
                <p>
                  Dockerfile
                  <pre class="prettyprint ms-0">
FROM node
WORKDIR /opt/node-app
COPY . .
ENV channel=kablosuzkedi
CMD [ "node", "index.js" ]
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker build . -t simple-node-app-2</pre> ile image oluşturulur.
                </p>
                <p>
                  image dosyası 1.1 GB. Bıyutu daha önce kendimizin ubuntu ile yaptığından daha büyük. Bu nedenle node versiyonunu 16-slim ile değiştirdik.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-app
COPY . .
ENV channel=kablosuzkedi
CMD [ "node", "index.js" ]
                  </pre>
                </p>
                <p>
                  Önceki image silindi <pre class="prettyprint ms-0">docker rmi simple-node-app-2</pre> ve yeniden image alındı
                  <pre class="prettyprint ms-0">docker build . -t simple-node-app-2</pre>
                </p>
                <p>
                  İmage dosyamız şimdi 179MB :D
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run simple-node-app-2</pre> yazdığımızda terminalde
                  <pre class="prettyprint ms-0">
Hello from ubuntu
env => kablosuzkedi
                  </pre>
                  cevabı alındı.
                </p>

                <h3 id="dockerNodeServer">Uygulama 3 - Node Server</h3>
                <p>
                  Yeni bir proje klasörü oluşturuldu ve içine App.js eklendi.
                  <pre class="prettyprint ms-0">
const express = require("express");
const app = express();
const PORT = process.env.PORT || 3000;

app.get("/", (req, res) => {
  res.send("hello world");
});

app.listen(PORT, () => {
  console.log(`Example app listening at http://localhost:${PORT}`);
});
                  </pre>
                </p>
                <p>
                  npm paketlerini kullanabilmek için terminale <pre class="prettyprint ms-0">npm init -y</pre> yazdık. Sonra express modülünü indirmek için <pre class="prettyprint ms-0">npm install --save express</pre> yazıldı.
                </p>
                <p>
                  Bu hali ile çalıştırdığımızda server lokalde çalışıyor.
                </p>
                <p>
                  image alırken "node_modules" klasörünü da kopyalamamak için ".dockerignore" klasörü oluşturuldu ve içine
                  <pre class="prettyprint ms-0">node_modules/</pre> yazıldı.
                </p>
                <p>
                  Dockerfile dosyası oluşturuldu.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-server
COPY . .
RUN npm install
CMD ["node", "app.js"
                  </pre>
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run simple-node-server</pre> ile image container haline gelir ve çalıştırılır. Terminalde <pre class="prettyprint ms-0">Example app listening at http://localhost:3000</pre> çıktısı alınır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run -p 3001:3000 simple-node-server</pre> ile dışarıya port açılır ve <a href="http://localhost:3001/">http://localhost:3001/</a> üzerinden görülebilir.
                </p>
                
                <h3 id="dockerSimplePhp">Uygulama 4 - Simple PHP App</h3>
                <p>
                  Yeni bir uygulama klasörü oluşturduk. İçinde index.php dosyası oluşturduk.
                  <pre class="prettyprint ms-0">
&lt;?php
    echo "PHP Uygulamasını Dockerize Etmek...";
?>
                  </pre>
                  Dockerfile dosyası oluşturup içine:
                  <pre class="prettyprint ms-0">
FROM php:7-apache
COPY index.php /var/www/html/index.php
EXPOSE 80
CMD ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"]
                  </pre>
                  yazıldı.
                </p>
                <p>
                  Proje klasöründe terminale <pre class="prettyprint ms-0">docker build . -t simple-php-app</pre> yazılarak image oluşturuldu.
                  <pre class="prettyprint ms-0">docker run -p 8080:80 simple-php-app</pre> diyerek uygulama up edilir. <a href="http://localhost:8080/">http://localhost:8080/</a> üzerinden de görüntülenebilir.
                </p>

                <h3 id="dockerMondoTodo">Uygulama 5 - Mondo Todo App</h3>
                <p>
                  Yeni bir proje klasörü açtık ve hocanın hazır kodlarını kullandık.
                </p>
                <p>
                  App.js
                  <pre class="prettyprint ms-0">
const express = require("express");
const bodyParser = require("body-parser");
const cors = require("cors");
const app = express();
const { TodoModel } = require("./TodoModel");
const Mongoose = require("mongoose");
const PORT = process.env.PORT || 3000;

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(cors());

app.get("/", (req, res) => {
  TodoModel.find({})
    .then((todoList) => res.status(200).json(todoList))
    .catch((e) => res.status(500).json(e));
});

app.post("/todo", (req, res) => {
  const todo = new TodoModel({
    ...req.body,
    created_at: new Date(),
  });

  todo
    .save()
    .then((savedTodo) => res.status(200).json(savedTodo))
    .catch((e) => res.status(400).json(e));
});

app.listen(PORT, async () => {
  console.log(`Sunucu çalışıyor... ${PORT} | MongoDB'ye bağlanılacak..`);
  await Mongoose.connect("mongodb://mongo-alias:27017/todos", {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  });
  console.log("MongoDB'ye bağlantı başarılı!");
});
                  </pre>
                  TodoModel.js
                  <pre class="prettyprint ms-0">
const Mongoose = require("mongoose");

const todoSchema = new Mongoose.Schema({
  title: String,
  description: String,
  completed: Boolean,
  created_at: Date,
});

module.exports = {
  TodoModel: Mongoose.model("todo", todoSchema),
};
                  </pre>
                  package.json 
                  <pre class="prettyprint ms-0">
{
  "name": "node-mongo",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "body-parser": "^1.19.0",
    "cors": "^2.8.5",
    "express": "^4.17.1",
    "mongoose": "^5.11.13"
  },
  "devDependencies": {
    "nodemon": "^2.0.7"
  }
}
                  </pre>
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">npm i</pre> yazıp bağımlılıkları indirdik. 
                </p>
                <p>
                  .dockerignore dosyasına <pre class="prettyprint ms-0">node_modules/</pre> yazdık. 
                </p>
                <p>
                  Dockerfile dosyasına
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-todo-app
COPY . .
ENV PORT=4000
EXPOSE 4000
RUN npm install
CMD ["node", "app.js"]
                  </pre>
                  yazdık.
                </p>
                <p>
                  proje klasörünü terminalde açıp <pre class="prettyprint ms-0">docker build . -t todo-app</pre> yazarak image aldık.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --name mongo-server -p 27017:27017 -d mongo</pre> ile mongo server ayağa kaldırıldı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run --link mongo-server:mongo-alias -p 4000:4000 todo-app</pre> <code>--link mongo-server:mongo-alias</code> kısmında mongo-server adındaki containera bağlan, bu bağlantı senin kodunda mongo-alias olarak geçiyor dedik. app.js kodunu incelersek orada <code>await Mongoose.connect("mongodb://mongo-alias:27017/todos"...)</code> kullanımını görürüz.
                </p>

                <h3 id="dockerCMDandENTERYPOINT">CMD ve ENTERYPOINT</h3>
                <p>
                  <b>CMD</b> Container ayağa kalktığında çalışacak fonksiyon. CMD tam bir fonksiyondur. Container çalıştığında çalışır. CMD override edilebilir.
                </p>
                <p>
                  <b>ENTERYPOINT</b> sadece executable komut içerir. Komutun parametresini çalışma anında bizden bekler. Yoksa çalışmaz. Varsayılan değer atamak için Dockerfile içinde hemen altında CMD ile varsayılan değer belirtilebilir.
                </p>
                <p>
                  Container yapılacak bir işlem varsa açık kalır yoksa kapanır. 
                </p>

                <h3 id="dockerUbuntuSleeper">Uygulama 6 - Ubuntu Sleeper</h3>

                <h4>v.1</h4>
                <p>
                  Yeni proje klasörü aç. Dockerfile dosyası
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04
CMD ["sleep", "4"] 
#  Bu yazım şeklinde 1. komut executable (çalıştırılabilir) olmalı. Devamında array olarak parametreler girilir.

# CMD sleep 4
# Bu yazımda direk çalıştırılacak kod yazılır.
                  </pre>
                </p>
                <p>
                  Proje klasöründe <pre class="prettyprint ms-0">docker build -t ubuntu-sleeper .</pre> yazılarak image oluşturulur ve <pre class="prettyprint ms-0">docker run ubuntu-sleeper</pre>yazarsak cotainer 4 sn açık kalır. sonra kendini kapatır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker run ubuntu-sleeper sleep 10</pre> yazarsak 10 sn sonra container kapanır. <code>run</code> komutunda container adından sonra girilen komut <code>cmd</code> ile girdiğimiz yere override olur (üzerine yazılır).
                </p>

                <h4>v.2</h4>
                <p>
                  Dockerfile dosyası
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04

ENTRYPOINT [ "sleep" ]
                  </pre>
                  terminalde <pre class="prettyprint ms-0">docker build -t ubuntu-sleeper .</pre> yazılarak image oluşturulur ve <pre class="prettyprint ms-0">docker run ubuntu-sleeper 5</pre>yazarsak cotainer 5 sn açık kalır. sonra kendini kapatır. <pre class="prettyprint ms-0">docker run ubuntu-sleeper</pre> yazarsak terminal bize 
                  <pre class="prettyprint ms-0">
sleep: missing operand
Try 'sleep --help' for more information.
                  </pre> döner.
                </p>
                <p>
                  <code>ENTERYPOINT</code> terminalden gelen veriyle çalışır. Buna defaut değer atamak için hemen altında <code>CMD</code> kullanılır.
                  <pre class="prettyprint ms-0">
FROM ubuntu:18.04

ENTRYPOINT [ "sleep" ]
CMD ["4"]
                  </pre> 
                  Terminale değer girilmezse default olarak 4 alır.
                </p>
              </div>
              <div class="row" id="dockerComposeLesson">
                <h2>Docker Compose ile Servis Yönetimi</h2>
                <p>
                  Birden fazla container ayağa kaldırıp birlikte kullanma işlemlerinde docker compose kullanılır. 
                </p>
                <p>
                  Hoca docker compose a girmeden 2 Dockerfile örneği daha yapmak istiyor. Biz de öyle yaparız :D
                </p>

                <h3 id="dockerPythonApp">Uygulama 7 - Python App</h3>
                <p>
                  Yeni bir proje klasörü içine hocanın hazırlamış olduğu src/server.py dosyasını
                  <pre class="prettyprint ms-0">
from flask import Flask
server = Flask(__name__)

@server.route("/")
def hello():
    return "Hello World!"

if __name__ == "__main__":
    server.run(host='0.0.0.0')
                  </pre>
                  ve dependencies.txt dosyasını 
                  <pre class="prettyprint ms-0">
Flask==2.2.3
                  </pre>
                  ekledik.
                </p>
                <p>
                  Dockerfile dosyasını
                  <pre class="prettyprint ms-0">
FROM python:3.8-slim
WORKDIR /server
COPY dependencies.txt .
RUN pip install -r dependencies.txt
COPY src/ .
CMD ["python", "./server.py"]
                  </pre>
                  olarak yazdık.
                </p>
                <p>
                  Proje dosyasında terminale <pre class="prettyprint ms-0">docker build . -t python-app</pre> yazarak image oluşturduk. <pre class="prettyprint ms-0">docker run -p 3000:5000 python-app</pre> ile uygulama ayağa kaldırıldı.
                </p>

                <h3 id="dockerVueApp">Uygulama 8 - Vue App</h3>
                <p>
                  Hocanın hazırladığı örneği proje klasörümüze kopyaladık.
                </p>
                <p>
                  Dockerfile
                  <pre class="prettyprint ms-0">
FROM node:14-slim
WORKDIR /vue-app
COPY app/ .
RUN npm install
RUN npm install -g live-server
RUN npm run build
EXPOSE 8080
CMD [ "live-server", "dist" ]
                  </pre>
                </p>
                <p>
                  Proje dosyasında terminale <pre class="prettyprint ms-0">docker build . -t vue-app</pre> yazarak image alındı. <pre class="prettyprint ms-0">docker run -p 9000:8080 vue-app</pre> ile app ayağa kaldırıldı. <a href="http://localhost:9000/">http://localhost:9000/</a> ile uygulamaya ulaşılabiliyor.
                </p>

                <h3 id="dockerPurine">Her Şeyi Silmek (docker container prune)</h3>
                <p>
                  <code>docker contaşner prune</code> ile tüm containerlar silinir.
                </p>
                <p>
                  <code>docker images prune</code> ile tüm images silinir. <code>docker volume prune</code> ile de tüm volume silinir. Bu kalıp diğer bileşenlerde de uygulanabilir.
                </p>

                <h3 id="dockerCompose">Docker Compose</h3>
                <p>
                  Birden fazla container ayağa kaldırıp birlikte kullanma işlemlerinde docker compose kullanılır.
                </p>
                <p>
                  Docker compose için proje klasörümüzde docker-compose.yml adında bir dosya oluşturuyoruz. .yml YMAL file dosya uzantısıdır. Bilgi aktarımı için kullanılır. JSON ve xml e göre daha kolay ve basit bir kullanımı var. Key: value düzeni ile yazılır. value array ise <q>-</q> işareti ile alt alta yazılır. Subkey bir iç çıkıntıda yazılır. Bu nedenle intent (çıkıntı) kavramı çok önemli.
                </p>
                <p>
                  İlk önce <q>version</q> keyi yazılır. Dockerın hangi sürümünün kullanılacağını belirler. Bu yapılacak işlemleri etkiler.
                </p>
                <p>
                  sonra <q>services</q> altına çalıştırılacak containerlar yazılır.
                </p>

                <h3 id="dockerExm1">Örnek - 1: Tek Service</h3>
                <p>
                  önceki projelerde yaptığımız node server içindeki app.js, package.json ve package-lock.json proje klasörümüzde app klasörüne kopyalandı. Dockerfile ise direk proje klasörümüze kopyalandı. 
                </p>
                <p>
                  docker-compose.yml dosyası:
                  <pre class="prettyprint ms-0">
version: '3.4'
services:
  node-server: 
    container_name: my-server
    build: .
    ports: 
      - 3001:3000
                  </pre>
                  Dockerfile dosyası bazı işleri docker-compose.yml üzerine taşıdığımız için ve bazı klasörlerin yeri değiştiği için tekrar düzenlendi.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-server
COPY app/ .
RUN npm install
CMD ["node", "app.js"]
                  </pre>
                </p>
                <p>
                  Proje dizininde terminale <pre class="prettyprint ms-0">docker-compose build</pre> diyerek build aldırılır.
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker images</pre> yazdığımızda bizi <q>1-node-server-node-server</q> adında bir image karşılar. Burada ilk kısım klasörün adı (1-node-server) ikinci kısım da servisin adı (docker-compose.yml -> services: node-server: ...)
                </p>
                <p>
                  Proje dizininde terminale <pre class="prettyprint ms-0">docker-compose up</pre> diyerek çalıştırılır. Daha önce build alınmadıysa build alır ve sonra çalıştırır
                </p>

                <h3 id="dockerExm2">Örnek - 2: Multiple Service</h3>
                <p>
                  5-node-mongo-todo projesindeki Dockerfile yeni projemizin kök dizinine, app.js, package.json package-lock.js ve TodoModel.js yeni ptojenin app klasörüne eklendi.
                </p>
                <p>
                  Dockerfile dosyası aşağıdaki gibi düzenlendi.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /opt/node-todo-app
COPY app/ .
RUN npm install
CMD ["node", "app.js"]
                  </pre>
                </p>
                <p>
                  docker-compose.yml dosyası:
                  <pre class="prettyprint ms-0">
version: '3.4'
services: 
  todo-app:
    container_name: dc-todo-app
    build: .
    ports:
      - 3000:3000
  mongodb: 
    image: mongo
    ports: 
      - 27017:27017
    volumes:
      - todo-app-data:/data/db
volumes: 
  todo-app-data:
                  </pre>
                </p>
                <p>
                  docker-compose ile volume eklerken container seviyesindeki volume name ana seviyede de belirtilmeli.
                </p>
                <p>
                  app/app.js içinde mondoDB bağlantısı için docker-compose.yml içindeki servis adı (mongodb) kullanılır.
                  <pre class="prettyprint ms-0">
app.listen(PORT, async () => {
  ...
  await Mongoose.connect("mongodb://mongodb:27017/todos", {
    ...
  });
  ...
});
                  </pre>
                </p>
                <p>
                  Değişiklik yaptığımızda <code>docker-compose up</code> yapmadan önce <code>docker-compose build</code> ile build almak gerekir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker-compose down</pre> projeyi durdurmanın en doğru yoludur. containerları tek tek kapatmak hataya neden olabilir.
                </p>

                <h3 id="dockerExm3">Örnek - 3: Upload Edilen Dosyanın Saklanması</h3>
                <p>
                  Hocanın uygulamasını proje klasörümüze app klaaörü içine ekledik.
                </p>
                <p>
                  Proje klasöründe Dockerfile dosyası eklendi.
                  <pre class="prettyprint ms-0">
FROM node:16-slim
WORKDIR /uploader-app
COPY app/. .
RUN npm i
EXPOSE 3000
CMD [ "node", "server.js" ]
                  </pre>
                  docker-compose.yml dosyası
                  <pre class="prettyprint ms-0">
version: "3.4"
services:
  uploader-app:
    build: .
    ports:
      - 3000:3000
    volumes:
      - uploader-app-uploads:/uploads
volumes:
  uploader-app-uploads:
                  </pre>
                  volume olarak dosyaların uygulamada yüklendiği "uploads" klasörünü gösterdik.
                </p>

                <h3 id="dockerExm4">Örnek - 4: Variable Environment kullanmak</h3>
                <p>
                  Bu seferki ürünü sadece docker-compose.yml ile oluşturduk. <a href="https://hub.docker.com/_/wordpress">hub.docker.com -> wordpress</a> dökümantasyonundan faydalandık.
                  <pre class="prettyprint ms-0">
version: '3.4'
services:
  wordpress:
    image: wordpress
    ports:
      - 8080:80
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: bloguser
      WORDPRESS_DB_PASSWORD: test123
      WORDPRESS_DB_NAME: blogdb
    volumes:
      - wordpress:/var/www/html
  db:
    image: mysql:5.7
    restart: always
    environment:
      MYSQL_DATABASE: blogdb
      MYSQL_USER: bloguser
      MYSQL_PASSWORD: test123
      MYSQL_RANDOM_ROOT_PASSWORD: "1"
    volumes:
      - db:/var/lib/mysql
volumes:
  wordpress:
  db:
                  </pre>
                </p>
                <code>services: db: </code> ile database oluşturuldu. db ismine dikkat. bunu diğer serviste <code>WORDPRESS_DB_HOST: db</code> olarak kullandık. 
                
                <h3 id="dockerExm5">Örnek - 5: Çalışmak İçin Diğer Containerların Çalışmasına İhtiyaç Duymak</h3>
                
                <p>
                  Bu projenin dosyalarını hoca paylaşmamış sadece docker-compose.yml üzerinde konuştuk.
                  <pre class="prettyprint ms-0">
version: '3,4'
services:
  twitter-app:
    build: .
    ports:
      - 3000:3000
    depends_on:
      - mongodb
      - redis
  mongodb:
    image: mongo:latest
    ports:
      - 27017:27017
    volumes:
      - data:/data/db
  redis:
    image: redis
    ports:
      - 6379:6379
volumes:
  data:
                  </pre>
                </p>
                <p>
                  <code>depends_on:</code> altına verilen servisler o servisin çalışması için gerekenleri tanımlar. Önce onlar çalışır. Sonra içine yazıldığı container çalışır.
                </p>
              </div>
              <div class="row" id="linuxDockerSetupProductionLginx">
                <h2>linuxDockerSetupProductionLginx</h2>
                <p>
                  Hoca işlemleri <a href="https://www.digitalocean.com/">digitalocean.com</a> üzerinden host alıp yapıyor. Biz de onu takip edeceğiz. 
                </p>
                <p>
                  Create>Droplets ile formu doldurup makineyi ayağa kaldırıyoruz.
                </p>
                <p>
                  Oluşturduğumuz makineye docker kurmak için <a href="https://docs.docker.com/engine/install/ubuntu/">docker.com/engine/install/ubuntu/</a> adresindeki yönergeleri izleyeceğiz.
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">ssh root@&lt;host-id></pre> sintaxı ile bağlanıyoruz. Bizimki <pre class="prettyprint ms-0">ssh root@165.232.122.105</pre> Gelen ekrana parolamızı yazıp giriş yapıyoruz.
                </p>
                <p>
                  Ubuntuya girdiğimizde terminale <pre class="prettyprint ms-0">sudo apt-get update</pre> yazarak mevcut paketleri güncelliyoruz.
                </p>
                <p>
                  Sonra terminale <pre class="prettyprint ms-0">sudo apt-get install ca-certificates curl gnupg</pre> yazıyoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">apt install docker.io</pre> ile docker kuruldu.
                </p>
                <p>
                  <pre class="prettyprint ms-0">apt install docker-compose</pre> ile docker-compose kuruldu.
                </p>
                <p>
                  <pre class="prettyprint ms-0">systemctl status docker</pre> ile docker'ın çalışma durumu kontrol edilir.
                </p>

                <h3 id="dockerCloudExm1">Örnek 1: Docker Compose ile Wordpress Site Ayağa Kaldırma.</h3>
                <p>
                  Uzak bilgisayara bağlandıktan sonra kök dizinde terminale
                  <pre class="prettyprint ms-0">
cd /tmp
mkdir
mkdir web-apps
cd web-apps
                  </pre>
                  yazılarak tmp içine web-apps dosyası oluşturuldu ve içine girildi
                </p>
                <p>
                  <pre class="prettyprint ms-0">vi docker-compose.yml</pre> ile bu klasörde docker-compose.yml klasörü oluşturuldu ve içine girildi. Bu aşamada klavyede <q>i</q> ye basıp düzenleme (insert) modu açıldı. Daha önce wordpress için kullandığımız docker-compose içeriği buraya aktarıldı (hoca direk yapıştırdı. Bende düzgün yapışmadığından elle tek tek yazdım.)
                  <pre class="prettyprint ms-0">
version: '3.4'
services:
  wordpress:
    image: wordpress
    ports:
      - 8080:80
    environment:
      WORDPRESS_DB_HOST: db
      WORDPRESS_DB_USER: bloguser
      WORDPRESS_DB_PASSWORD: test123
      WORDPRESS_DB_NAME: blogdb
    volumes:
      - wordpress:/var/www/html
  db:
    image: mysql:5.7
    restart: always
    environment:
      MYSQL_DATABASE: blogdb
      MYSQL_USER: bloguser
      MYSQL_PASSWORD: test123
      MYSQL_RANDOM_ROOT_PASSWORD: "1"
    volumes:
      - db:/var/lib/mysql
volumes:
  wordpress:
  db:
                  </pre>
                </p>
                <p>
                  <q>esc</q> ile insert modundan çıkıldı. <q>:wq</q> ile dosya kaydedilip kapatıldı.
                </p>
                <p>
                  terminale
                  <pre class="prettyprint ms-0">
mkdir videomeet
mv docker-compose.yml videomeet/
                  </pre>
                  yazarak önce videomeet adında bir klasör oluşturduk ve ardından docker-compose.yml dosyasını buraya taşıdık.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
                    cd videomeet
                    cat docker-compose
                  </pre>
                  yazarak önce bu klasöre girdik. Sonra da docker-compose.yml içeriğini terminalde görüntüledik.
                </p>
                <p>
                  <pre class="prettyprint ms-0">docker-compose up</pre> ile projemizi ayağa kaldırdık.
                </p>
                <p>
                  Projeye <a href="http://165.232.122.105:8080/">165.232.122.105:8080</a> ile ulaşabiliriz.
                </p>
                <p>
                  projeyi kapatırken <q>ctrl + C</q> yeterli olur ancak tüm bileşenlerin kapanması için <pre class="prettyprint ms-0">docker-compose down</pre> komutu kullanılır.
                </p>

                <h3 id="dockerCloudNginxReverseProxy">Nginx kurulumu ve Reverse Proxy tanımı</h3>
                <p>
                  <b>Reverse proxy (ters yönlü proxy)</b>, bir ağdaki istemcilerin (genellikle internet kullanıcıları) bir hizmet sunucusuna erişirken, istemcilerin bu hizmet sunucusunu doğrudan değil de arada bir sunucu üzerinden erişmelerini sağlayan bir teknolojidir. Bu arada sunucuya "reverse proxy" denir çünkü geleneksel olarak çalışan "forward proxy"nin tersine, istemciden gelen istekleri bir sunucuya ileterek geriye doğru işlem yapar.
                </p>
                <p>
                  Biz reverse proxy ile aynı IP ile de bağlı olan iki domaini isteğin geldiği <q>server_name</q> e göre farklı container içine göndereceğiz.
                </p>
                <p>
                  Nginx kurulumu için <a href="https://www.scaleway.com/en/docs/tutorials/nginx-reverse-proxy/">hocanın kullandığı kaynak</a>
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">apt install nginx</pre> yazılarak ngnix yüklenir.
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">unlink /etc/nginx/sites-enabled/default</pre> yazılarak Nginxin, Ubuntu'nun paket yöneticisi apt aracılığıyla yüklendiğinde önceden yapılandırılmış olan varsayılan sanal ana bilgisayarı devre dışı bırakılır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
cd /etc/nginx/sites-available
vi reverse-proxy.conf
                  </pre>
                  ile ilgili klasöre gidip revers proxy için configuration dosyası oluşturduk.  içine yazmak için klavyede <q>i</q> ye bastık ve aşağıdakileri yazdık.
                  <pre class="prettyprint ms-0">
server {
        listen 80;
        listen [::]:80;
        server_name videomeet.app;
        server_name_in_redirect off;

        access_log /var/log/nginx/reverse-access.log;
        error_log /var/log/nginx/reverse-error.log;

        location / {
            proxy_set_header Client-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $host;
            proxy_pass http://127.0.0.1:8080;
  }
}
                  </pre>
                  <q>esc</q> ile insert mode dan çıktık <q>:wq</q> ile kaydedip çıktık.
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">ln -s /etc/nginx/sites-available/reverse-proxy.conf /etc/nginx/sites-enabled/reverse-proxy.conf</pre> ile yazdığımız dosya gerekli olan başka bir klasör ile bağlandı.
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">nginx -t</pre> yazarak nginx test edilir.
                  <pre class="prettyprint ms-0">
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
                  </pre>
                  çıktısı alıyorsa her şey yolunda demektir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">systemctl restart nginx</pre> ile nginx restart edilir. ngnixin sistemde çalışmasını sorgulamak için terminale <pre class="prettyprint ms-0">systemctl status nginx</pre> yazılır.
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">cd /tmp/web-apps/videomeet</pre> yazılarak projemizin olduğu dosyaya ulaştık.
                  <pre class="prettyprint ms-0">docker-compose up</pre> ile projeyi ayağa kaldırdık.
                </p>
                <p>
                  Burada bazı işlemler domain gerektiriyor. Bunu daha sonra tekrar deneriz. Bu kısımda domaine ve wordpress e host id girildi.
                </p>

                <h3 id="dockerCloudExm2">Örnek 2: Docker Compose ile Aynı Hostta Asana Clone Ayağa Kaldırma.</h3>
                <p>
                  Proje dosyasını ssh üzerinden scp ile göndereceğiz.
                </p>
                <p>
                  Bunun için daha önce hocanın dosyalarından aldığımız ve göndereceğimiz <q>8-vue-app-docker-file</q> klasörünü <q>.tar</q> formatında sıkıştırıyoruz. Sıkıştıracağımız klasörde terminale <pre class="prettyprint ms-0">tar -cvf asana-clone.tar *</pre> yazdık.
                </p>
                <p>
                  Dosyayı göndermek için dosyanın olduğu klasörde terminale <pre class="prettyprint ms-0">scp asana-clone.tar ssh root@165.232.122.105:/tmp/web-apps/</pre> yazdık
                </p>
                <p>
                  server tarafında <pre class="prettyprint ms-0">cd /tmp/web-apps</pre> ile dosyayı gönderdiğimiz dizine girdik. <pre class="prettyprint ms-0">chmod 755 asana-clone.tar</pre> ile dosya erişim iznini değiştirdik. <pre class="prettyprint ms-0">tar xf asana-clone.tar</pre> ile dizinden çıkarttık. <pre class="prettyprint ms-0">mkdir asana-clone</pre> yazarak yeni bir klasör oluşturduk.
                  <pre class="prettyprint ms-0">
mv app asana-clone/app
mv Dockerfile asana-clone/Dockerfile
                  </pre> ile .tar dan çıkartılanlar bu dosyaya taşındı. <pre class="prettyprint ms-0">rm asana-clone.tar</pre> ile sıkıştırılmış dosya silindi
                </p>
                <p>
                  <pre class="prettyprint ms-0">
cd asana-clone
docker build . -t asana-clone-app
                    </pre> ile build aldık ve <pre class="prettyprint ms-0">docker run -p 8090:8080 -d asana-clone-app</pre> ile uygulama up edildi.
                </p>
                <p>
                  <a href="http://165.232.122.105:8090/">http://165.232.122.105:8090/</a> ile uygulamaya ulaşılabilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">cd /etc/nginx/sites-available/</pre> ile nginx ayarlarının olduğu klasörü açtık. <pre class="prettyprint ms-0">vi reverse-proxy.conf</pre> ile içine girdik. Klavyede <q>i</q> ye basarak insert modunu açtık ve dosyaya gerekli eklemeleri yaptık. Son hali:
                  <pre class="prettyprint ms-0">
server {
        listen 80;
        listen [::]:80;
        server_name videomeet.app;
        server_name_in_redirect off;

        access_log /var/log/nginx/reverse-access.log;
        error_log /var/log/nginx/reverse-error.log;

        location / {
            proxy_set_header Client-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $host;
            proxy_pass http://127.0.0.1:8080;
  }
}

server {
        listen 80;
        listen [::]:80;
        server_name talkinghead.app;
        server_name_in_redirect off;

        access_log /var/log/nginx/reverse-access.log;
        error_log /var/log/nginx/reverse-error.log;

        location / {
            proxy_set_header Client-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $host;
            proxy_pass http://127.0.0.1:8090;
  }
}
                  </pre>
                  <q>esc</q> sonra da ":wq" ile kaydedilip kapatılır.
                </p>
                <p>
                  Her iki domain de aynı IP ile de bağlı olsa isteğin geldiği <q>server_name</q> e göre yönlendirme değişmektedir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">systemctl restart nginx</pre> ile nginx restart edilir. Böylece yeni ayarlar devreye alınmış olur.
                </p>
                <p>
                  Domain aldığımızda biz de bu durumu deneriz.
                </p>
              </div>
            </div>
            <div class="row" id="kubernetes">
              <h1>Kubernetes (K8S)</h1>
              <p>
                Tamamen teorik bir eğitim. Uygulama adına hiçbir şey yapmadık.
              </p>
              <div class="row" id="enterKubernetes">
                <h2>Kubernetes'e Giriş</h2>
                <p>
                  Containerlar üzerinde çalışan microservice tabanlı uygulamaların orkestrasyonu.
                </p>
                <ol>
                  <li>Uygulamayı geliştirip container haline getiririz</li>
                  <li>YAML veya JSON dosyası olarak "Deployment" objesini yaratırız</li>
                  <li>Yarattığımız dosyayı kubernetes api-server'a göndeririz</li>
                </ol>

                <ol>Kompanenetler
                  <li>Master (Control Plane) <ol>
                    <li>kube-api-server: K8S in beyni</li>
                    <li>cluster store(etcd): K8S in hafızası</li>
                    <li>kube-controller-manager: kontrollör</li>
                    <li>kube-scheduler: organizatör</li>
                  </ol></li>
                  <li>Node (Worker) <ol>
                    <li>kubelet: Node Agent</li>
                    <li>container engine: Container yöneticisi</li>
                    <li>kube-proxy: Load Balancer</li>
                  </ol></li>
                </ol>

                <p>
                  <b>Pod nedir</b> Docker için container ne ise K8S için de Pod odur. Podların içinde containerlar çalışır. K8S ölöekleme birimidir. 1 Pod birden fazla K8S nodu üzerine deploy edilemez. 
                </p>
                <p>
                  <b>Deployment nedir?</b> REST objeleridir. YAML yada JSON dosyasında tanımlanabilirler. Bir kere hazırlanıp birden fazla deploy edilebilirler. Versiyonlanabilirler. Yaratımı api-server üzerinden olur.
                </p>
                <p>
                  <b>Service nedir?</b> K8S üzerinde bir network var. Podların trafiğini service yönetir. Sadece sağlıklı podlara yönlendirir. Load balancing görevini de yerine getirir.
                </p>
              </div>
              <div class="row" id="kubernetesMaster">
                <h2>Master'a Genel Bakış</h2>
                <p>
                  Cloudda veya lokalde herhangi bir host üzerinden çalışabilir. Cluster'a gözkulak olur. Cluster üzerinde nelerin çalışacağına master karar verir. Workload ayarlamaları, yaşam döngüsü, ölçekleme ve upgrade işlemlerinden sorumludur.
                </p>

                <h3>Komponentleri</h3>
                <p>
                  <b>kube-api-server</b> kuberneteste birşey yaratmak ve kullanmak için faydalanacağımız, K8S in beyni. API(REST) üzerinden fonksiyonları expose eder. JSON yada YAML dosyaları vasıtasıyla fonksiyonları kullanabilir. 443 portu üzerinden çalışır (HTTPS). $kubectl komut satırı ile kullanılır.
                </p>
                <p>
                  <b>cluster store</b> Yönetimdeki tek stateful kısımdır. Kalıcı bir saklama alanıdır. Key/value store teknolojisini kullanır.
                </p>
                <p>
                  <b>kube-controller-manager</b> controllerları koordine eder. Her işlem için controller bulunabilir. Desired state (arzulanan hal) pozisyonunu kontrol eder. Arzulanan halden çıkılırsa geri dönmek için gerekeni yapan kısımdır.
                </p>
                <p>
                  <b>kube-scheduler</b> api-serverdan gelen yeni pod yaratma görevleri için bekler. Node'lara workload atamasından sorumludur.
                </p>
              </div>
              <div class="row" id="kubernetesNode">
                <h2>Node'a Genel Bakış</h2>
                <p>
                  Cluster'ın çalışan gücü. Fiziksel yada sanal makinede olabilirler. Node'u node yapan en önemli şey container runtime'dır.
                </p>
                <h3>Komponentleri</h3>
                <p>
                  <b>kubelet</b> node'u cluster'a register etmeye yarar. api-server dan gelen direktifleri bekler. Pod oluşturmada görev alır. Master ile sürekli iletişim halinde.
                </p>
                <p>
                  <b>container engine</b> container'ları yönetme işini halleder. Pluggable (kaldırılabilir, değiştirilebilir). Genelde Docker Container Engine kullanılır. Container'ları start-stop etmede görevlidir.
                </p>
                <p>
                  <b>kube-proxy</b> kubernetes network fonksiyonlarını sağlar. Node içinde her pod tek bir IP adresine sahiptir. Service içinde tanımlanan Pod'ların yük dengelemesini sağlıyor. Frontend ve backend podlar kube-proxy üzerinden haberleşir.
                </p>
                <h3>Master-Node Arası İletişim</h3>
                <p>
                  api-server node'lardaki loglara erişmek, port-front etmek ve portlara erişmek için kubelet'i kullanır. api-server'ın node'lar, pod'lar ve service'ler ile iletişimi şu an için secure (https) değil.
                </p>
              </div>
              <div class="row" id="kubernetesHowWork">
                <h2>Kubernetes'in Çalışma Prensipleri</h2>
                <p>
                  Kubernetes karmaşık mikroservice yapılarını organize eder. Herhangi bir microservice down olursa yeni bir cluster kubernetes tarafından ayağa kaldırılır.
                </p>
                <p>
                  Biz kubectl kullanarak K8S in beyni olan api-server ile konuşur. Manifest dosyamiz ve kubectl komutu ile api-server üzerinden işlem başlar.
                </p>
              </div>
              <div class="row" id="kubernetesSetup1">
                <h2>Kubernetes Kuruyoruz-1</h2>
                <p>
                  <a href="https://gitlab.com/onurersen/turkce-kubernetes/-/tree/master/kubernetes-kuruyoruz">Hocanın notları</a> Node ve Master kurulumunda notlardan faydalandık ancak bu kısımda <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">bu dökümantasyondan</a> faydalandık. Hocanınki bizde çalışmadı. Gerçi bizim yaptığımız hali de eninde sonunda çöktü :D
                </p>
                <p>
                  Hoca kurulumu direk linux ortamında yapmış. Ben de digitalocean üzerinden 2 makine açıp orada deneyeceğim 
                </p>
                <p>
                  Hem master hem de node makinede swap disable edilmeli. <pre class="prettyprint ms-0">swapoff -a</pre> Bu olmazsa kubernetes ayağa kalkmıyor.
                </p>
                <p>
                  <b>swap nedir?</b> Swap (Takas) Alanı, işletim sistemi tarafından sabit diskinizde ayrılmış bir bölümdür. İşlenecek veriler ön belleğe (RAM) sığmadığı zaman bu bölüm “RAM” gibi kullanılır ve böylelikle veri akışının ve proseslerinin devam etmesi sağlanır.
                </p>
                <p>
                  Her iki makineyi de güncelle <pre class="prettyprint ms-0">sudo apt-get update</pre>
                </p>
                <p>
                  Her iki makineye google apt reposty ekle <pre class="prettyprint ms-0">curl -fsSL https://dl.k8s.io/apt/doc/apt-key.gpg | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-archive-keyring.gpg</pre>
                </p>
                <p>
                  Her iki makineye kubernetes apt repository ekle.
                  <pre class="prettyprint ms-0">
echo "deb [signed-by=/etc/apt/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main" | sudo tee /etc/apt/sources.list.d/kubernetes.list
                  </pre>
                </p>
                <p>
                  Her iki makineyi tekrar güncelle <pre class="prettyprint ms-0">sudo apt-get update</pre>
                </p>
                <p>
                  Repository deki versiyonları daha sonra incelemek için apt-cache ile cacheliyelim.
                  <pre class="prettyprint ms-0">
apt-cache policy kubelet|head -n 20
apt-cache policy docker.io|head -n 20
                  </pre>
                </p>
                <p>
                  Gerekli paketleri repositoryden makinemize çekelim.
                  <pre class="prettyprint ms-0">
sudo apt-get install -y docker.io kubelet kubeadm kubectl
                  </pre>
                </p>
                <p>
                  kubelet, container runtime'mımız olan docker statusleri kontrol edelim.
                  <pre class="prettyprint ms-0">
sudo systemctl status kubelet.service
sudo systemctl status docker.service
                  </pre>
                </p>
                <p>
                  sistem ayağa kalktığında çalışacak şekilde ayarlayalım.
                  <pre class="prettyprint ms-0">
sudo systemctl enable kubelet.service
sudo systemctl enable docker.service
                  </pre>
                </p>
              </div>
              <div class="row" id="kubernetesSetupMaster">
                <h2>Kubernetes Kuruyoruz-Master</h2>
                <p>
                  Pod network yaratmak icin calico yaml lari indirelim
                  <pre class="prettyprint ms-0">
wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml
wget https://docs.projectcalico.org/v3.3/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml
                  </pre>
                </p>
                <p>
                  Calico yaml file daki ip bilgisine uygun olarak, bir pod network range i belirleyerek Kubernetes cluster imizi olusturalim
                  <pre class="prettyprint ms-0">sudo kubeadm init --pod-network-cidr=192.168.0.0/16</pre>
                </p>
                <p>
                  API server a admin erisim yetkisine sahip bir hesap yaratalim
                  <pre class="prettyprint ms-0">
mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config
                  </pre>
                </p>
                <p>
                  Pod network olusturmak icin gerekli yaml dosyalarini calistiralim
                  <pre class="prettyprint ms-0">
kubectl apply -f rbac-kdd.yaml
kubectl apply -f calico.yaml
                  </pre>
                </p>
                <p>
                  Sistem specific podlari ve calico podlarini inceleyelim <br>
                  Not : DNS pod umuz network deploy olup calisir halene kadar aktif olmayacak
                  <pre class="prettyprint ms-0">
kubectl get pods --all-namespaces
                  </pre>
                </p>
                <p>
                  Cluster da mevcut podlarin listesine bakalim - sadece master gorunecek <pre class="prettyprint ms-0">kubectl get nodes</pre>
                </p>
                <p>
                  kubelet static pod manifestleri calistiriyor yani bir anlamda core cluster podlari calisir hale geliyor <pre class="prettyprint ms-0">sudo systemctl status kubelet.service</pre>
                </p>
                <p>
                  kubeconfig dosyasinin bulundugu directory i inceleyelim <pre class="prettyprint ms-0">ls /etc/kubernetes</pre>
                </p>
                <p>
                  master daki manifestleri inceleyelim <pre class="prettyprint ms-0">ls /etc/kubernetes/manifests</pre>
                </p>
                <p>
                  api-server ve etcd nin manifestlerini incelemek istersek...
                  <pre class="prettyprint ms-0">
sudo more /etc/kubernetes/manifests/etcd.yaml
sudo more /etc/kubernetes/manifests/kube-apiserver.yaml
                  </pre>
                </p>
              </div>
              <div class="row" id="kubernetesSetupNode">
                <h2>Kubernetes Kuruyoruz-Node</h2>
                <p>
                  kubelet ve container runtime service lerini kontrol ederim
                  <pre class="prettyprint ms-0">
sudo systemctl status kubelet.service
sudo systemctl status docker.service  
                  </pre>
                </p>
                <p>
                  Sistem basladigi zaman baslayacak sekilde set edelim
                  <pre class="prettyprint ms-0">
sudo systemctl enable kubelet.service  
sudo systemctl enable docker.service
                  </pre>
                </p>
                <p>
                  Master'da token bilgisi verilmisti eger not almadiysak su sekilde listeleyebiliriz <pre class="prettyprint ms-0">kubeadm token list</pre>
                </p>
                <p>
                  Yeniden bir token generate etmek istiyorsak <pre class="prettyprint ms-0">kubeadm token create</pre>
                </p>
                <p>
                  Master uzerinde ca cert hash bulunmakta. Onu elde etmek için: 
                  <pre class="prettyprint ms-0">
openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2>/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //'
                  </pre>
                </p>
                <p>
                  Yukarıdaki kodlarla elde ettiğimiz token imiz ve cert ile Api Server in IP adresi ya da adını kullanarak Node'umuzu cluster a dahil edelim.
                  <pre class="prettyprint ms-0">
sudo kubeadm join &lt;ip>:6443 --token&lt;token> --discovery-token-ca-cert-hash &lt;ca_cert_hash>
                  </pre>
                </p>
                <p>
                  bizim durumumuzda aşağıdaki kod node'a yazılır.
                  <pre class="prettyprint ms-0">
kubeadm join 174.138.60.6:6443 --token nyndhw.xynrxsohej6fw400 \
        --discovery-token-ca-cert-hash sha256:ccb7f01df76693e522c9ba719adb9817d8c28f0ab1cf18148fd21022ee04a74d
                  </pre>
                </p>
              </div>
              <div class="row" id="kubernetesTraffic">
                <h2>NodePort - ClusterIP - LoadBalancer - Ingress</h2>
                <p>
                  Kuberneteste Ptrafik yönetimi: Podlar tüm cruster içinde erişebilir olur. Service üzerinden Podları erişebilir hale getirir. kube-dns servislere otomatik DNS name atar.
                </p>
                <p>
                  <b>NodePort nedir?</b> Dış dünyadan gelen trafiği Cluster'imizin içine kabul etmenin temel yolu. Tüm nodelar üzerinde bir portu erişime açar (default range of 30000-32767). Cluster dışından &lt;NodeIp>:&lt;NodePort> şeklinde erişilebilir. Gelen istekler ilişkilendirilen Service'e yönlendirilir.
                </p>
                <p>
                  <b>ClusterIp nedir?</b> Service'e cluster genelinde geçerli bir IP verme yöntemi. Default olarak dış dünyaya erişime açmaz ama proxy vasıtasıyla dışarıdan erişim sağlanır.
                </p>
                <p>
                  <b>LoadBalancer nedir?</b> Kuberneteste service'i dış dünyaya expose etmek için standart yöntem. Service'lerin yük dağılımı NodePort üzerinden Service'e yönlendirme ile sağlanır. Yaratılan LoadBalancer tipindeki Service'lerin de bir IP si olur. İstek NodeBalancer üzerinden NodePort'a oradan podlara geçer.
                </p>
                <p>
                  <b>Ingress</b> aslında bir service değil bir object. Reverse proxy işi yapar. Service'ler arası yük dağıtan bir router gibi davranır. Çalışması için cluster'da bir Ingress Controllerîn bulunması gerekir.
                </p>
              </div>
              <div class="row" id="kubernetesDaemonset">
                <h2>Daemonset ve Kullanımı</h2>
                <p>
                  Cluster üzerinde her Node üzerinde belirlediğimiz bir Pod'u çalıştırmanın yolu. İstenilen şartta bir Node oluştuğu anda set edilen işlemi gerçekleştirir (İçinde default olarak gelmesi istenen bir pod vs gibi). Spesifik işler yapmak için spesifik Node'lara deploy olabilirler.
                </p>
                <p>
                  DeamonSetlere ulaşmak için: DeamonSet'i yaratırken port bilgisi verilip, NodeIp-Port bilgisiyle veya DeamonSet podları bir Service objesine bind edilip service üzerinden ulaşılabilirler.
                </p>
                <p>
                  DeamonSetler genelde dışarı data push etmek için kullanılır (Loglama vs).
                </p>
              </div>
              <div class="row" id="kubernetesImperativeDeclarative">
                <h2>Imperative ve Declarative Yöntemler</h2>
                <p>
                  <b>Imperative yöntem</b> özel komutlar vasıtasıyla süreci yönetmek.
                </p>
                <p>
                  <b>Declarative yöntem</b> yapılacak işi bir veya birden fazla script içerisinde tanımlayıp çalıştırmak
                </p>
                <p>
                  Imperative bizim tek tek elle yaptığımız işlemlerken, declarative ise manifest dosyaları gibi önceden hazırlanmış dosyalarla yaptığımız kalıptan yapılan işlemlerdir. 
                </p>
              </div>
              <div class="row" id="kubernetesPod">
                <h2>Pod Yaşam Döngüsü ve Probe'lar</h2>
                <ol>Pod'un statüleri
                  <li><b>Pending:</b> kubernetes tarafından kabul edildi. Container image'ların inmesi bekleniyor</li>
                  <li><b>Running:</b> Pod bir node ile ilişkilendirildi. Tün container'lar yaratıldı</li>
                  <li><b>Succeded:</b> Pod'daki tüm containerlar görevini tamamlayıp sonlandırıldı. Yeniden başlamayacaklar.</li>
                  <li><b>Failed:</b> Tüm containerlar sonlandırıldı. Sonlandırılırken en az biri hata verdi.</li>
                  <li><b>Unknown:</b> Podun stat'i alınamıyor. Podun üzerinde çalıştığı node'dan bilgisi okunamıyor.</li>
                </ol>

                <p>
                  <b>Probe</b> kubernetesin Pod'un durumunu öğrenmek için yaptığı işlem. Periyodik olarak cluster'da yapılan diagnostic operasyondur.
                </p>
                <ol>Üç çeşit prop vardır
                  <li><b>Liveness Probe:</b> Sağlıklı çalışıyor mu? Beklendiği gibi çalışıyor mu?</li>
                  <li><b>Readiness Probe:</b> Pod request kabul edebilir mi?</li>
                  <li><b>Startup Probe:</b> Containerdaki uygulama başarılı çalıştı mı?</li>
                </ol>

                <ol>Üç Probe yöntemi vardır
                  <li><b>Execation</b> prob sırasında bir aksiyon alınıyor.</li>
                  <li><b>TCPSocketraction</b> prob sırasında soket açılıp denetleniyor</li>
                  <li><b>HTTPGetAction</b> http request gönderip sonucu veriyor (success, failure, unknown)</li>
                </ol>
              </div>
              <div class="row" id="kubernetesCrusterLog">
                <h2>Cluster'da Loglama</h2>
                <p>
                  Clusterda olan bitenden haberdar olmak (monitmr etme, debug etme) için kullanılır.
                </p>

                <ul>Bunlar log üretir
                  <li>Podlar</li>
                  <li>Contanerlar</li>
                  <li>Kubernetes Componentleri</li>
                  <li>DeamonSetler</li>
                  <li>Birçok Kubernetes Service'i</li>
                </ul>

                <p>
                  Kubernetes api üzerinden loglara erişilir.
                </p>

                <p>
                  Node level ve cluster level olarak iki ayrı log seviyesi vardır. Node level loglarını default olarak tutar. Cluster level için K8S te bir log kayıt mekanizması yok. Biz ekliyoruz.
                </p>
              </div>
              <div class="row" id="kubernetesReplication">
                <h2>Replication Yöntemlerine Genel Bakış</h2>
                <p>
                  Kubernetesin var olma sebebi. Sistemde çalışan uygulamaların, mikroservislerin ve containerların çoklanması işlemidir. Kubernetese verdiğimiz desired state'e göre kill olanların yerini yeniler alarak bizim istediğimiz yapının kalıcılığı sağlanır.
                </p>
                <ul>Üç ihtiyacı karşılar
                  <li>Scaling (ölçeklendirme)</li>
                  <li>Reliability (Sistemin kusursuz çalışması)</li>
                  <li>Load Balancing</li>
                </ul>
                <ul> Replication Yöntemleri
                  <li><b>Replication Controller:</b> Kubernetes'te replication’in en temel halini uygulayan yöntem. Pod’ların replication yönetimi bir controller üzerinden gercekleşir</li>
                  <li><b>ReplicaSet:</b> Contoller yapısı kullanmadan daha hedefe yönelik (new-gen RC). Replication Controller’a gére daha fazla esnek selector yapı</li>
                  <li><b>Deployment: </b>(Resmi olarak önerilen yöntem) Replicas tanımlaması ile deployment'in içi replication’ı yedirme. Rollout ve gerekirse rollback avantajı</li>
                </ul>

              </div>
              <div class="row" id="kubernetesKubectlFirsDeployment">
                <h2>Kubectl ve İlk Deployment</h2>
                <p>
                  <b>Kubectl</b> kubernetes command-line aracı. Cruster'ı yönetmeye (deployment yapmak, uygulamaları incelemek ve loglara erişmek) yarar. ~/.kube/config dosyasının içindeki bilgilere göre çalışır.
                </p>
                <p>
                  kubectl komutu syntax: <pre class="prettyprint ms-0">kubectl [command] [type] [name] [flags]</pre>
                  Örnek:
                  <pre class="prettyprint ms-0">
kubectl get pods
kubectl get service my-service
kubectl create deployment nginx --image=nginx
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="heroku">
              <h1>Heroku yerine Deta.Space</h1>
              <p>
                Hoca heroku anlatacak ancak biz heroku artık ücretli olduğundan deta.space üzerinden takip etmeye çalışacağız.
              </p>
              <p>
                diğer alternatifler: Render, Netlify, Cyclic
              </p>

              <h2>Node JS ile Basit Rest Api Yapımı</h2>
              <p>
                Proje ekranında terminale <pre>npm init y</pre> ile package.json oluşturuldu ve npm başlatıldı.
              </p>
              <p>
                <pre>npm install --save express body-parser</pre> ile gereken bağımlılıklar yüklendi
              </p>
              <p>
                <pre>npm install --save-dev nodemon</pre> ile nodemon kuruldu.
              </p>
              <p>
                db.json dosyası oluşturuldu ve içine hocanın verdiği data eklendi.
              </p>
              <p>
                app.js oluşturuldu son hali aşağıda.
                <pre>
const app = require("express")();
const db = require("./db.json");
const bodyParser = require("body-parser");

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

app.get("/users", (req, res) => {
  res.status(200).send(db);
});
app.get("/users/:id", (req, res) => {
  if (isNaN(req.params.id)) {
    res.status(400).send({
      message: "İşlenemeyen veri",
    });
  } else {
    const user = db.find((user) => user.id == req.params.id);
    if (user) {
      res.status(200).send(user);
    } else {
      res.status(400).send({
        message: "Kullanıcı bulunamadı",
      });
    }
  }
});
app.post("/users", (req, res) => {
  const willSaveData = {
    id: new Date().getTime(),
    full_name: req.body.full_name,
    country: req.body.country,
    email: req.body.email,
    created_at: new Date(),
  };
  db.push(willSaveData);
  res.send(willSaveData);
});
app.patch("/users/:id", (req, res) => {
  if (isNaN(req.params.id)) {
    res.status(400).send({
      message: "İşlenemeyen veri",
    });
  } else {
    const user = db.find((user) => user.id == req.params.id);
    if (user) {
      // Kayıt değişikliği
      // pass by referance ve pass by value araştırılacak.
      Object.keys(req.body).forEach((key) => {
        user[key] = req.body[key];
      });
      res.status(200).send(user);
    } else {
      res.status(400).send({
        message: "Kullanıcı bulunamadı",
      });
    }
  }
});
app.delete("/users/:id", (req, res) => {
  if (isNaN(req.params.id)) {
    res.send(400, {
      message: "İşlenemeyen veri",
    });
  } else {
    const userIndex = db.findIndex((user) => user.id == req.params.id);
    if (userIndex > -1) {
      //silme işlemi
      db.splice(userIndex, 1);
      res.status(201).send({
        message: "Kullanıcı Silindi",
      });
    } else {
      res.status(400).send({
        message: "Kullanıcı bulunamadı",
      });
    }
  }
});

app.listen(process.env.PORT || 3000, () => {
  console.log("Sunucu ayaktadır... Çalışıyor...");
});

                </pre>
              </p>
              <p>
                nodemonun bizim her değişikliğimizde kodumuzu tekrar çalıştırması için package.json içine 
                <pre>
"scripts": {
    "start": "nodemon app.js"
  },
                </pre>
                eklendi ve terminale <pre>npm start</pre> yazılarak proje ayağa kaldırıldı.
              </p>

              <h2>Heroku yerine Deta.Space</h2>
              <p>
                Heroku ücretli olduğundan alternatif arayışındayız. <a href="https://deta.space/">deta.space</a> terminal kullanımı ve tamamen ücretsiz olması nedeni ile ilgimizi çekti. Burayı deneyeceğiz.
              </p>
              <p>
                diğer alternatifler: Render, Netlify, Cyclic
              </p>
              <p>
                Terminale <pre>iwr https://deta.space/assets/space-cli.ps1 -useb | iex</pre> yazarak bilgisayarımıza kurduk.
              </p>
              <p>
                <pre>space login</pre> ile uygulamayı açtık. Bizden istediği access token için <a href="https://deta.space/">deta.space</a> sayfasında en alttaki form yardımıyla setting>access token ürettik ve terminale girdik. Ve login olduk.
              </p>
              <p>
                Proje dizininde terminale <pre>space new</pre> yazılarak proje deta.space üzerinde pluşturulur.
              </p>
              <p>
                Dockerdakine benzer bir şekilde projemiz için Spacefile adında bir manifest oluşturduk.
                <pre>
v: 0
micros:
  - name: node-rest-api
    src: ./
    engine: nodejs16
    primary: true
    run: node app.js
    dev: npm start
    public: true
                </pre>
              </p>
              <p>
                Terminale <pre>space push</pre> yazarak projeyi deploy ettik.
              </p>
            </div>
            <div class="row" id="diger">
              <h1>Diğer Eğitimlerdeki Deployment Örnekleri</h1>
              <ul>
                <li><a href="./react.html#surgeSh">Surge</a></li>
                <li><a href="./react.html#netlify">Netlify</a></li>
                <li><a href="./react.html#awsEc2Deploy">AWS EC2 Üzerine Deploy İşlemleri</a></li>
                <li><a href="https://render.com/">render.com/</a></li>
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>