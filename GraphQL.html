<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GraphQL</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
            list-style-position: inside;
        }
        table, th ,td{
            border: 1px black solid;
            border-collapse: collapse;
            text-align: center;
        }
        nav{
            background-color: white;
        }
        .nav-pills .nav-link.active {
            background-color: rgba(0, 0, 0, 0.51);
        }
        .nav-pills .nav-link {
            color: black
        }
        </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg bg-light">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">GraphQL</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          <li><a class="dropdown-item" href="react.html" target="_blank">React</a></li>
                          <li><a class="dropdown-item" href="redux.html" target="_blank">Redux</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2>Konu Listesi </h2>
            <hr>
            <nav id="navbar-example3" class="h-100 flex-column align-items-stretch pe-4 border-end " style="max-height: 400px; overflow: auto;">
                <nav class="nav nav-pills flex-column ">
                  <a class="nav-link" href="#whatIsGraphQL">Giriş</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsGraphQL">GraphQL Nedir? Ne Değildir?</a>
                    <a class="nav-link ms-3 my-1" href="#apolloServer">Apollo Server'a Giriş</a>
                    <a class="nav-link ms-3 my-1" href="#nonNullableFields">Non Nullable Fields</a>
                    <a class="nav-link ms-3 my-1" href="#scalarTypes">Scalar Types</a>
                    <a class="nav-link ms-3 my-1" href="#customTypes">Custom Types</a>
                    <a class="nav-link ms-3 my-1" href="#argumans">Argümanlar ile Çalışmak</a>
                    <a class="nav-link ms-3 my-1" href="#iliskiselData">İlişkisel Veriler ile Çalışmak</a>
                    <a class="nav-link ms-3 my-1" href="#iliskiselDataArgumanlar">İlişkisel İfadelerde Argümanlar</a>
                  </nav>
                  <a class="nav-link" href="#whatIsMutation">Mutations (Server)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#whatIsMutation">Mutation Nedir? Nasıl Yazılır?</a>
                    <a class="nav-link ms-3 my-1" href="#inputType">Input Type</a>
                    <a class="nav-link ms-3 my-1" href="#updateMutations">Update Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#deleteMutations">Delete Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#deleteAllMutations">Delete All Mutations</a>
                  </nav>
                  <a class="nav-link" href="#subscriptionServerSetup">Subscriptions (Server)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#subscriptionServerSetup">Subscription Server Kurulumu</a>
                    <a class="nav-link ms-3 my-1" href="#userCRUDsubs">User CRUD Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#postVeCommentCRUDsubs">Post ve Comment CRUD Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#withFilter">withFilter ile Subscription Filtreleme</a>
                    <a class="nav-link ms-3 my-1" href="#redisPubsub">Redis PubSub</a>
                    <a class="nav-link ms-3 my-1" href="#env">Ortam Değişkenleri</a>
                  </nav>
                  <a class="nav-link" href="#Folder/Schema Structure - 1">Folder/Schema Structure</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#folderSchemaStructure1">Folder/Schema Structure - 1</a>
                    <a class="nav-link ms-3 my-1" href="#folderSchemaStructure2">Folder/Schema Structure - 2 (File Loader)</a>
                    <a class="nav-link ms-3 my-1" href="#babelComplier">Babel Compiler</a>
                  </nav>
                  <a class="nav-link" href="#setupApolloClient">Queries (Apollo Client)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#setupApolloClient">Apollo Client Kurulumu</a>
                    <a class="nav-link ms-3 my-1" href="#ApolloClientVisual">Genel Görünümün Ayarlanması</a>
                    <a class="nav-link ms-3 my-1" href="#reactRouter">React Router</a>
                    <a class="nav-link ms-3 my-1" href="#postlarinListelenmesi">Postların Listelenmesi (useQuery)</a>
                    <a class="nav-link ms-3 my-1" href="#postDetail">Post Detaylarının Gösterilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#shortDescField">Short Description Field'ının Tanımlanması</a>
                    <a class="nav-link ms-3 my-1" href="#useLazyQuery">Post Yorumlarının Listelenmesi (useLazyQuery)</a>
                  </nav>
                  <a class="nav-link" href="#subscribeToMore">Subscriptions (Apollo Client)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#subscribeToMore">Postların Gerçek Zamanlı Listelenmesi (subscribeToMore)</a>
                    <a class="nav-link ms-3 my-1" href="#useSubscription">Post Sayısını Gerçek Zamanlı Göstermek (useSubscription)</a>
                    <a class="nav-link ms-3 my-1" href="#commentsRealTime">Yorumların Gerçek Zamanlı Gösterilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#fragments">Fragments</a>
                  </nav>
                  <a class="nav-link" href="#createNewPostForm">Mutations (Apollo Client)</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#createNewPostForm">New Post Formunun Tasarlanması</a>
                    <a class="nav-link ms-3 my-1" href="#newPostFormUsers">Kullanıcı Listesinin Çekilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#useMutation">Yeni Post Eklemek (useMutation)</a>
                    <a class="nav-link ms-3 my-1" href="#createNewCommentForm">Yorum Formunun Hazırlanması</a>
                    <a class="nav-link ms-3 my-1" href="#mutationNewComment">Yeni Yorum Mutation'unun Hazırlanması</a>
                    <a class="nav-link ms-3 my-1" href="#spinnerDelay">Spinner Delay</a>
                  </nav>
                  <a class="nav-link" href="#connectMongoDb">GraphQL & MongoDB</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#connectMongoDb">MongoDB Bağlantısının Gerçekleştirilmesi</a>
                    <a class="nav-link ms-3 my-1" href="#createUserModel">User Modelinin Oluşturulması</a>
                    <a class="nav-link ms-3 my-1" href="#createPostModel">Post Modelinin Oluşturulması</a>
                    <a class="nav-link ms-3 my-1" href="#createCommentModel">Comment Modelinin Oluşturulması</a>
                    <a class="nav-link ms-3 my-1" href="#relationshipMongoDb">MongoDB İlişkileri</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringUserMutation">Refactoring User Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringPostMutation">Refactoring Post Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringCommentMutation">Refactoring Comment Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#refactoringSubscriptions">Refactoring Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#apolloClientUpdates">Apollo Client Güncellemeleri</a>
                  </nav>
                  <a class="nav-link" href="#enterToHasura">Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#enterToHasura">Hasura'ya Giriş ve Query</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraMutations">Hasura Mutations</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraSubscriptions">Hasura Subscriptions</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraRelationships">Relationships</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraCustomActions">Custom Actions</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraRemoteSchemas">Remote Schemas</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraEventTriggers">Event Triggers</a>
                  </nav>
                  <a class="nav-link" href="#commentHasuraDocker">Comments App with Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#commentHasuraDocker">Hasura Docker Yapılandırması</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraData">Veritabanı Mimarisinin Oluşturulması</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraClient1">Client Entegrasyonu - 1</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraClient2">Client Entegrasyonu - 2</a>
                    <a class="nav-link ms-3 my-1" href="#commentHasuraClient3">Client Entegrasyonu - 3</a>
                  </nav>
                  <a class="nav-link" href="#votingHasuraBackend">Realtime Voting App with Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#votingHasuraBackend">Hasura Backend'in Oluşturulması</a>
                    <a class="nav-link ms-3 my-1" href="#votingApolloClientAndReactRouter">Apollo Client ve React Router Kurulumu</a>
                    <a class="nav-link ms-3 my-1" href="#votingRealTimeListing">Oylamaların Gerçek Zamanlı Listelenmesi</a>
                    <a class="nav-link ms-3 my-1" href="#votingNewVoting1">Yeni Oylama Oluşturma Ekranının Hazırlanması - 1</a>
                    <a class="nav-link ms-3 my-1" href="#votingNewVoting2">Yeni Oylama Oluşturma Ekranının Hazırlanması - 2</a>
                    <a class="nav-link ms-3 my-1" href="#votingVotingDetail1">Oylama Detay Ekranının Hazırlanması - 1</a>
                    <a class="nav-link ms-3 my-1" href="#votingVotingDetail2">Oylama Detay Ekranının Hazırlanması - 2</a>
                  </nav>
                  <a class="nav-link" href="#hasuraDigitalOceanDeployment">Deployment</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#hasuraDigitalOceanDeployment">Hasura DigitalOcean Deployment</a>
                    <a class="nav-link ms-3 my-1" href="#reactClientNetlifyDeployment">React Client Netlify Deployment</a>
                  </nav>
                  <a class="nav-link" href="#hasuraMeetingApp">Meeting App with Hasura</a>
                  <nav class="nav nav-pills flex-column">
                    <a class="nav-link ms-3 my-1" href="#hasuraMeetingDb">Hasura Kurulumu ve DB Yapısının Oluşturulması</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraExpressBackend">Express Backending Hazırlanması</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraSucraseHasuraClientRoutingErrorHandling">Sucrase, Hasura Client, Routing ve Error Handling</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraUserRegisterRoute">User Register Route</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraJWTAuthRegister">Hasura JWT Authentication (Register)</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraJWTAuthLogin">Hasura JWT Authentication (Login)</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraMeQuery">Me Query</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraPermissions">Hasura Permissions</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraComputedFields">Computed Fields</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraEventTrigers">Event Triggers</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraMeetingApproveInvitation">Meeting Approve Invitation</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraOneOffScheduledEvents1">One Off Scheduled Events - 1</a>
                    <a class="nav-link ms-3 my-1" href="#hasuraOneOffScheduledEvents2">One Off Scheduled Events - 2</a>
                  </nav>
                </nav>
              </nav>
        </div>
        <div class="col-sm-9">
          <div data-bs-spy="scroll" data-bs-target="#navbar-example3" data-bs-smooth-scroll="true" class="scrollspy-example-2" tabindex="0">
            <div class="row" id="giris">
              <div class="row" id="whatIsGraphQL">
                <h1>GraphQL Nedir? Ne Değildir?</h1>
                <p>
                  Rest Api yapısının eksik olduğu yönleri kapatmak için facebook ekibi tarafından geliştirilmiştir.
                </p>
                <p>
                  Api'dan veri çekerken sadece istediğimiz sorguya uygun veri dönmesini sağlar. Bunu tek bir endpoint kullanarak yapar.
                </p>
                <p>
                  İlişkisel verilerle çalışması çok daha kolaydır.
                </p>
                <p>
                  GraphQL dökümantasyonunu kendisi otomatik olarak yapar. Sorgu sonucunun göründüğü arayüz de otomatik olarak oluşur.
                </p>
                <p>
                  Versiyonlama yapmaya gerek yok. Eski ve yeni alanları belirtebiliyoruz.
                </p>
                <p>
                  Websoket tanımlarını yapmak daha kolay.
                </p>
                <ul>GraphQL Terminolojisi
                  <li>Query: Bir veri kaynağına erişmek istediğinizde kullanacağınız tanımdır.</li>
                  <li>Mutation: Ekleme, silme ve güncelleme işlemi için kullanacağınız tanımdır.</li>
                  <li>Subscription: Gerçek zamanlı çalışan projeler için kullanacağınız tanımdır.</li>
                </ul>
              </div>
              <div class="row" id="apolloServer">
                <h1>Apollo Server'a Giriş</h1>
                <p>
                  <a href="https://www.apollographql.com/docs/">Apollo Server</a>, hızlıca GraphQL sunucuları oluşturabileceğimiz, oldukça az bağımlılığı olan bir kütüphanedir.
                </p>
                <p>
                  Apollo server kullanmak için NodeJS pc de kurulu olmalı.
                </p>
                <p>
                  Bir dosya oluşturup açıyoruz. Açtığımız dosyanın içinde <pre class="prettyprint ms-0">npm init --yes</pre> yazıyoruz. <code>npm init</code> bizim yeni bir proje oluşturmamızı sağlar. <code>--yes</code> npm init sonrası sorulacak tüm soruların default olarak otomatik doldurulmasını sağlar.
                </p>
                <p>
                  Apollo server için 2 tane bağlılık gerekiyor. Bunları yüklemek için terminale <pre class="prettyprint ms-0">npm i @apollo/server graphql</pre> yazıyoruz.
                </p>
                <p>
                  ES6 import yapspını kullanabilmek için package.json dosyasında aşağıdaki ekleme yapılır.
                  <pre class="prettyprint ms-0">
  {
    // ...etc.
    "type": "module",
    "scripts": {
      "start": "node index.js"
    }
    // other dependencies
  }
                  </pre>
                </p>
                <p>
                  index.js dosyası oluşturulur. İçine: 
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from '@apollo/server/standalone';

  // Tip (type) tanımı:
  const typeDefs = `#graphql
    # GraphQL dizelerindeki yorumlar (bunun gibi) kare (#) simgesiyle başlar.
    # Bu "Book" türü, veri kaynağımızdaki her kitap için sorgulanabilir alanları tanımlar.

    type Book {
      title: String
      author: String
    }


    # "Query" türü özeldir: istemcilerin yürütebileceği tüm kullanılabilir sorguları ve her birinin dönüş türünü listeler. Bu durumda, "books" sorgusu sıfır veya daha fazla Book'tan (yukarıda tanımlanmıştır) oluşan bir dizi döndürür.
    type Query {
      books: [Book]
    }
    # data tipi ne ise ona ona uygun düzenlenmeli. Bu örnekte data tipi array olduğundan "[]" içine yazıldı.
  `;
  // data:
  const books = [
    {
      title: "The Awakening",
      author: "Kate Chopin",
    },
    {
      title: "City of Glass",
      author: "Paul Auster",
    },
    {
      title: "Yabancı",
      author: "Albert Camus",
    },
  ];

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      books: () => books,
    },
  };

  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alır. 1. tip tanımları, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`🚀  Server ready at: ${url}`);

                  </pre>
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm start</pre> yazdığımızda terminalde "🚀  Server ready at: http://localhost:4000/" çıktısını görürüz.
                </p>
                <p>
                  http://localhost:4000/ adresine gittiğimizde bizi sorgu yapmak için hazır bir arayüz ve dökümantasyon karşılar.
                </p>
                <p> Bu arayüze
                  <pre class="prettyprint ms-0">
  query ExampleQuery {
    books {
      title
    }
  }
                  </pre> yazarak datamızdaki kitap adlarına ulaşabiliriz.
                </p> 
                <p>
                  Bu sayfada gördüğümüz arayüzü, daha sık kullanılan graphql playground arayüzü ile değiştirmek için <a href="https://www.apollographql.com/docs/apollo-server/api/plugin/landing-pages/#graphql-playground-landing-page">bu yönerge</a> takip edilebilir ancak yapımcılar bunu önermiyor.
                </p>
                <p>
                  Kodu her güncellediğimizde serveri manuel restart etmemek için nodemon kurduk. Bunun için terminale <pre class="prettyprint ms-0">npm i --save-dev nodemon</pre> yazdık ve package.json>scripts alanına <pre class="prettyprint ms-0">"dev": "nodemon index.js",</pre> ekledik. Terminale <pre class="prettyprint ms-0">npm run dev</pre> yazarak serveri başlattığımızda her güncellemede kendini resetler.
                </p>
              </div>
              <div class="row" id="nonNullableFields">
                <h1>Non Nullable Fields</h1>
                <p>
                  GraphQL resolver tanımlarınız üzerinde null dönmemesini istediğiniz bir field veya tip varsa bunun için bir tanım yapabilirsiniz. "!" ile ifade edilir.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  ...
  type Book {
      title: String!
      author: String
    }
  ...

                  </pre>
                  ifadesi title alanının null dönemeyeceğini ifade eder.
                </p> 
                <p>
                  <pre class="prettyprint ms-0">
  ...
  type Query {
    books: [Book]!
  }
  ...
                  </pre>
                  ifadesi books sorgusunun null dönemeyeceğini ifade eder.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  ...
  type Query {
    books: [Book!]!
  }
  ...
                  </pre>
                  ifadesi books sorgusunu sonucunda gelen array içinde null eleman olamayacağını ifade eder.
                </p>
              </div>
              <div class="row" id="scalarTypes">
                <h1>Scalar Types</h1>
                <ul>GraphQL'nin varsayılan skaler türleri şunlardır:
                  <li>Int</li>
                  <li>Float</li>
                  <li>String</li>
                  <li>Boolean</li>
                  <li>ID</li>
                </ul>
                <p> Örnek kullanım:
                  <pre class="prettyprint ms-0">
  ...
  type Book {
    id: ID!
    title: String!
    author: String
    score: Float
    isPublished: Boolean
  }
  ...
                  </pre>
                  <pre class="prettyprint ms-0">
  const books = [
    {
      id: 1,
      title: "The Awakening",
      author: "Kate Chopin",
      score: 6.9,
      isPublished: true
    },
  ...
                  </pre>
                </p>
              </div>
              <div class="row" id="customTypes">
                <h1>Custom Types</h1>
                <p>
                  Girilen verinin tipini girerken aşağıdaki gibi tek tek girebiliriz:
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type Query {
      name: String!
      surname: String!
      age: Int
    }
  `;

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      name: () => "Murat",
      surname: () => "Gökduman",
      age: () => 29,
    },
  };
                  </pre> bunun yerine User için bir tip tanımı oluşturup bunu da geçebiliriz.
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type User {
      name: String!
      surname: String!
      age: Int
    }
    type Query {
      user: User
    }
  `;

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      user: () => ({
        name: "Murat",
        surname: "Gökduman",
        age: 29,
      }),
    },
  };
                  </pre> bu yazımda User bir custom type'dır. Daha önceki örneklerdeki Book da bir custom type'dir.
                </p>
                <p>
                  Bu durumda yeni bir veri girmek istersek ancak User içine dahil etmezsek veri ayrıca tiplendirilip resorve edilebilir.
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type User {
      name: String!
      surname: String!
      age: Int
    }
    type Query {
      user: User
      hello: String!
    }
  `;

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      user: () => ({
        name: "Murat",
        surname: "Gökduman",
        age: 29,
      }),
      hello: () => "world"
    },
  };
                  </pre>
                </p>
                <p>
                  localhost:4000 içinde aşağıdaki sorgu yapıldığında
                  <pre class="prettyprint ms-0">
  Query {
    hello
    user {
      name
      surname
    }
  }
                  </pre>
                  Aşağıdaki cevap alınır.
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "hello": "world",
      "user": {
        "name": "Murat",
        "surname": "Gökduman"
      }
    }
  }
                  </pre>
                </p>
                <p>
                  Custom type başka bir custom type içinde type olarak da kullanılabilir.
                  <pre class="prettyprint ms-0">
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books: [Book!]
    }

    type Book {
      id: ID!
      title: String!
      author: Author!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      book: [Book]
    }
    
  `;

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      book: () => books,
    },
  };
                  </pre>
                </p>
              </div>
              <div class="row" id="argumans">
                <h1>Argümanlar ile Çalışmak</h1>
                <p>
                  Hazırlık olarak çalıştığımız dataları data.js dosyasına taşıdık ve index.js içine import ettik.
                </p>
                <p>
                  data.js
                  <pre class="prettyprint ms-0">
  export const authors = [
    {
      id: 3,
      name: "Kate Chopin",
      score: 8,
      books: [],
    },
    {
      id: 2,
      name: "Paul Auster",
      score: 3,
      books: [],
    },
    {
      id: 1,
      name: "Albert Camus",
      score: 5,
      books: [],
    },
  ];

  export const books = [
    {
      id: 1,
      title: "The Awakening",
      author: authors[0],
      score: 6.9,
      isPublished: true,
    },
    {
      id: 2,
      title: "City of Glass",
      author: authors[1],
      score: 7,
    },
    {
      id: 3,
      title: "Yabancı",
      author: authors[2],
      isPublished: false,
    },
  ];
                  </pre>
                </p>
                <p>
                  id den kitap sorgulama ve id den yazar sorgulama için typeQuery alanına ilgili tip tanımları yapıldı. Sonrasında bu tip tanımlarına uygun resolve lar tanımlandı.
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";

  // data:
  import { books, authors } from "./data.js";

  // Tip (type) tanımı:
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books: [Book!]
    }

    type Book {
      id: ID!
      title: String!
      author: Author!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      books: [Book!]
      book(id: ID!): Book!
      
      authors: [Author!]
      author(id: ID!): Author!
    }
    
  `;

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      books: () => books,
      book: (parent, args) => {
        //4 parametre alır: 1. parent: ilişkisel veri tabanı oluştururken kullanacağız. 2. prametre istemciden gelen argümanı verir.
        const data = books.find((book) => book.id == args.id);
        return data;
      },

      authors: () => authors,
      author: (parent, args) => {
        const data = authors.find((author) => author.id == args.id);
        return data;
      }
    },
  };

  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alır. 1. tip tanımları, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`🚀  Server ready at: ${url}`);

                  </pre>
                </p>
                <p>
                  resolver alanında alınan 2. parametre sorguda bize gönderilen parametredir. Bundan faydalanarak bir find işlemi yapıldı ve gelen veri dönüldü.
                </p>
                <p>
                  Aşağıdaki sorgu yapıldığında
                  <pre class="prettyprint ms-0">
  query{
    author (id: 1){
      name
    }
    book(id: 3) {
      title
      author {
        name
      }
    }
  }
                  </pre>
                  aşağıdaki sonuç alınır
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "author": {
        "name": "Albert Camus"
      },
      "book": {
        "title": "Yabancı",
        "author": {
          "name": "Albert Camus"
        }
      }
    }
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="iliskiselData">
                <h1>İlişkisel Veriler ile Çalışmak</h1>
                <p>
                  Sorgu sırasında birbiri ile alakalı iki veriyi birbirine bağlamak mümkün. Bunun için aranacak karşılık data alanından silinir. Daha sonra resolvers içinde ilişkisi kurulur.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";

  // data:
  import { books, authors } from "./data.js";

  // Tip (type) tanımı:
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books: [Book!]
    }

    type Book {
      id: ID!
      title: String!
      author: Author
      author_id: ID!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      books: [Book!]
      book(id: ID!): Book!
      
      authors: [Author!]
      author(id: ID!): Author!
    }
    
  `;

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      books: () => books,
      book: (parent, args) => books.find((book) => book.id === args.id),
      
      authors: () => authors,
      author: (parent, args) => authors.find((author) => author.id === args.id),
    },
    Book: {
      // Book tipi altındaki author keyi için girilen resolver.
      author: (
        parent, // parent sorgunun yapıldığı parent tipin değerini döner.
        args 
      ) => authors.find((author) => author.id === parent.author_id),
    },
    Author: {
      books: (parent, args) =>
        books.filter((book) => book.author_id === parent.id),
    },
  };

  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alır. 1. tip tanımları, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`🚀  Server ready at: ${url}`);

                  </pre>
                </p>
                <p>
                  tip alanında istenilen veri keyi veri tipi ile bağlantılanır.
                </p>
                <p>
                  resolver alanında hangi tipin altında hangi sorgu yapılırsa nasıl bir verinin çekileceği tanımlanır.
                </p>
                <p>
                  Book altında author sorgulandığında parent alanından aldığı author_id ile authors içinde data arar.
                </p>
                <p>
                  Author altında books sorgulandığında books içinde author_id değeri barent.id ile uyumlu olanları filtreler.
                </p>
              </div>
              <div class="row" id="iliskiselDataArgumanlar">
                <h1>İlişkisel İfadelerde Argümanlar</h1>
                <p>
                  Author altında books sorgusuna ilk harfe göre filtreleme özelliği eklemek için aşağıdaki örneği yaptık.
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";

  // data:
  import { books, authors } from "./data.js";
                  </pre>
                  <pre class="prettyprint ms-0">
  // Tip (type) tanımı:
  const typeDefs = `#graphql

    type Author {
      id: ID!
      name: String!
      score: Float
      age: Int
      books(filter: String): [Book!] # filtreleme işlemi için
    }
                  </pre> books için parametre alabilme özelliği ve alacağı parametrenin veri tipi belirtildi.
                  <pre class="prettyprint ms-0">
  type Book {
      id: ID!
      title: String!
      author: Author
      author_id: ID!
      isPublsihed: Boolean
      score: Float
    }

    type Query {
      books: [Book!]
      book(id: ID!): Book!
      
      authors: [Author!]
      author(id: ID!): Author!
    }
    
  `;

  // resolvers (çözücü):
  const resolvers = {
    Query: {
      books: () => books,
      book: (parent, args) => books.find((book) => book.id === args.id),

      authors: () => authors,
      author: (parent, args) => authors.find((author) => author.id === args.id),
    },
    Book: {
      author: (parent, args) =>
        authors.find((author) => author.id === parent.author_id),
    },
                  </pre>
                  <pre class="prettyprint ms-0">
  Author: {
      books: (parent, args) => {
        let filtered = books.filter((book) => book.author_id === parent.id);

        if (args.filter) { // sorguda filter var ise
          filtered = filtered.filter((book) =>
            book.title.toLowerCase().startsWith(args.filter.toLowerCase()) // args.filter verisine göre filtreler.
          );
        }
        return filtered;
      },
    },
  };
                  </pre> sorguda book için filter parametresi geçildiyse ilk harfe göre filtreleme yapılır.
                  <pre class="prettyprint ms-0">
  // apollo server:
  const server = new ApolloServer({ typeDefs, resolvers }); // iki parametre alır. 1. tip tanımları, 2. resolvers

  const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
  });

  console.log(`🚀  Server ready at: ${url}`);
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="mutations">
              <div class="row" id="whatIsMutation">
                <h1>Mutation Nedir? Nasıl Yazılır?</h1>
                <p>
                  Mutation tanımı, GraphQL sunucuları üzerinde veri ekleme,silme veya güncelleme durumlarında kullanılır.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid"; // user id için gerekli
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
      type User {
          id: ID!
          fullName: String!
          posts: [Post]
          comments: [Comment]
      }
  
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
  
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
  
      type Query {
          users: [User!]!
          user(id: ID!): User!
  
          posts: [Post!]
          post(id: ID!): Post!
  
          comments: [Comment]
          comment(id: ID!): Comment!
      }
  
      type Mutation {
        createUser(fullName: String!): User! #createUser parametre olarak fullName keyi ile string alır. response olarak User döner.
        createPost(title: String!, user_id: ID!): Post!
        createComment(text: String!, post_id: ID!, user_id: ID!): Comment!
      }
  `;
  
  const resolvers = {
    Mutation: {
      createUser: (parent, args) => {
        // yeni user ekleme
        const user = {
          id: nanoid(),
          fullName: args.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      createPost: (parent, args) => {
        // yeni post ekleme
        const post = { id: nanoid(), title: args.title, user_id: args.user_id };
  
        posts.push(post);
  
        return post;
      },
      createComment: (parent, { text, post_id, user_id }) => {
        //args destruct edildi
        // yeni comment ekleme
        const comment = {
          id: nanoid(),
          text, // parametre key ve value aynı olduğundan tek kelimeyle yazılabilir.
          post_id,
          user_id,
        };
  
        comments.push(comment);
  
        return comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`🚀  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="inputType">
                <h1>Input Type</h1>
                <p>
                  Mutation için yazılan parametre tanımları, kdun temiz kalması için, başka bir alanda yazılabilir. Bu alan input tanımı ile başlar. Parametre içinde data ketyi ile karşılanır.
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid"; // user id için gerekli
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
  
      type User {
          id: ID!
          fullName: String!
          posts: [Post]
          comments: [Comment]
      }
  
      input CreateUserInput { # createUser mutationu için parametre tanımları.
        fullName: String!
      }
  
      type Post {
          id: ID!
          title: String!
          user_id: ID!
          comments: [Comment!]
          user: User!
      }
      input CreatePostInput { # createPost mutationu için parametre tanımları.
        title: String!
        user_id: ID!
      }
  
      type Comment {
          id: ID!
          text: String!
          post_id: ID!
          post: Post!
          user: User!
      }
      input CreateCommetInput{
        text: String!
        post_id: ID!
        user_id: ID!
      }
  
      type Query {
          users: [User!]!
          user(id: ID!): User!
  
          posts: [Post!]
          post(id: ID!): Post!
  
          comments: [Comment]
          comment(id: ID!): Comment!
      }
  
      type Mutation {
        createUser(data: CreateUserInput!): User! #input type tanımı data keyi ile geçilir.
        createPost(data: CreatePostInput!): Post!
        createComment(data: CreateCommetInput!): Comment!
      }
  `;
  
  const resolvers = {
    Mutation: {
      createUser: (parent, args) => {
        // yeni user ekleme
        const user = {
          id: nanoid(),
          fullName: args.data.fullName, // gelen arguman data altında gelir.
        };
  
        users.push(user);
  
        return user;
      },
      createPost: (parent, { data: { title, user_id } }) => {
        //args.data destruct edildi
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data, // data içindeki veri obje olarak tamamen eklendi.
        };
  
        comments.push(comment);
  
        return comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`🚀  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="updateMutations">
                <h1>Update Mutations</h1>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
    # User
    type User {
        id: ID!
        fullName: String!
        age: Int!
        posts: [Post]
        comments: [Comment]
    }
  
    input CreateUserInput { 
      fullName: String!
      age: Int!
    }
  
    input UpdateUserInput {
      fullName: String
      age: Int
    }
  
    # Post
    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }
    input CreatePostInput { 
      title: String!
      user_id: ID!
    }
    input UpdatePostInput {
      title: String
      user_id: ID
    }
  
    # Comment
    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }
    input CreateCommetInput{
      text: String!
      post_id: ID!
      user_id: ID!
    }
    input UpdateCommentInput{
      text: String
      post_id: ID
      user_id: ID
    }
  
    type Query {
        users: [User!]!
        user(id: ID!): User!
  
        posts: [Post!]
        post(id: ID!): Post!
  
        comments: [Comment]
        comment(id: ID!): Comment!
    }
  
    type Mutation {
      # User
      createUser(data: CreateUserInput!): User! 
      updateUser(id: ID!, data: UpdateUserInput!): User!
      # Post
      createPost(data: CreatePostInput!): Post!
      updatePost(id: ID!, data: UpdatePostInput!): Post
  
      # Comment
      createComment(data: CreateCommetInput!): Comment!
      updateComment(id: ID!, data: UpdateCommentInput!): Comment!
    }
  `;
  
  const resolvers = {
    Mutation: {
      // User
      createUser: (parent, args) => {
        const user = {
          id: nanoid(),
          fullName: args.data.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      updateUser: (parent, { id, data }) => {
        const user_index = users.findIndex((user) => user.id === id);
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const update_user = (users[user_index] = {
          ...users[user_index], // önce mevcut tanımları al
          ...data, // data altından gelenlerle merge et.
        });
  
        return update_user;
      },
      // Post
      createPost: (parent, { data: { title, user_id } }) => {
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      updatePost: (parent, { id, data }) => {
        const post_index = posts.findIndex((post) => post.id === id);
  
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const updated_post = (posts[post_index] = {
          ...posts[post_index],
          ...data,
        });
  
        return updated_post;
      },
      // Comment
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data,
        };
  
        comments.push(comment);
  
        return comment;
      },
      updateComment: (parent, { id, data }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
  
        if (comment_index === -1) {
          throw new Error("Comment not found.");
        }
  
        const updated_comment = (comments[comment_index] = {
          ...comments[comment_index],
          ...data,
        });
  
        return updated_comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`🚀  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="deleteMutations">
                <h1>Delete Mutations</h1>
                <p>
                  <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
    # User
    type User {
        id: ID!
        fullName: String!
        age: Int!
        posts: [Post]
        comments: [Comment]
    }
  
    input CreateUserInput { 
      fullName: String!
      age: Int!
    }
  
    input UpdateUserInput {
      fullName: String
      age: Int
    }
  
    # Post
    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }
    input CreatePostInput { 
      title: String!
      user_id: ID!
    }
    input UpdatePostInput {
      title: String
      user_id: ID
    }
  
    # Comment
    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }
    input CreateCommetInput{
      text: String!
      post_id: ID!
      user_id: ID!
    }
    input UpdateCommentInput{
      text: String
      post_id: ID
      user_id: ID
    }
  
    type Query {
        users: [User!]!
        user(id: ID!): User!
  
        posts: [Post!]
        post(id: ID!): Post!
  
        comments: [Comment]
        comment(id: ID!): Comment!
    }
  
    type Mutation {
      # User
      createUser(data: CreateUserInput!): User! 
      updateUser(id: ID!, data: UpdateUserInput!): User!
      deleteUser(id: ID!): User!
      # Post
      createPost(data: CreatePostInput!): Post!
      updatePost(id: ID!, data: UpdatePostInput!): Post!
      deletePost(id: ID!): Post!
  
      # Comment
      createComment(data: CreateCommetInput!): Comment!
      updateComment(id: ID!, data: UpdateCommentInput!): Comment!
      deleteComment(id: ID!): Comment!
    }
  `;
  
  const resolvers = {
    Mutation: {
      // User
      createUser: (parent, args) => {
        const user = {
          id: nanoid(),
          fullName: args.data.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      updateUser: (parent, { id, data }) => {
        const user_index = users.findIndex((user) => user.id === id);
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const update_user = (users[user_index] = {
          ...users[user_index],
          ...data,
        });
  
        return update_user;
      },
      deleteUser: (parent, { id }) => {
        // silme işlemi için: 1. filter metodunda id si parent.id olmayanları filtreleyip users'a atayabiliriz. 2. indexini bulup slice ile çıkartabiliriz.
        const user_index = users.findIndex((user) => user.id === id); // bu idye sahip kullanıcı var mı?
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const deleted_user = users[user_index]; // silinecek olanı ayrı bir yere kaydettik
  
        users.splice(user_index, 1); //splice iki parametre alır. Silinecek olanın indexi ve indexten itibaren kaç eleman silineceği. 3 parametre olarak da yerine eklenecek ögeyi alabilir.
  
        return deleted_user;
      },
      // Post
      createPost: (parent, { data: { title, user_id } }) => {
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      updatePost: (parent, { id, data }) => {
        const post_index = posts.findIndex((post) => post.id === id);
  
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const updated_post = (posts[post_index] = {
          ...posts[post_index],
          ...data,
        });
  
        return updated_post;
      },
      deletePost: (parent, { id }) => {
        const post_index = posts.findIndex((post) => post.id === id);
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const deleted_post = posts[post_index];
  
        posts.splice(post_index, 1);
  
        return deleted_post;
      },
  
      // Comment
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data,
        };
  
        comments.push(comment);
  
        return comment;
      },
      updateComment: (parent, { id, data }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
  
        if (comment_index === -1) {
          throw new Error("Comment not found.");
        }
  
        const updated_comment = (comments[comment_index] = {
          ...comments[comment_index],
          ...data,
        });
  
        return updated_comment;
      },
      deleteComment: (parent, { id }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
        if (comment_index === -1) {
          throw new Error("Comment not found");
        }
  
        const deleted_comment = comments[comment_index];
  
        comments.splice(comment_index, 1);
        
        return deleted_comment;
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`🚀  Server ready at: ${url}`);
  
                  </pre>
                </p>
              </div>
              <div class="row" id="deleteAllMutations">
                <h1>Delete All Mutations</h1>
                <pre class="prettyprint ms-0">
  import { ApolloServer } from "@apollo/server";
  import { startStandaloneServer } from "@apollo/server/standalone";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const typeDefs = `#graphql
    # User
    type User {
        id: ID!
        fullName: String!
        age: Int!
        posts: [Post]
        comments: [Comment]
    }
  
    input CreateUserInput { 
      fullName: String!
      age: Int!
    }
  
    input UpdateUserInput {
      fullName: String
      age: Int
    }
  
    # Post
    type Post {
        id: ID!
        title: String!
        user_id: ID!
        comments: [Comment!]
        user: User!
    }
    input CreatePostInput { 
      title: String!
      user_id: ID!
    }
    input UpdatePostInput {
      title: String
      user_id: ID
    }
  
    # Comment
    type Comment {
        id: ID!
        text: String!
        post_id: ID!
        post: Post!
        user: User!
    }
    input CreateCommetInput{
      text: String!
      post_id: ID!
      user_id: ID!
    }
    input UpdateCommentInput{
      text: String
      post_id: ID
      user_id: ID
    }
  
    type DeleteAllOutput {
      count: Int!
    }
  
    type Query {
        users: [User!]!
        user(id: ID!): User!
  
        posts: [Post!]
        post(id: ID!): Post!
  
        comments: [Comment]
        comment(id: ID!): Comment!
    }
  
    type Mutation {
      # User
      createUser(data: CreateUserInput!): User! 
      updateUser(id: ID!, data: UpdateUserInput!): User!
      deleteUser(id: ID!): User!
      deleteAllUsers: DeleteAllOutput!
      # Post
      createPost(data: CreatePostInput!): Post!
      updatePost(id: ID!, data: UpdatePostInput!): Post!
      deletePost(id: ID!): Post!
      deleteAllPosts: DeleteAllOutput!
  
      # Comment
      createComment(data: CreateCommetInput!): Comment!
      updateComment(id: ID!, data: UpdateCommentInput!): Comment!
      deleteComment(id: ID!): Comment!
      deleteAllComments: DeleteAllOutput!
    }
  `;
  
  const resolvers = {
    Mutation: {
      // User
      createUser: (parent, args) => {
        const user = {
          id: nanoid(),
          fullName: args.data.fullName,
        };
  
        users.push(user);
  
        return user;
      },
      updateUser: (parent, { id, data }) => {
        const user_index = users.findIndex((user) => user.id === id);
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const update_user = (users[user_index] = {
          ...users[user_index],
          ...data,
        });
  
        return update_user;
      },
      deleteUser: (parent, { id }) => {
        const user_index = users.findIndex((user) => user.id === id); 
        if (user_index === -1) {
          throw new Error("User not found.");
        }
  
        const deleted_user = users[user_index]; 
  
        users.splice(user_index, 1); 
  
        return deleted_user;
      },
      deleteAllUsers: () => {
        const length = users.length;
        // users = []; // users tanımlanırken const ile tanımlandığından bu method çalışmaz. Bunun çalışabilmesi içiin const ifadesi let ile değiştirilebilir veya farklı bir metod kullanılabilir.
  
        users.splice(0, length); // 0 dan başlayıp tüm elemanları siler
  
        return {
          count: length,
        };
      },
      // Post
      createPost: (parent, { data: { title, user_id } }) => {
        const post = {
          id: nanoid(),
          title,
          user_id,
        };
  
        posts.push(post);
  
        return post;
      },
      updatePost: (parent, { id, data }) => {
        const post_index = posts.findIndex((post) => post.id === id);
  
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const updated_post = (posts[post_index] = {
          ...posts[post_index],
          ...data,
        });
  
        return updated_post;
      },
      deletePost: (parent, { id }) => {
        const post_index = posts.findIndex((post) => post.id === id);
        if (post_index === -1) {
          throw new Error("Post not found.");
        }
  
        const deleted_post = posts[post_index];
  
        posts.splice(post_index, 1);
  
        return deleted_post;
      },
      deleteAllPosts: () => {
        const length = posts.length;
  
        posts.splice(0, length);
  
        return {
          count: length,
        };
      },
  
      // Comment
      createComment: (parent, { data }) => {
        const comment = {
          id: nanoid(),
          ...data,
        };
  
        comments.push(comment);
  
        return comment;
      },
      updateComment: (parent, { id, data }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
  
        if (comment_index === -1) {
          throw new Error("Comment not found.");
        }
  
        const updated_comment = (comments[comment_index] = {
          ...comments[comment_index],
          ...data,
        });
  
        return updated_comment;
      },
      deleteComment: (parent, { id }) => {
        const comment_index = comments.findIndex((comment) => comment.id === id);
        if (comment_index === -1) {
          throw new Error("Comment not found");
        }
  
        const deleted_comment = comments[comment_index];
  
        comments.splice(comment_index, 1);
  
        return deleted_comment;
      },
      deleteAllComments: () => {
        const length = comments.length;
        comments.splice(0, length);
        return {
          count: length,
        };
      },
    },
    Query: {
      users: () => users,
      user: (parent, args) => {
        const user = users.find((user) => user.id === args.id);
        if (!user) {
          return new Error("User not found");
        }
  
        return user;
      },
  
      posts: () => posts,
      post: (parent, args) => posts.find((post) => post.id === args.id),
  
      comments: () => comments,
      comment: (parent, args) =>
        comments.find((comment) => comment.id === args.id),
    },
    User: {
      posts: (parent, args) => posts.filter((post) => post.user_id === parent.id),
      comments: (parent, args) =>
        comments.filter((comment) => comment.user_id === parent.id),
    },
    Post: {
      comments: (parent, args) =>
        comments.filter((comment) => comment.post_id === parent.id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
    Comment: {
      post: (parent, args) => posts.find((post) => post.id === parent.post_id),
      user: (parent, args) => users.find((user) => user.id === parent.user_id),
    },
  };
  
  const server = new ApolloServer({ typeDefs, resolvers });
  
  const { url } = await startStandaloneServer(server, { listen: { port: 4000 } });
  
  console.log(`🚀  Server ready at: ${url}`);
  
                </pre>
              </div>
            </div>
            <div class="row" id="subscription">
              <div class="row" id="subscriptionServerSetup">
                <h1>Subscription Server Kurulumu</h1>
                <p>
                  Subscription tanımı gerçekleşen olaylardan(ekleme,silme,güncelleme vb.) gerçek zamanlı olarak haberdar olabileceğimiz WebSocket tabanlı bir yapıdır.
                </p>
                <p>
                  Apollo Server'ın 3. versiyonu ile birlikte Subscription yapısı core üzerinden kaldırıldı ancak ek kütüphaneler ekleyerek bunu yeniden aktifleştirebilirsiniz. Bu işlem sırasında birden fazla kütüphanenin kurulması gerekiyor ve kod biraz daha karmaşık görünüyor. Bundan kurtulmak için <a href="https://github.com/dotansimha/graphql-yoga">graphql yoga</a> adında bir kütüphaneden faydalanacağız.
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">npm i graphql-yoga</pre> yazıyoruz
                </p>
                <p>
                  Dersin videosu güncel değil. Biz kendi yolumuzu bulacağız. <a href="https://the-guild.dev/graphql/yoga-server/docs/features/subscriptions">Bunu</a> uyguladık.
                </p>
                <p>
                  <a href="https://github.com/dotansimha/graphql-yoga/blob/main/examples/subscriptions/src/index.ts">Bu</a> da kullanılabilir. Aynı methodun farklı yazılmışı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga"; //graphql-yoga içinden gerekenler import edildi.
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub(); // Yayın için gereken middleware
  
  const yoga = createYoga({
    // Şemayı sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Örnek için
          userCreated: User!
        }
      `,
      resolvers: {
        Subscription: {
          // count: { // Örnek
          //   subscribe: () => { // Her saniye değeri 1 arttırıp iletir
          //     let count = 0;
  
          //     setInterval(() => {
          //       count++;
          //       pubSub.publish("count", {count});
          //     }, 1000);
  
          //     return pubSub.subscribe("count")
          //   }
          // }
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"), // kanala abone olduk.
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age
            };
  
            users.push(user);
            pubSub.publish("userCreated", {"userCreated": user}); // yayın yapıldı.
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
  
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length); 
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
  
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
  
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="userCRUDsubs">
                <h1>User CRUD Subscriptions</h1>
                <p>
                  Yukarıdaki işlemleri diğer user Crud işlemlerine uyarladık.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // Şemayı sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Örnek için
  
          # User
          userCreated: User!
          userUpdated: User!
          userDeleted: User!
  
        }
      `,
      resolvers: {
        Subscription: {
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"),
          },
          userUpdated: {
            subscribe: () => pubSub.subscribe("userUpdated"), // yayına abone olundu
          },
          userDeleted: {
            subscribe: () => pubSub.subscribe("userDeleted"), // yayına abone olundu
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age,
            };
  
            users.push(user);
            pubSub.publish("userCreated", { userCreated: user });
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
            pubSub.publish("userUpdated", { userUpdated: update_user, }); //yayın yapıldı
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            pubSub.publish("userDeleted", { userDeleted: deleted_user }); // yayın yapıldı
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length);
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
  
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
  
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="postVeCommentCRUDsubs">
                <h1>Post ve Comment CRUD Subscriptions</h1>
                <p>
                  Yukarıdaki işlemi post ve comment için tekrarlıyoruz.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // Şemayı sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Örnek için
  
          # User
          userCreated: User!
          userUpdated: User!
          userDeleted: User!
  
          # Post
          postCreated: Post!
          postUpdated: Post!
          postDeleted: Post!
          postsCount: Int!
  
          # Comment
          commentCreated: Comment!
          commentUpdated: Comment!
          commentDeleted: Comment!
        }
      `,
      resolvers: {
        Subscription: {
          // User
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"),
          },
          userUpdated: {
            subscribe: () => pubSub.subscribe("userUpdated"),
          },
          userDeleted: {
            subscribe: () => pubSub.subscribe("userDeleted"),
          },
  
          // Post
          postCreated: {
            subscribe: () => pubSub.subscribe("postCreated"),
          },
          postUpdated: {
            subscribe: () => pubSub.subscribe("postUpdated"),
          },
          postDeleted: {
            subscribe: () => pubSub.subscribe("postDeleted"),
          },
          postsCount: {
            subscribe: () => {
              setTimeout(() => {
                pubSub.publish("postsCount", { postsCount: posts.length })
              }); // publish işlemi subscribe işleminden sonra olmalı. Bu nedenle geçikme koyduk
              return pubSub.subscribe("postsCount");
            },
          },
  
          // Comment
          commentCreated: {
            subscribe: () => pubSub.subscribe("commentCreated"),
          },
          commentUpdated: {
            subscribe: () => pubSub.subscribe("commentUpdated"),
          },
          commentDeleted: {
            subscribe: () => pubSub.subscribe("commentDeleted"),
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age,
            };
  
            users.push(user);
            pubSub.publish("userCreated", { userCreated: user });
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
            pubSub.publish("userUpdated", { userUpdated: update_user }); //yayın yapıldı
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            pubSub.publish("userDeleted", { userDeleted: deleted_user }); // yayın yapıldı
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length);
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            pubSub.publish("postCreated", { postCreated: post });
            pubSub.publish("postsCount", { postsCount: posts.length });
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            pubSub.publish("postUpdated", { postUpdated: updated_post });
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
            pubSub.publish("postDeleted", { postDeleted: deleted_post });
            pubSub.publish("postsCount", { postsCount: posts.length });
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
            pubSub.publish("postsCount", { postsCount: posts.length });
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            pubSub.publish("commentCreated", { commentCreated: comment });
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
            pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="withFilter">
                <h1>withFilter ile Subscription Filtreleme</h1>
                <p>
                  Subscription sırasında paraametre ile filtreleme yapacağız.
                </p>
                <p>
                  biz v4 kullanıyoruz. hocanın methodu bizde işe yaramıyor. Bu nedenle dökümantasyondan <a href="https://the-guild.dev/graphql/yoga-server/docs/migration/migration-from-yoga-v1">buradan</a> ve <a href="https://the-guild.dev/graphql/yoga-server/docs/features/subscriptions#filter-and-map-values">buradan</a> faydalanarak kendi kodumuzu yazıyoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  import {
    createYoga,
    createSchema,
    createPubSub,
    filter,
    pipe,
    map,
  } from "graphql-yoga"; //filter ve pipe subscription filtreleme için import edildi.
  import { createServer } from "node:http";
  import { nanoid } from "nanoid";
  
  import { users, posts, comments } from "./data.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // Şemayı sarmala
    schema: createSchema({
      typeDefs: `#graphql
        # User
        type User {
            id: ID!
            fullName: String!
            age: Int!
            posts: [Post]
            comments: [Comment]
        }
  
        input CreateUserInput { 
          fullName: String!
          age: Int!
        }
  
        input UpdateUserInput {
          fullName: String
          age: Int
        }
  
        # Post
        type Post {
            id: ID!
            title: String!
            user_id: ID!
            comments: [Comment!]
            user: User!
        }
        input CreatePostInput { 
          title: String!
          user_id: ID!
        }
        input UpdatePostInput {
          title: String
          user_id: ID
        }
  
        # Comment
        type Comment {
            id: ID!
            text: String!
            post_id: ID!
            post: Post!
            user: User!
        }
        input CreateCommetInput{
          text: String!
          post_id: ID!
          user_id: ID!
        }
        input UpdateCommentInput{
          text: String
          post_id: ID
          user_id: ID
        }
  
        type DeleteAllOutput {
          count: Int!
        }
  
        type Query {
            users: [User!]!
            user(id: ID!): User!
  
            posts: [Post!]
            post(id: ID!): Post!
  
            comments: [Comment]
            comment(id: ID!): Comment!
        }
  
        type Mutation {
          # User
          createUser(data: CreateUserInput!): User! 
          updateUser(id: ID!, data: UpdateUserInput!): User!
          deleteUser(id: ID!): User!
          deleteAllUsers: DeleteAllOutput!
          # Post
          createPost(data: CreatePostInput!): Post!
          updatePost(id: ID!, data: UpdatePostInput!): Post!
          deletePost(id: ID!): Post!
          deleteAllPosts: DeleteAllOutput!
  
          # Comment
          createComment(data: CreateCommetInput!): Comment!
          updateComment(id: ID!, data: UpdateCommentInput!): Comment!
          deleteComment(id: ID!): Comment!
          deleteAllComments: DeleteAllOutput!
        }
  
        type Subscription {
          # count: Int! # Örnek için
  
          # User
          userCreated: User!
          userUpdated: User!
          userDeleted: User!
  
          # Post
          postCreated(user_id: ID): Post! #postCreated parametre alacak şekilde düzenlendi.
          postUpdated: Post!
          postDeleted: Post!
          postsCount: Int!
  
          # Comment
          commentCreated(post_id: ID): Comment!
          commentUpdated: Comment!
          commentDeleted: Comment!
        }
      `,
      resolvers: {
        Subscription: {
          // User
          userCreated: {
            subscribe: () => pubSub.subscribe("userCreated"),
          },
          userUpdated: {
            subscribe: () => pubSub.subscribe("userUpdated"),
          },
          userDeleted: {
            subscribe: () => pubSub.subscribe("userDeleted"),
          },
  
          // Post
          postCreated: {
            subscribe: (parent, args) => {
              return pipe(
                // pipe 2 parametre alır.
                pubSub.subscribe("postCreated"), // 1. parametre yayına abone olmak için kullanılan fonksiyon.
                filter((value) => // 2 parametre filter. içi true dönerse değeri yakalar. yoksa es geçer.
                  args.user_id // args.user_id varsa 
                  ? value.postCreated.user_id === args.user_id // bu kıyaslama yapılır. 
                  : true // args.user_id yoksa parametre geçilmemiştir. true döner.
                )
              );
            },
          },
          postUpdated: {
            subscribe: () => pubSub.subscribe("postUpdated"),
          },
          postDeleted: {
            subscribe: () => pubSub.subscribe("postDeleted"),
          },
          postsCount: {
            subscribe: () => {
              setTimeout(() => {
                pubSub.publish("postsCount", { postsCount: posts.length });
              });
              return pubSub.subscribe("postsCount");
            },
          },
  
          // Comment
          commentCreated: {
            subscribe: (parent, args) => {
              return pipe( // Yukarıdaki örneğin tekrarı.
                pubSub.subscribe("commentCreated"),
                filter((value) =>
                  args.post_id
                    ? value.commentCreated.post_id === args.post_id
                    : true
                )
              );
            },
          },
          commentUpdated: {
            subscribe: () => pubSub.subscribe("commentUpdated"),
          },
          commentDeleted: {
            subscribe: () => pubSub.subscribe("commentDeleted"),
          },
        },
        Mutation: {
          // User
          createUser: (parent, args) => {
            const user = {
              id: nanoid(),
              fullName: args.data.fullName,
              age: args.data.age,
            };
  
            users.push(user);
            pubSub.publish("userCreated", { userCreated: user });
  
            return user;
          },
          updateUser: (parent, { id, data }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const update_user = (users[user_index] = {
              ...users[user_index],
              ...data,
            });
            pubSub.publish("userUpdated", { userUpdated: update_user });
            return update_user;
          },
          deleteUser: (parent, { id }) => {
            const user_index = users.findIndex((user) => user.id === id);
            if (user_index === -1) {
              throw new Error("User not found.");
            }
  
            const deleted_user = users[user_index];
  
            users.splice(user_index, 1);
  
            pubSub.publish("userDeleted", { userDeleted: deleted_user });
            return deleted_user;
          },
          deleteAllUsers: () => {
            const length = users.length;
  
            users.splice(0, length);
  
            return {
              count: length,
            };
          },
          // Post
          createPost: (parent, { data: { title, user_id } }) => {
            const post = {
              id: nanoid(),
              title,
              user_id,
            };
  
            posts.push(post);
  
            pubSub.publish("postCreated", { postCreated: post });
            pubSub.publish("postsCount", { postsCount: posts.length });
            return post;
          },
          updatePost: (parent, { id, data }) => {
            const post_index = posts.findIndex((post) => post.id === id);
  
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const updated_post = (posts[post_index] = {
              ...posts[post_index],
              ...data,
            });
  
            pubSub.publish("postUpdated", { postUpdated: updated_post });
            return updated_post;
          },
          deletePost: (parent, { id }) => {
            const post_index = posts.findIndex((post) => post.id === id);
            if (post_index === -1) {
              throw new Error("Post not found.");
            }
  
            const deleted_post = posts[post_index];
  
            posts.splice(post_index, 1);
            pubSub.publish("postDeleted", { postDeleted: deleted_post });
            pubSub.publish("postsCount", { postsCount: posts.length });
  
            return deleted_post;
          },
          deleteAllPosts: () => {
            const length = posts.length;
  
            posts.splice(0, length);
            pubSub.publish("postsCount", { postsCount: posts.length });
            return {
              count: length,
            };
          },
  
          // Comment
          createComment: (parent, { data }) => {
            const comment = {
              id: nanoid(),
              ...data,
            };
  
            comments.push(comment);
  
            pubSub.publish("commentCreated", { commentCreated: comment });
            return comment;
          },
          updateComment: (parent, { id, data }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
  
            if (comment_index === -1) {
              throw new Error("Comment not found.");
            }
  
            const updated_comment = (comments[comment_index] = {
              ...comments[comment_index],
              ...data,
            });
            pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
            return updated_comment;
          },
          deleteComment: (parent, { id }) => {
            const comment_index = comments.findIndex(
              (comment) => comment.id === id
            );
            if (comment_index === -1) {
              throw new Error("Comment not found");
            }
  
            const deleted_comment = comments[comment_index];
  
            comments.splice(comment_index, 1);
  
            pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
            return deleted_comment;
          },
          deleteAllComments: () => {
            const length = comments.length;
            comments.splice(0, length);
            return {
              count: length,
            };
          },
        },
        Query: {
          users: () => users,
          user: (parent, args) => {
            const user = users.find((user) => user.id === args.id);
            if (!user) {
              return new Error("User not found");
            }
  
            return user;
          },
  
          posts: () => posts,
          post: (parent, args) => posts.find((post) => post.id === args.id),
  
          comments: () => comments,
          comment: (parent, args) =>
            comments.find((comment) => comment.id === args.id),
        },
        User: {
          posts: (parent, args) =>
            posts.filter((post) => post.user_id === parent.id),
          comments: (parent, args) =>
            comments.filter((comment) => comment.user_id === parent.id),
        },
        Post: {
          comments: (parent, args) =>
            comments.filter((comment) => comment.post_id === parent.id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
        Comment: {
          post: (parent, args) =>
            posts.find((post) => post.id === parent.post_id),
          user: (parent, args) =>
            users.find((user) => user.id === parent.user_id),
        },
      },
    }),
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="redisPubsub">
                <h1>Redis PubSub (Konu çözülemedi.)</h1>
                <p>
                  Birden fazla sunucu kullanılması gereken durumlarda pubSub işlemlerinin sunucuda olması diğer sunucularda yapılan işlemleri okuyamamasına neden olur. Bu nedenle pubSub işlemleri sunucu dışında redis üzerinde tutulabilir.
                </p>
                <p>
                  <b>Redis:</b> bir veri yapısı sunucusudur. Açık kaynak, bellek kullanımlı, anahtar-değer deposudur. Redis "Uzak Sözlük Sunucusu" (İngilizce: "REmote DIctionary Server") anlamına gelmektedir. Çeşitli kaynaklara göre en çok kullanılan anahtar-değer veritabanıdır.
                </p>
                <p>
                  Bunun için <a href="https://github.com/davidyaha/graphql-redis-subscriptions">graphql-redis-subscriptions</a> kullanacağız. <a href="https://github.com/davidyaha/graphql-redis-subscriptions#creating-a-redis-client">buradaki</a> örneği baz alıyoruz.
                </p>
                <p>
                  terminale: <pre class="prettyprint ms-0">npm i graphql-redis-subscriptions</pre> ve <pre class="prettyprint ms-0">npm i ioredis</pre> yazıyoruz.
                </p>
                <p>
                  Hoca redis için heroku kullanmış. heruko artık free değil. Biz <a href="https://dashboard.render.com/">render</a> kullanacağız.
                </p>
                <p>
                  new > redis > create redis
                </p>
                <p>
                  projemizin kök dizinine pubsub.js dosyası oluşturulur. İçine <a href="https://github.com/davidyaha/graphql-redis-subscriptions#creating-a-redis-client">buradaki</a> örneği yapıştırıyoruz. İlgili alanları da oluşturduğumuz redis serverına göre dolduruyoruz. External redis url <pre class="prettyprint ms-0">rediss://username:password@host:port</pre> kalıbına göre oluşturulmuştur. Buradaki veriler örneğe uygun olarak ayrıştırılır.
                </p>
                <p>
                  Kullanılan teknolojilerde çakışma var. Son sürümler çalışmıyor. Daha sonra tekrar denenecek.
                </p>
                <p style="color: rgb(6, 194, 6); background-color: black; padding: 10px; font-family: monospace;">
                  birden fazla metod denendi. 5. saatin sonunda konu daha sonra irdelenmek üzere bırakıldı. Kullanılan iki pakette çakışma mevcut. 
                </p>
              </div>
              <div class="row" id="env">
                <h1>Ortam Değişkenleri</h1>
                <p>
                  Kaynak kodumuzda görünmesini istemediğimiz bilgiler için .env adında bir dosya oluşturuyoruz. Bunun içinde <pre class="prettyprint ms-0">PASS="password1234"</pre> gibi tanımımızı yapıyoruz. Bu bilgileri kullanmak için terminale <pre class="prettyprint ms-0">npm i dotenv</pre> yazarak ilgili paketi kuruyoruz.
                </p>
                <p>
                  Bu bilgiyi kullanmak istediğimiz dosyada <code>dotenv</code> paketini import edip çalıştırıyoruz.
                  <pre class="prettyprint ms-0">
  import dotenv from "dotenv"
  dotenv.config()
                  </pre>
                  Artık .env içindeki veriyi kullanabiliriz.
                  <pre class="prettyprint ms-0">
  ...
  password: process.env.PASS
  ...
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="folderSchemaStructure">
              <div class="row" id="folderSchemaStructure1">
                <h1>Folder/Schema Structure - 1</h1>
                <p>
                  Bu ksımda index.js içindeki kodun daha düzenli ve okunaklı görünmesi için bazı kısımları başka dosyalara yükleyip import ettik. index.js ve data.js src klasörüne taşındı. <br>
                  Son durumda: <br>
                  index.js:
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import * as fs from "fs";
  import * as path from "path";
  import { fileURLToPath } from "url";
  
  import db from "./data.js"; // veriler import edildi
  import resolvers from "./graphql/resolvers/index.js"; // resolvers import edildi
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    // Şemayı sarmala
    schema: createSchema({
      typeDefs: fs.readFileSync( // datanın olduğu dosyanın okunması
        path.join(
          path.dirname(fileURLToPath(import.meta.url)), // data yolunun ifade edilmesi
          "graphql/schema.graphql"
        ),
        "utf-8"
      ),
      resolvers,
    }),
    context: {
      pubSub,
      db, // database context içinde geçildi.
    },
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
                <p>
                  typeDefs için graphql/schema.qraphql dosyası oluşturuldu.
                  <pre class="prettyprint ms-0">
  # User
  type User {
    id: ID!
    fullName: String!
    age: Int!
    posts: [Post]
    comments: [Comment]
  }
  
  input CreateUserInput {
    fullName: String!
    age: Int!
  }
  
  input UpdateUserInput {
    fullName: String
    age: Int
  }
  
  # Post
  type Post {
    id: ID!
    title: String!
    user_id: ID!
    comments: [Comment!]
    user: User!
  }
  input CreatePostInput {
    title: String!
    user_id: ID!
  }
  input UpdatePostInput {
    title: String
    user_id: ID
  }
  
  # Comment
  type Comment {
    id: ID!
    text: String!
    post_id: ID!
    post: Post!
    user: User!
  }
  input CreateCommetInput {
    text: String!
    post_id: ID!
    user_id: ID!
  }
  input UpdateCommentInput {
    text: String
    post_id: ID
    user_id: ID
  }
  
  type DeleteAllOutput {
    count: Int!
  }
  
  type Query {
    users: [User!]!
    user(id: ID!): User!
  
    posts: [Post!]
    post(id: ID!): Post!
  
    comments: [Comment]
    comment(id: ID!): Comment!
  }
  
  type Mutation {
    # User
    createUser(data: CreateUserInput!): User!
    updateUser(id: ID!, data: UpdateUserInput!): User!
    deleteUser(id: ID!): User!
    deleteAllUsers: DeleteAllOutput!
    # Post
    createPost(data: CreatePostInput!): Post!
    updatePost(id: ID!, data: UpdatePostInput!): Post!
    deletePost(id: ID!): Post!
    deleteAllPosts: DeleteAllOutput!
  
    # Comment
    createComment(data: CreateCommetInput!): Comment!
    updateComment(id: ID!, data: UpdateCommentInput!): Comment!
    deleteComment(id: ID!): Comment!
    deleteAllComments: DeleteAllOutput!
  }
  
  type Subscription {
    # count: Int! # Örnek için
  
    # User
    userCreated: User!
    userUpdated: User!
    userDeleted: User!
  
    # Post
    postCreated(user_id: ID): Post! #postCreated parametre alacak şekilde düzenlendi.
    postUpdated: Post!
    postDeleted: Post!
    postsCount: Int!
  
    # Comment
    commentCreated(post_id: ID): Comment!
    commentUpdated: Comment!
    commentDeleted: Comment!
  }
  
                  </pre>
                </p>
                <p>
                  data.js db adıyla import edildi ve pubSub ile birlikte context içinde geçildi. Bu sayede her resolver için ulaşılabilir kılındı.
                </p>
                <p>
                  src/graphql/resolvers dosyasında tüm resolver işlemleri ayrı ayrı tanımlandı. Tanımlarda data.js den gelen veri context.db üzerinden alındı. pubSub işlemleri contex.pubSub a göre düzenlendi. resolvers/index.js içine import edilip oradan topluca export edildi. <br>
                  örnek resolvers için: <br>
                  src/graphql/resolvers/Mutation.js
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  const Mutation = {
    // User
    createUser: (_, args, { pubSub, db }) => {
      const user = {
        id: nanoid(),
        fullName: args.data.fullName,
        age: args.data.age,
      };
  
      db.users.push(user);
      pubSub.publish("userCreated", { userCreated: user });
  
      return user;
    },
    updateUser: (_, { id, data }, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const update_user = (db.users[user_index] = {
        ...db.users[user_index],
        ...data,
      });
      pubSub.publish("userUpdated", { userUpdated: update_user });
      return update_user;
    },
    deleteUser: (_, __, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const deleted_user = db.users[user_index];
  
      db.users.splice(user_index, 1);
  
      pubSub.publish("userDeleted", { userDeleted: deleted_user });
      return deleted_user;
    },
    deleteAllUsers: (_, __, { db }) => {
      const length = db.users.length;
  
      db.users.splice(0, length);
  
      return {
        count: length,
      };
    },
    // Post
    createPost: (_, { data: { title, user_id } }, { pubSub, db }) => {
      const post = {
        id: nanoid(),
        title,
        user_id,
      };
  
      db.posts.push(post);
  
      pubSub.publish("postCreated", { postCreated: post });
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return post;
    },
    updatePost: (_, { id, data }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
  
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const updated_post = (db.posts[post_index] = {
        ...db.posts[post_index],
        ...data,
      });
  
      pubSub.publish("postUpdated", { postUpdated: updated_post });
      return updated_post;
    },
    deletePost: (_, { id }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const deleted_post = db.posts[post_index];
  
      db.posts.splice(post_index, 1);
      pubSub.publish("postDeleted", { postDeleted: deleted_post });
      pubSub.publish("postsCount", { postsCount: posts.length });
  
      return deleted_post;
    },
    deleteAllPosts: (_, __, { pubSub, db }) => {
      const length = db.posts.length;
  
      db.posts.splice(0, length);
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return {
        count: length,
      };
    },
  
    // Comment
    createComment: (_, { data }, { pubSub, db }) => {
      const comment = {
        id: nanoid(),
        ...data,
      };
  
      db.comments.push(comment);
  
      pubSub.publish("commentCreated", { commentCreated: comment });
      return comment;
    },
    updateComment: (_, { id, data }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
  
      if (comment_index === -1) {
        throw new Error("Comment not found.");
      }
  
      const updated_comment = (db.comments[comment_index] = {
        ...db.comments[comment_index],
        ...data,
      });
      pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
      return updated_comment;
    },
    deleteComment: (_, { id }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
      if (comment_index === -1) {
        throw new Error("Comment not found");
      }
  
      const deleted_comment = db.comments[comment_index];
  
      db.comments.splice(comment_index, 1);
  
      pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
      return deleted_comment;
    },
    deleteAllComments: (_, __, { db }) => {
      const length = db.comments.length;
      db.comments.splice(0, length);
      return {
        count: length,
      };
    },
  };
  
  export default Mutation;
  
                  </pre>
                  index.js:
                  <pre class="prettyprint ms-0">
  import Comment from "./Comment.js"
  import Mutation from "./Mutation.js"
  import Post from "./Post.js"
  import Query from "./Query.js"
  import Subscription from "./Subscription.js"
  import User from "./User.js"
  
  export default {
      Mutation,
      Comment,
      Post,
      Query,
      Subscription,
      User
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="folderSchemaStructure2">
                <h1>Folder/Schema Structure - 2 (File Loader)</h1>
                <p>
                  Bu kısımda tip tanımlarımızı otomatik merge edeceğiz. <a href="https://the-guild.dev/graphql/tools/docs/schema-merging">doc</a>
                </p>
                <p>
                  resolver için de dökümanda merge uygulaması var ancak es6 için uygulanamıyor. Babeli kurduktan sonraki kısımda resolver merge işlemini tekrar yaptık 😄
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm i @graphql-tools/load-files @graphql-tools/merge</pre> yazıp gereken paketleri yüklüyoruz.
                </p>
                <p>
                  dökümantasyondaki <code>__dir</code> ifadesi ES6 da çalışmıyor. <code>path.join(__dirname)</code> yerine <code>path.dirname(fileURLToPath(import.meta.url))</code> ifadesini kullanıyoruz. Bunun çalışması için ise 
                  <pre class="prettyprint ms-0">
  import * as path from "path";
  import { fileURLToPath } from "url";
                  </pre> 
                  import işlemlerinin yapılması gerekiyor.
                </p>
                <p>
                  tip tanımlarını src/graphql/type-defs klasörünün içine yerleştirdik ve her bir veri tipi için ilgili tip tanımını kendine ait bir dosyaya taşıdık.
                  <ul>
                    <li>User.graphql</li>
                    <li>Post.graphql</li>
                    <li>Comment.graphql</li>
                    <li>global.graphql</li>
                  </ul>
                </p>
                <p>
                  Örnek olarak User.graphql
                  <pre class="prettyprint ms-0">
  type Query {
    users: [User!]!
    user(id: ID!): User!
  }
  
  type Mutation {
    createUser(data: CreateUserInput!): User!
    updateUser(id: ID!, data: UpdateUserInput!): User!
    deleteUser(id: ID!): User!
    deleteAllUsers: DeleteAllOutput!
  }
  
  type Subscription {
    userCreated: User!
    userUpdated: User!
    userDeleted: User!
  }
  
  type User {
    id: ID!
    fullName: String!
    age: Int!
    posts: [Post]
    comments: [Comment]
  }
  
  input CreateUserInput {
    fullName: String!
    age: Int!
  }
  
  input UpdateUserInput {
    fullName: String
    age: Int
  }
                  </pre>
                </p>
                <p>
                  Bu tanımları birleştirmesi (merge) içib src/type-defs/index.js içine:
                  <pre class="prettyprint ms-0">
  import * as path from "path";
  import { fileURLToPath } from "url";
  import { loadFilesSync } from '@graphql-tools/load-files'
  import { mergeTypeDefs } from '@graphql-tools/merge'
   
  const typesArray = loadFilesSync(path.dirname(fileURLToPath(import.meta.url)), { extensions: ['graphql'] })
   
  export default mergeTypeDefs(typesArray)
                  </pre>
                </p>
                <p>
                  src index.js içinde import edilir ve kullanılır.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./data.js";
  import resolvers from "./graphql/resolvers/index.js";
  import typeDefs from "./graphql/type-defs/index.js";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db,
    },
  });
  
  const server = createServer(yoga); // server kur
  
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="babelComplier">
                <h1>Babel Compiler </h1>
                <p>
                  Build işlemini gerçekleştireceğiz. Bunun için <a href="https://babeljs.io/">babel</a> kullanacağız.
                </p>
                <p>
                  <strong>Babel nedir?</strong> Babel, ECMAScript 2015+ kodunu mevcut ve eski tarayıcılarda veya ortamlarda geriye dönük olarak uyumlu bir JavaScript sürümüne dönüştürmek için kullanılan bir araçtır.
                </p>
                <p>
                  Babel sayesinde daha önce ES6 da çalışmayan söz dizimleri ile ES6 bir arada yazılabilir. 
                </p>
                <p>
                  <a href="https://babeljs.io/">Babeljs.io</a> içinde setup>nodemon
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm install @babel/core @babel/node --save-dev</pre> ve <pre class="prettyprint ms-0">npm install @babel/preset-env --save-dev</pre> ve build için:<pre class="prettyprint ms-0">npm install --save-dev @babel/cli</pre> 
                </p>
                <p>
                  package.json dosyasında scripts>dev alanı aşağıdaki gibi güncellendi ve "type": "module" ifadesi kaldırıldı.
                  <pre class="prettyprint ms-0">
  "scripts": {
      ...
      "dev": "nodemon --exec babel-node ./src/index.js",
      ...
    },
                  </pre>
                </p>
                <p>
                  kök dizine .babelrc adında bir dosya oluşturuldu ve içine:
                  <pre class="prettyprint ms-0">
  {
      "presets": ["@babel/preset-env"]
  }
                  </pre> eklendi.
                </p>
                <p>
                  son nanoid versiyonu ES6 dışında çalışmıyor. Bu nedenle önceki bir sürüm yoklendi.
                  <pre class="prettyprint ms-0">
  npm uninstall nanoid
  npm install nanoid@3.3.4
                  </pre>
                </p>
                <p>
                  ES6 dışında çalışmayan kodlardan kurtulmak için graphql/type-defs/index.js düzenlendi.
                  <pre class="prettyprint ms-0">
  import * as path from "path";
  import { loadFilesSync } from '@graphql-tools/load-files'
  import { mergeTypeDefs } from '@graphql-tools/merge'
   
  // const typesArray = loadFilesSync(path.dirname(fileURLToPath(import.meta.url)), { extensions: ['graphql'] })
  const typesArray = loadFilesSync(path.join(__dirname), { extensions: ['graphql'] }) // dir ifadesi babel sayesinde çalışıyor.
  
  export default mergeTypeDefs(typesArray)
                  </pre>
                </p>
                <p>
                  package.json script alanı düzenlendi. package.json son hali:
                  <pre class="prettyprint ms-0">
  {
    "name": "comment-challenge",
    "version": "1.0.0",
    "description": "",
    "main": "index.js",
    "scripts": {
      "start": "node ./dist/index.js",
      "dev": "nodemon --exec babel-node ./src/index.js",
      "build": "babel ./src --out-dir dist --minified --copy-files"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "dependencies": {
      "@apollo/server": "^4.7.1",
      "@graphql-tools/load-files": "^7.0.0",
      "@graphql-tools/merge": "^9.0.0",
      "@graphql-yoga/node": "^3.9.1",
      "@graphql-yoga/redis-event-target": "2.0.0",
      "graphql": "^16.6.0",
      "graphql-redis-subscriptions": "^2.6.0",
      "graphql-subscriptions": "^2.0.0",
      "graphql-ws": "^5.13.1",
      "graphql-yoga": "^3.9.2-rc-20230524133912-835c7e3d",
      "ioredis": "5.3.2",
      "nanoid": "^3.3.4",
      "redis": "^4.6.7"
    },
    "devDependencies": {
      "@babel/cli": "^7.22.5",
      "@babel/core": "^7.22.5",
      "@babel/node": "^7.22.5",
      "@babel/preset-env": "^7.22.5",
      "babel-plugin-module-resolver": "^5.0.0",
      "nodemon": "^2.0.22"
    }
  }
                  </pre>
                </p>
                <p>
                  <code>"build": "babel ./src --out-dir dist --minified --copy-files"</code> kodunda <code>--minified</code> build edilen tüm dosyalarda kodu tek satıra toplar. <code>--copy-files</code> ise o olmadan kopyalanmayan nonjs dosyaları da build içine kopyalar
                </p>
                <p>
                  build işlemi ile developer tarafındaki ürün product tarafına hazır hale getirilir. Bu işlem için terminale <pre class="prettyprint ms-0">npm run build</pre> yazılır. disc adında bir klasöre build oluşturulur.
                </p>
  
                <h2>babel-plugin-module-resolver</h2>
                <p>
                  import sırasında dosya dizini bulmayı kolaylaştırmak için dosya yollarına takma ad vermek  için <a href="https://www.npmjs.com/package/babel-plugin-module-resolver">babel-plugin-module-resolver</a> kullanılabilir. bunun için terminale <pre class="prettyprint ms-0">npm install --save-dev babel-plugin-module-resolver</pre>
                </p>
                <p>
                  .babelrc içine kısayollar tanımlanır. .babelrc son hali:
                  <pre class="prettyprint ms-0">
  {
      "presets": ["@babel/preset-env"],
      "plugins": [
          ["module-resolver", {
          "root": ["./src"],
          "alias": {
              "@graphql": "./src/graphql",
              "@resolvers": "./src/graphql/resolvers",
              "@type-defs": "./src/graphql/type-defs"
          }
          }]
      ]
  }
                  </pre>
                </p>
                <p>
                  Buna göre src/index.js:
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./data.js";
  import resolvers from "@resolvers"; //
  import typeDefs from "@type-defs"; //
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db,
    },
  });
  
  const server = createServer(yoga); 
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
                  </pre>
                </p>
  
                <h2>Babel Sonrası Resolver Merge</h2>
                <p>graphql/resolvers altına bir resolvers klasörü daha açılır ve index.js harici dosyalaor oraya taşınır.</p>
                <p>
                  graphql/resolvers/index.js aşağıdaki gibi düzenlenir.
                  <pre class="prettyprint ms-0">
  import path from "path";
  import { mergeResolvers } from "@graphql-tools/merge";
  import { loadFilesSync } from "@graphql-tools/load-files";
  
  const resolversArray = loadFilesSync(path.join(__dirname, "/resolvers"), {
    extensions: ["js"],
    extractExports: (fileExport) => { // bu kod index.js ile aynı dizinde resolverler olması durumunda index.js dosyasını merge dışında tutmak için yazıldı ama çalışmıyor. Bu nedenle resolverlar başka bir klasöre taşındı.
      if (typeof fileExport === "function") {
        return fileExport("query_root");
      }
      return fileExport;
    },
  });
  
  export default mergeResolvers(resolversArray);
  
                  </pre>
                </p>
                <p>
                  merge işleminin düzgün yapılabilmesi için <code>export default ...</code> ifadesi yerine <code>export const ...</code> kalıbı kullanılır. örnek: src/graphql/resolvers/resolvers/Mutation.js
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  export const Mutation = {
    // User
    createUser: (_, args, { pubSub, db }) => {
      const user = {
        id: nanoid(),
        fullName: args.data.fullName,
        age: args.data.age,
      };
  
      db.users.push(user);
      pubSub.publish("userCreated", { userCreated: user });
  
      return user;
    },
    updateUser: (_, { id, data }, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const update_user = (db.users[user_index] = {
        ...db.users[user_index],
        ...data,
      });
      pubSub.publish("userUpdated", { userUpdated: update_user });
      return update_user;
    },
    deleteUser: (_, __, { pubSub, db }) => {
      const user_index = db.users.findIndex((user) => user.id === id);
      if (user_index === -1) {
        throw new Error("User not found.");
      }
  
      const deleted_user = db.users[user_index];
  
      db.users.splice(user_index, 1);
  
      pubSub.publish("userDeleted", { userDeleted: deleted_user });
      return deleted_user;
    },
    deleteAllUsers: (_, __, { db }) => {
      const length = db.users.length;
  
      db.users.splice(0, length);
  
      return {
        count: length,
      };
    },
    // Post
    createPost: (_, { data: { title, user_id } }, { pubSub, db }) => {
      const post = {
        id: nanoid(),
        title,
        user_id,
      };
  
      db.posts.push(post);
  
      pubSub.publish("postCreated", { postCreated: post });
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return post;
    },
    updatePost: (_, { id, data }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
  
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const updated_post = (db.posts[post_index] = {
        ...db.posts[post_index],
        ...data,
      });
  
      pubSub.publish("postUpdated", { postUpdated: updated_post });
      return updated_post;
    },
    deletePost: (_, { id }, { pubSub, db }) => {
      const post_index = db.posts.findIndex((post) => post.id === id);
      if (post_index === -1) {
        throw new Error("Post not found.");
      }
  
      const deleted_post = db.posts[post_index];
  
      db.posts.splice(post_index, 1);
      pubSub.publish("postDeleted", { postDeleted: deleted_post });
      pubSub.publish("postsCount", { postsCount: posts.length });
  
      return deleted_post;
    },
    deleteAllPosts: (_, __, { pubSub, db }) => {
      const length = db.posts.length;
  
      db.posts.splice(0, length);
      pubSub.publish("postsCount", { postsCount: db.posts.length });
      return {
        count: length,
      };
    },
  
    // Comment
    createComment: (_, { data }, { pubSub, db }) => {
      const comment = {
        id: nanoid(),
        ...data,
      };
  
      db.comments.push(comment);
  
      pubSub.publish("commentCreated", { commentCreated: comment });
      return comment;
    },
    updateComment: (_, { id, data }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
  
      if (comment_index === -1) {
        throw new Error("Comment not found.");
      }
  
      const updated_comment = (db.comments[comment_index] = {
        ...db.comments[comment_index],
        ...data,
      });
      pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
      return updated_comment;
    },
    deleteComment: (_, { id }, { pubSub, db }) => {
      const comment_index = db.comments.findIndex((comment) => comment.id === id);
      if (comment_index === -1) {
        throw new Error("Comment not found");
      }
  
      const deleted_comment = db.comments[comment_index];
  
      db.comments.splice(comment_index, 1);
  
      pubSub.publish("commentDeleted", { commentDeleted: deleted_comment });
      return deleted_comment;
    },
    deleteAllComments: (_, __, { db }) => {
      const length = db.comments.length;
      db.comments.splice(0, length);
      return {
        count: length,
      };
    },
  };
  
  
                  </pre> 
                </p>
              </div>
            </div>
            <div class="row" id="apolloClientQueries">
              <div class="row" id="setupApolloClient">
                <h1>Apollo Client Kurulumu</h1>
                <p>
                  Daha önceki tüm yapımızı kök dizindeki server dosyasına taşıdık.
                </p>
                <p>
                  Kök dizinde client dosyası içine react kuruludu. Terminale <pre class="prettyprint ms-0">npx create-react-app .</pre>
                </p>
                <p>
                  Apollo Client, GraphQL ile uzak ve yerel verilerin yönetimini basitleştiren bir durum yönetimi kütüphanesidir. Özelliklerini zamanla öğreneceğiz.
                </p>
                <p>
                  client içine apollo client kuruldu. terminale <pre class="prettyprint ms-0">npm install @apollo/client graphql</pre>
                </p>
                <p>
                  apollo client'in client içine importu için <a href="https://www.apollographql.com/docs/react/get-started">bu döküman</a> uygulandı.
                </p>
                <p>
                  client/src/index.js
                  <pre class="prettyprint ms-0">
  import React from "react";
  import ReactDOM from "react-dom/client";
  import "./index.css";
  import App from "./App";
  import {
    ApolloProvider
  } from "@apollo/client";
  import client from "./apollo";
  
  
  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(
    &lt;ApolloProvider client={client}>
      &lt;App />
    &lt;/ApolloProvider>,
  );
  
                  </pre>
                </p>
                <p>
                  client/src/apollo.js
                  <pre class="prettyprint ms-0">
  import { ApolloClient, InMemoryCache } from "@apollo/client";
  
  const client = new ApolloClient({
    uri: "http://localhost:4000/graphql", // server tarafının verdiği endpoint
    cache: new InMemoryCache(),
  });
  
  export default client
                  </pre>
                </p>
                <p>
                  chore için <a href="https://chrome.google.com/webstore/detail/apollo-client-devtools/jdkknkkbebbapilgoeccciglkfbmbnfm">apollo client devtools</a> eklentisi.
                </p>
              </div>
              <div class="row" id="ApolloClientVisual">
                <h1>Genel Görünümün Ayarlanması</h1>
                <p>
                  Kullanıcı tarafının görüntüsünün ayarlanmasına başlandı.
                </p>
                <p>
                  Bunun için <a href="https://ant.design/">ant design</a> kullanacağız.
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">npm install antd</pre>
                </p>
                <p>
                  client/src/App.js dosyası client/src/components/App/index.js olarak göüncellendi. İçine:
                  <pre class="prettyprint ms-0">
  import { Col, Row } from "antd";
  import styles from "./styles.module.css"; // stil tanımları
  
  import { Avatar, List, Skeleton } from "antd";
  
  const data = [ // placeholder data
    {
      gender: "female",
      name: {
        title: "Miss",
        first: "Tanise",
        last: "Monteiro",
      },
      email: "tanise.monteiro@example.com",
      picture: {
        large: "https://randomuser.me/api/portraits/women/82.jpg",
        medium: "https://randomuser.me/api/portraits/med/women/82.jpg",
        thumbnail: "https://randomuser.me/api/portraits/thumb/women/82.jpg",
      },
      nat: "BR",
    },
  ];
  
  function App() {
    return (
      &lt;div className={styles.container}>
        &lt;Row justify="center">
          &lt;Col span={14} className={styles.content}>
            &lt;List
              className="demo-loadmore-list"
              loading={false}
              itemLayout="horizontal"
              // loadMore={loadMore}
              dataSource={data}
              renderItem={(item) => (
                &lt;List.Item>
                  &lt;Skeleton avatar title={false} loading={item.loading} active>
                    &lt;List.Item.Meta
                      avatar={&lt;Avatar src={item.picture.large} />}
                      title={&lt;a href="https://ant.design">{item.name?.last}&lt;/a>}
                      description="Ant Design, a design language for background applications, is refined by Ant UED Team"
                    />
                  &lt;/Skeleton>
                &lt;/List.Item>
              )}
            />
          &lt;/Col>
        &lt;/Row>
      &lt;/div>
    );
  }
  
  export default App;
  
                  </pre>
                </p>
                <p>
                  Stil tanımları için client/src/components/App/styles.module.css içi aşağıdaki gibi düzenlenir.
                  <pre class="prettyprint ms-0">
  .container{
      height: 100vh;
  }
  
  .content{
      background-color: #fff;
      padding: 24px;
      margin: 24px;
      border: solid 4px bisque;
  }
                  </pre>
                </p>
                <p>
                  App.js lokasyonundaki değişiklik src/index.js içindeki import satırında güncellenir.
                  <pre class="prettyprint ms-0">
  ...
  import App from "./components/App";
  ...
                  </pre>
                </p>
                <p>
                  src/index.css
                  <pre class="prettyprint ms-0">
  body {
    background-color: #282c34;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="reactRouter">
                <h1>React Router</h1>
                <p>
                  terminale <pre class="prettyprint ms-0">npm i react-router-dom</pre>
                </p>
                <p>
                  hoca v5 üzerinden anlatıyor. Biz v6 kullanıyoruz. React notlarımda detay mevcut.
                </p>
                <p>
                  Router sarmalama işlemi App.js üzerinde yapılabilir. Hoca index.js üzerinden yapmayı tercih etti. 
                  <pre class="prettyprint ms-0">
  import React from "react";
  import ReactDOM from "react-dom/client";
  import "./index.css";
  import App from "./components/App";
  import { BrowserRouter as Router } from "react-router-dom";
  
  import { ApolloProvider } from "@apollo/client";
  import client from "./apollo";
  
  const root = ReactDOM.createRoot(document.getElementById("root"));
  root.render(
    &lt;ApolloProvider client={client}>
      &lt;Router> 
        {/* Router sarmalaması App.js yerine burada yapıldı.*/}
        &lt;App />
      &lt;/Router>
    &lt;/ApolloProvider>
  );
  
                  </pre>
                </p>
                <p>
                  Sayfa yapısını düzenlemek için src/pages altına Home/index.js ve NewPost/index.js oluşturuldu. NewPost/index.js placeholder olarak bırakıldı. Home/index.js içine App/index.js içindeki List yapısı taşındı.
                  <pre class="prettyprint ms-0">
  import React from "react";
  
  import { Avatar, List, Skeleton } from "antd";
  
  const data = [
    // placeholder data
    {
      gender: "female",
      name: {
        title: "Miss",
        first: "Tanise",
        last: "Monteiro",
      },
      email: "tanise.monteiro@example.com",
      picture: {
        large: "https://randomuser.me/api/portraits/women/82.jpg",
        medium: "https://randomuser.me/api/portraits/med/women/82.jpg",
        thumbnail: "https://randomuser.me/api/portraits/thumb/women/82.jpg",
      },
      nat: "BR",
    },
  ];
  
  function Home() {
    return (
      &lt;div>
        &lt;List
          className="demo-loadmore-list"
          loading={false}
          itemLayout="horizontal"
          // loadMore={loadMore}
          dataSource={data}
          renderItem={(item) => (
            &lt;List.Item>
              &lt;Skeleton avatar title={false} loading={item.loading} active>
                &lt;List.Item.Meta
                  avatar={&lt;Avatar src={item.picture.large} />}
                  title={&lt;a href="https://ant.design">{item.name?.last}&lt;/a>}
                  description="Ant Design, a design language for background applications, is refined by Ant UED Team"
                />
              &lt;/Skeleton>
            &lt;/List.Item>
          )}
        />
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
                <p>
                  src/components/App/index.js dosyasıda router yapısı kuruldu.
                  <pre class="prettyprint ms-0">
  import { Col, Row } from "antd";
  import { Routes, Route } from "react-router-dom";
  import styles from "./styles.module.css";
  import HeaderMenu from "./HeaderMenu";
  
  // pages
  import Home from "pages/Home"; // react absolute path ile kök dizin src olarak ayarlandı.
  import NewPost from "pages/NewPost";
  
  function App() {
    return (
      &lt;div className={styles.container}>
        &lt;Row justify="center">
          &lt;Col span={14}>
            &lt;HeaderMenu />
            &lt;div className={styles.content}>
              &lt;Routes>
                &lt;Route path="/new" element={&lt;NewPost />} />
                &lt;Route path="/" element={&lt;Home />} />
              &lt;/Routes>
            &lt;/div>
          &lt;/Col>
        &lt;/Row>
      &lt;/div>
    );
  }
  
  export default App;
  
                  </pre>
                </p>
                <p>
                  kök dizini src yapmak için react absolute path yapısı kurgulandı. Bunun için client/jsconfig.json dosyası oluşturuldu. içine 
                  <pre class="prettyprint ms-0">
  {
      "compilerOptions": {
        "baseUrl": "src"
      }
  }
                  </pre>
                </p>
                <p>
                  App/index.js içinde kullanılan HeaderMenu App/HeaderMenu.js içinde oluşturuldu.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Menu } from "antd";
  import styles from "./styles.module.css";
  import { Link, useLocation } from "react-router-dom";
  
  const items = [
    {
      label: (
        &lt;Link to="/" className={styles.menuItem}>
          Home
        &lt;/Link>
      ),
      key: "/",
    },
    {
      label: (
        &lt;Link to="/new" className={styles.menuItem}>
          New
        &lt;/Link>
      ),
      key: "/new",
    },
  ];
  
  function HeaderMenu() {
    const location = useLocation(); // açık olan sayfanın bilgisini verir.
    return (
      &lt;Menu
        mode="horizontal"
        items={items}
        className={styles.headerMenu}
        selectedKeys={location.pathname}
      />
    );
  }
  
  export default HeaderMenu;
  
                  </pre>
                </p>
                <p>
                  stil tanımları için componenets/App/styles.module.css içinde:
                  <pre class="prettyprint ms-0">
  .container{
      height: 100vh;
  }
  
  .content{
      background-color: #fff;
      padding: 24px;
      /* margin: 24px; */
      border: solid 4px bisque;
  }
  
  .headerMenu{
      background: none;
      border: none;
  }
  
  .menuItem{
      font-weight: bold;
      font-size: 16px;
  }
                  </pre>
                  src/index.css içinde
                  <pre class="prettyprint ms-0">
  body {
    background-color: #282c34;
  }
  
  .ant-menu-item:hover::after{
    border-bottom-color: bisque !important
  }
  
  .ant-menu-item-selected::after{
    border-bottom-color: bisque !important
  }
  
  .ant-menu-item-selected .ant-menu-title-content a {
    color: bisque !important
  }
  
  .ant-menu-item:hover::after .ant-menu-title-content {
    color: #f8f8f8
  }
  
  .ant-menu-horizontal > .ant-menu-item a:hover {
    color: bisque;
  }
  
  .ant-menu-horizontal > .ant-menu-item a {
    color: #f8f8f8;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="postlarinListelenmesi">
                <h1>Postların Listelenmesi (useQuery)</h1>
                <p>
                  Client tarafında daha iyi bir görsel yakalamak için server tarafında post datasının ve type-def tanımının içine <q>description</q>, user fatasının ve type-def tanımının içine <q>pfofile_photo</q> tanımları eklendi
                </p>
                <p>
                  pages/Home/queries.js dosyası oluşturuldu ve içinde sorgumuz tanımlandı.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_POSTS = gql`
    query getAllPosts {
      posts {
        id
        title
        description
        user {
          profile_photo
        }
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  pages/Home/index.js içinde useQuery ile sorgudan data alındı ve işlendi. useQuery data dışında loading ve error durumlarını da bize veriyor. 
                  <pre class="prettyprint ms-0">
  import React from "react";
  
  import { Avatar, List } from "antd";
  
  import { useQuery } from "@apollo/client";
  import Loading from "components/Loading";
  import { GET_POSTS } from "./queries";
  
  function Home() {
    const { loading, error, data } = useQuery(GET_POSTS);
  
    if (loading) {
      return &lt;Loading />;
    }
  
    if (error) {
      return &lt;div>Error: {error.message}&lt;/div>;
    }
  
    console.log(data);
  
    return (
      &lt;div>
        &lt;List
          className="demo-loadmore-list"
          loading={false}
          itemLayout="horizontal"
          // loadMore={loadMore}
          dataSource={data.posts}
          renderItem={(item) => (
            &lt;List.Item>
              &lt;List.Item.Meta
                avatar={&lt;Avatar src={item.user.profile_photo} />}
                title={&lt;a href="https://ant.design">{item.title}&lt;/a>}
                description={item.description}
              />
            &lt;/List.Item>
          )}
        />
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
                <p>
                  components/Loading/index.js içinde loading durumunda gösterilecek spinner tanımlandı.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { LoadingOutlined } from "@ant-design/icons";
  import { Spin } from "antd";
  
  import styles from "./styles.module.css"
  
  function Loading() {
    return (
      &lt;div className={styles.loading}>
        &lt;Spin indicator={&lt;LoadingOutlined style={{ fontSize: 32 }} spin />} />
      &lt;/div>
    );
  }
  
  export default Loading;
  
                  </pre>
                </p>
                <p>
                  component/Loading/styles.module.css içinde loading spinnerı için stil tanımı yapıldı.
                  <pre class="prettyprint ms-0">
  .loading{
      display: flex;
      align-items: center;
      justify-content: center;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="postDetail">
                <h1>Post Detaylarının Gösterilmesi</h1>
                <p>
                  server tarafında posts datasına ve type-defs kısmına <q>cover</q> tanımları eklendi.
                </p>
                <p>
                  App/index.js içinde Routes altında yeni route oluşturuldu.
                  <pre class="prettyprint ms-0">
  ... 
    &lt;Routes>
      &lt;Route path="/new" element={&lt;NewPost />} />
      &lt;Route path="/post/:id" element={&lt;Post />} />
      &lt;Route path="/" element={&lt;Home />} />
    &lt;/Routes>
  ...
                  </pre>
                </p>
                <p>
                  Home/index.js alanında Link kompanenti ile bağlantılar oluşturuldu.
                  <pre class="prettyprint ms-0">
  ...
  import { Link } from "react-router-dom";
  ...
  
  function Home() {
    ...
  
    return (
      &lt;div>
        &lt;List
          className="demo-loadmore-list"
          loading={false}
          itemLayout="horizontal"
          // loadMore={loadMore}
          dataSource={data.posts}
          renderItem={(item) => (
            &lt;List.Item>
              &lt;List.Item.Meta
                avatar={&lt;Avatar src={item.user.profile_photo} />}
                title={
                  &lt;Link to={`/post/${item.id}`} className={styles.listTitle}>
                    {item.title}
                  &lt;/Link>
                }
                description={
                  &lt;Link to={`/post/${item.id}`} className={styles.listItem}>
                    {item.description}
                  &lt;/Link>
                }
              />
            &lt;/List.Item>
          )}
        />
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
                <p>
                  Home/styles.module.css içinde linlker için stil tanımları yapıldı.
                  <pre class="prettyprint ms-0">
  .listItem{
      color: rgba(0, 0, 0, 0.45);
      font-size: 14px;
      line-height: 1,5715;
  }
  
  .listItem:hover{
      color: rgba(0, 0, 0, 0.6);
  }
  
  .listTitle{
      margin-bottom: 4px;
      color: rgba(0, 0, 0, 0.85);
      font-size: 14px;
      line-height: 1,5715;
  }
  
  .listTitle:hover{
      color: rgba(0, 0, 0, 0.9) !important;
  }
                  </pre>
                </p>
                <p>
                  pages/Post dosyası oluşturuldu. İçinde index.js ve queries.js dosyası oluşturuldu. <br>
                  queries.js içinde query tanımı eklendi.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_POST = gql`
    query post($id: ID!) {
    post(id: $id) {
      id
      title
      description
      cover
      user {
        id
        fullName
      }
    }
  }
  `;
                  </pre>
                  index.js içinde de query import edildi ve useQuery ile variables girilerek kullanıldı.
                  <pre class="prettyprint ms-0">
  import Loading from "components/Loading";
  import { useParams } from "react-router-dom";
  import { useQuery } from "@apollo/client";
  import { GET_POST } from "./queries";
  import { Typography, Image } from "antd";
  const { Title } = Typography;
  
  function Post() {
    const { id } = useParams();
  
    const { loading, error, data } = useQuery(GET_POST, {
      variables: {
        id,
      },
    });
  
    if (loading) {
      return &lt;Loading />;
    }
  
    if (error) {
      return &lt;div>Error: {error.message}&lt;/div>;
    }
  
    console.log(data);
  
    const { post } = data;
  
    return (
      &lt;div>
        &lt;Title level={3}>{post.title}&lt;/Title>
        &lt;Image
          src={post.cover}
        />
        &lt;div>{post.description}&lt;/div>
      &lt;/div>
    );
  }
  
  export default Post;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="shortDescField">
                <h1>Short Description Field'ının Tanımlanması</h1>
                <p>
                  post datası ve type-def tanımlarına <q>short_description</q> alanı oluşturuldu. Bu short_description client tarafında Home için query ile sorgulandı ve gelen veri daha önce description tanımı olan yerde kullanıldı.
                </p>
                <p>
                  Post detaylarının olduğu sayfada description alanı için stil tanımı yapıldı. Post/index.js
                  <pre class="prettyprint ms-0">
  import styles from "./styles.module.css";
  
  ...
  function Post() {
    ...
  
    return (
      ...
        &lt;div className={styles.description}>{post.description}&lt;/div>
      &lt;/div>
    );
  }
  
  export default Post;
                  </pre>
                  Post/styles.module.css
                  <pre class="prettyprint ms-0">
  .description{
      font-size: 1.1rem;
      margin: 10px;
      color: #666;
  }
                  </pre>
                </p>
                <p>
                  Genel görünümü güzelleştirmek için App/index.js için stil tanımı yapıldı.
                  <pre class="prettyprint ms-0">
  ...
  
  function App() {
    return (
      ...
        &lt;Row justify="center">
          &lt;Col span={14} className={styles.col}>
      ...
                  </pre>
                  App/styles.module.css
                  <pre class="prettyprint ms-0">
  ...
  .col{
    margin: 10px 0 30px 0
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="useLazyQuery">
                <h1>Post Yorumlarının Listelenmesi (useLazyQuery)</h1>
                <p>
                  Post sayfasında yorumların sayfadaki <q>show comments</q> butonuna basılınca gösteileceği bir durum kurguladık.
                </p>
                <p>
                  Hoca butonu tıklandıktan sonra kaybetmek için farklı bir yöntem kullandı. Ben daha farklı yaptım.
                </p>
                <p>
                  Post/queries.js içine ihtiyacımız olan bilgileri çekmek için sorgu yazıldı.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const GET_POST_COMMENTS = gql`
    query postComments($id: ID!) {
    post(id: $id) {
      comments {
        id
        text
        user {
          id
          fullName
          profile_photo
        }
      }
    }
  }
  `;
  
                  </pre>
                </p>
                <p>
                  Post/Comments.js dosyası oluşturuldu. İçinde sorgu için butonla tetiklenen useLazyQuery hooku kullanıldı.
                  <pre class="prettyprint ms-0">
  import Loading from "components/Loading";
  import { Divider, Button } from "antd";
  import styles from "./styles.module.css";
  import { useLazyQuery } from "@apollo/client";
  import { GET_POST_COMMENTS } from "./queries";
  import { Avatar, List } from "antd";
  
  function Comments({ post_id }) {
    const [
      loadComments, // sorguyu başlatacak olan fonksiyon
      {
        called, // sorgu başladı mı?
        loading, // yükleniyor mu?
        data, // gelen veri
      },
    ] = useLazyQuery(
      GET_POST_COMMENTS,
      { variables: { id: post_id } } // sorgu için gönderilen değişken
    );
  
    if (called && loading) return &lt;Loading />;
  
    return (
      &lt;>
        &lt;Divider>Comments&lt;/Divider>
        {!called && (
          &lt;div className={styles.showCommentsButton}>
            &lt;Button loading={loading} onClick={() => loadComments()}>
              Show Comments
            &lt;/Button>
          &lt;/div>
        )}
  
        {!loading && data && (
          &lt;div>
            &lt;List
              className="demo-loadmore-list"
              loading={false}
              itemLayout="horizontal"
              // loadMore={loadMore}
              dataSource={data.post.comments}
              renderItem={(item) => (
                &lt;List.Item>
                  &lt;List.Item.Meta
                    avatar={&lt;Avatar src={item.user.profile_photo} />}
                    title={item.user.fullName}
                    description={item.text}
                  />
                &lt;/List.Item>
              )}
            />
          &lt;/div>
        )}
      </>
    );
  }
  
  export default Comments;
  
                  </pre>
                </p>
                <p>
                  Comments.js içindeki butona styles.module.css içinde stil tanımı yapıldı.
                  <pre class="prettyprint ms-0">
  ...
  
  .showCommentsButton{
      text-align: center;
  }
                  </pre> 
                </p>
                <p>
                  Post/index.js içindeki kompanentin en altına Comments kompanenti yerleştirildi. Bu sırada props olarak gönderilen veri Comments kompanentinde karşılandı ve sorgu için kullanıldı.
                  <pre class="prettyprint ms-0">
  ...
  import Comments from "./Comments";
  ...
  
  function Post() {
    ...
  
    return (
      &lt;div>
        ...
        &lt;Comments post_id={id}/>
      &lt;/div>
    );
  }
  
  export default Post;
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="apolloClientSubscriptions">
              <div class="row" id="subscribeToMore">
                <h1>Postların Gerçek Zamanlı Listelenmesi (subscribeToMore)</h1>
                <p>
                  Hoca websoket için client/src/apollo.js içinde değişiklik yaptı.
                </p>
                <p>
                  Apollo client sürüm 3.7.11 ve sonrası için HTTP üzerinden çok parçalı abonelikleri destekler. Bu nedenle apollo.js içinde değişiklik yapmaya gerek kalmaz.
                </p>
                <p>
                  server tarafında resolvers kısmında createPost mutasyonuna verinin son haline uyumlu olması için modif yapıldı.
                </p>
                <p>
                  Home/queries.js alanına <q>POSTS_SUBSCRIPTION</q> sorgusu eklendi.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const POSTS_SUBSCRIPTION = gql`
    subscription MySubscription {
      postCreated {
        id
        title
        short_description
        user {
          profile_photo
        }
      }
    }
  `;
  
                  </pre>
                </p>
                <p>
                  Home/index.js içinde aşağıdaki güncellem ile subscription kullanıldı.
                  <pre class="prettyprint ms-0">
  import { useEffect } from "react";
  ...
  
  import { GET_POSTS, POSTS_SUBSCRIPTION } from "./queries";
  ...
  
  function Home() {
    const {
      loading,
      error,
      data,
      subscribeToMore, // dinlemek için gereken fonksiyon
    } = useQuery(GET_POSTS);
  
    useEffect(() => {
      // veri değiştiğinde reactta kullanılması için useEffect hooku kullanıldı.
      subscribeToMore({
        document: POSTS_SUBSCRIPTION, // dinlenilecek sorgu
        updateQuery: (
          prev, // mevcut durum
          { subscriptionData } // dinlenen kanaldan gelen
        ) => {
          if (!subscriptionData.data) return prev;
  
          return {
            posts: [subscriptionData.data.postCreated, ...prev.posts], // posts tanımı cache olarak tutulan veri keyinden alındı
          };
        },
      });
    }, [subscribeToMore]);
  
    if (loading) {
      return &lt;Loading />;
    }
  
    if (error) {
      return &lt;div>Error: {error.message}&lt;/div>;
    }
  
    return (
      &lt;div>
        ...
      &lt;/div>
    );
  }
  
  export default Home;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="useSubscription">
                <h1>Post Sayısını Gerçek Zamanlı Göstermek (useSubscription)</h1>
                <p>
                  components/App/HeaderMenu.js kompanenti components/HeaderMenu/index.js olarak taşındı. Gereken import ve style tanımları düzenlendi.
                </p>
                <p>
                  components/PostCounter/queries.js oluşturuldu ve içine subscription sorgusu eklendi.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const POST_COUNT_SUBSCRİPTİON = gql`
    subscription {
      postsCount
    }
  `;
                  </pre>
                </p>
                <p>
                  components/PostCounter/index.js oluşturuldu. queries.js içindeki sorgu import edildi ve <code>useSubscription()</code> hooku ile abone olundu.: 
                  <pre class="prettyprint ms-0">
  import styles from "./styles.module.css";
  import { Badge, Avatar } from "antd";
  import { useSubscription } from "@apollo/client";
  import { POST_COUNT_SUBSCRİPTİON } from "./queries";
  
  function PostCounter() {
    const {loading, data} = useSubscription(POST_COUNT_SUBSCRİPTİON);
    
    return (
      &lt;div className={styles.container}>
        &lt;Badge count={loading ? "?" : data.postsCount }>
          &lt;Avatar shape="square" size="medium">
              &lt;span className={styles.counterTitle}>Posts&lt;/span>
          &lt;/Avatar>
        &lt;/Badge>
      &lt;/div>
    );
  }
  
  export default PostCounter;
                  </pre>
                </p>
                <p>
                  App/index.js içinde daha önce HeaderMenu kompanentinin tek başına yer aldığı kısım Row/Col yapısyla bölündü ve içine PostCounter kompanenti eklendi.
                  <pre class="prettyprint ms-0">
  ...
  import PostCounter from "components/PostCounter";
  
  function App() {
    return (
      &lt;div className={styles.container}>
        &lt;Row justify="center">
          &lt;Col span={14} className={styles.col}>
            &lt;Row>
              &lt;Col span={18}>
                &lt;HeaderMenu />
              &lt;/Col>
              &lt;Col span={6}>
                &lt;PostCounter />
              &lt;/Col>
            &lt;/Row>
            ...
          &lt;/Col>
        &lt;/Row>
      &lt;/div>
    );
  }
  
  export default App;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="commentsRealTime">
                <h1>Yorumların Gerçek Zamanlı Gösterilmesi</h1>
                <p>
                  Post içinde comment post_id parametresi ile abonelik oluşturacak sorguyu Post/queries.js içine ekledik.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const COMMENTS_SUBSCRIPTIONS = gql`
    subscription ($postId: ID) {
      commentCreated(post_id: $postId) {
        id
        text
        user {
          id
          fullName
          profile_photo
        }
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  Post/Comments.js alanında tıklayınca sorgu başlatan <q>useLazyQuery</q> hooku içinden subscribeToMore fonksiyonunu çektik ve <q>useEffect</q> hooku ile kullandık. 
                  <pre class="prettyprint ms-0">
  import { useEffect } from "react";
  
  function Comments({ post_id }) {
  
    const [loadComments, { called, loading, data, subscribeToMore }] =
      useLazyQuery(GET_POST_COMMENTS, { variables: { id: post_id } });
  
    useEffect(() => {
      if (!loading && called) {
        subscribeToMore({
          document: COMMENTS_SUBSCRIPTIONS,
          updateQuery: (prev, { subscriptionData }) => {
            if (!subscriptionData.data) return prev;
  
            return {
              post: {
                ...prev.post,
                comments: [
                  ...prev.post.comments,
                  subscriptionData.data.commentCreated,
                ],
              },
            };
          },
        });
      }
    }, [loading, called, subscribeToMore]);
  
    if (called && loading) return &lt;Loading />;
  
    return (
      ...
    );
  }
  
  export default Comments;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="fragments">
                <h1>Fragments</h1>
                <p>
                  Birden fazla query içinde aynı tanımları çekmemiz gerekti. İleride birini güncellememiz gerektiğinde hepsini güncellememiz gerekecek. Bu gibi durumlarda aksaklık yaşanmaması ve işin kolaylaşması için sorgu parametreleri fragment yapılarına alınabilir.
                </p>
                <p>
                  Post/queries.js içinde sorguda aynı kullanılan parametreler fragment içinde toplandı.
                  <pre class="prettyprint ms-0">
  const commentFragment = gql`
    fragment CommentFragment on Comment {
      # commentsFragment içinde CommentsFragment adıyla aşağıdaki parametreleri saklar.
      id
      text
      user {
        id
        fullName
        profile_photo
      }
    }
  `;
                  </pre>
                  Toplanan parametreler ilgili sorgulara import edildi ve kullanıldı.
                  <pre class="prettyprint ms-0">
  export const GET_POST_COMMENTS = gql`
    query postComments($id: ID!) {
      post(id: $id) {
        comments {
          ...CommentFragment
          # Bu kısım değişkenleri yerleştirmek için
        }
      }
    }
    ${commentFragment}
    # bu kısım değişkeni import etmek için
  `;
  
  export const COMMENTS_SUBSCRIPTIONS = gql`
    subscription ($postId: ID) {
      commentCreated(post_id: $postId) {
        ...CommentFragment
      }
    }
    ${commentFragment}
  `;
  
                  </pre>
                </p>
                <p>
                  Aynı uygulamanın Home/queries.js versiyonu
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  const postFragments = gql`
    fragment PostFragmens on Post {
      id
      title
      short_description
      user {
        profile_photo
      }
    }
  `;
  
  export const GET_POSTS = gql`
    query getAllPosts {
      posts {
        ...PostFragmens
      }
    }
    ${postFragments}
  `;
  
  export const POSTS_SUBSCRIPTION = gql`
    subscription MySubscription {
      postCreated {
        ...PostFragmens
      }
    }
    ${postFragments}
  `;
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="apolloClientMutations">
              <div class="row" id="createNewPostForm">
                <h1>New Post Formunun Tasarlanması</h1>
                <p>
                  pages/NewPost/NewPostForm.js dosyası oluşturuldu. İçine:
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Button, Checkbox, Form, Input, Select } from "antd";
  
  const { Option } = Select;
  
  function NewPostForm() {
    return (
      &lt;Form
        name="basic"
        initialValues={{
          remember: true,
        }}
        // onFinish={onFinish}
        // onFinishFailed={onFinishFailed}
        autoComplete="off"
      >
        &lt;Form.Item
          // label="Username"
          name="username"
          rules={[
            {
              required: true,
              message: "Please input your username!",
            },
          ]}
        >
          &lt;Input size="large" placeholder="Title" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="shortDescription">
          &lt;Input size="large" placeholder="Short description" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="description">
          &lt;Input.TextArea size="large" placeholder="Description" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="cover">
          &lt;Input size="large" placeholder="Cover" />
        &lt;/Form.Item>
  
        &lt;Form.Item
          name="user"
          rules={[
            {
              required: true,
              message: "Please select user!",
            },
          ]}
        >
          &lt;Select size="large" placeholder="Select your user">
            &lt;Option value="male">Male&lt;/Option>
            &lt;Option value="female">Female&lt;/Option>
            &lt;Option value="other">Other&lt;/Option>
          &lt;/Select>
        &lt;/Form.Item>
  
        &lt;Form.Item>
          &lt;Button type="primary" htmlType="submit">
            Submit
          &lt;/Button>
        &lt;/Form.Item>
        
      &lt;/Form>
    );
  }
  
  export default NewPostForm;
  
                  </pre>
                </p>
                <p>
                  Oluşturlan kompanent pages/NewPost/index.js içine import edildi.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Typography } from "antd";
  import NewPostForm from "./NewPostForm";
  const { Title } = Typography;
  
  function NewPost() {
    return (
      &lt;div>
        &lt;Title level={3}>New Post&lt;/Title>
  
        &lt;NewPostForm />
      &lt;/div>
    );
  }
  
  export default NewPost;
                  </pre>
                </p>
                <p>
                  Formdaki satır arası boşlukları azaltmak için src/style.css içine
                  <pre class="prettyprint ms-0">
  .ant-form-item{
    margin-bottom: 12px;
  }
                  </pre>
                  eklendi
                </p>
              </div>
              <div class="row" id="newPostFormUsers">
                <h1>Kullanıcı Listesinin Çekilmesi</h1>
                <p>
                  pages\NewPost\queries.js içinde userlar için gereken query tanımlandı.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_USER = gql`
    query {
      users {
        fullName
        id
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  Tanımlanan query NewPost\NewPostForm.js içinde kullanıldı.
                  <pre class="prettyprint ms-0">
  ..
  import { useQuery } from "@apollo/client";
  import { GET_USER } from "./queries";
  import styles from "./styles.module.css"
  
  ..
  
  function NewPostForm() {
    const {
      loading: get_users_loading, // yeniden adlandırdık
      data: users_data,
    } = useQuery(GET_USER);
  
    return (
      ...
  
        &lt;Form.Item
          name="user"
          rules={[
            {
              required: true,
              message: "Please select user!",
            },
          ]}
        >
          &lt;Select
            disabled={get_users_loading}
            loading={get_users_loading}
            size="large"
            placeholder="Select your user"
          >
            {users_data &&
              users_data.users.map(item => (
                &lt;Option value={item.id} key={item.id}>
                  {item.fullName}
                &lt;/Option>
              ))}
          &lt;/Select>
        &lt;/Form.Item>
  
        &lt;Form.Item className={styles.buttons}>
          &lt;Button size="large" type="primary" htmlType="submit">
            Submit
          &lt;/Button>
        &lt;/Form.Item>
      &lt;/Form>
    );
  }
  
  export default NewPostForm;
  
                  </pre>
                </p>
                <p>
                  \NewPost\styles.module.css içinde butonlar için stil tanımı yapıldı.
                  <pre class="prettyprint ms-0">
  .buttons{
      text-align: right;
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="useMutation">
                <h1>Yeni Post Eklemek (useMutation)</h1>
                <p>
                  yani post için mutation tanımı pages\NewPost\queries.js dosyasına eklendi.
                  <pre class="prettyprint ms-0">
                    import { gql } from "@apollo/client";
  
                    ...
                    
                    export const NEW_POST_MUTATION = gql`
                      mutation ($data: CreatePostInput!) {
                        createPost(data: $data) {
                          id
                          title
                        }
                      }
                    `;
                  </pre>
                </p>
                <p>
                  Hazırlanan mutation NewPost\NewPostForm.js içine import edilip kullanıldı.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Button, Form, Input, Select, message } from "antd";
  import { useNavigate } from "react-router-dom";
  import { useQuery, useMutation } from "@apollo/client";
  import { GET_USER, NEW_POST_MUTATION } from "./queries";
  import styles from "./styles.module.css";
  
  const { Option } = Select;
  
  function NewPostForm() {
    const navigate = useNavigate()
  
    const [
      savePost, // bizim mutation fonksiyonuna verdiğimiz ad.
      { loading, error }, // işlem sonunda dönen data
    ] = useMutation(NEW_POST_MUTATION);
  
    const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);
  
    const handleSubmit = async (values) => {
      try {
        await savePost({
          variables: {
            data: values,
          },
        });
        message.success("Post saved", [4]);
        navigate("/")
  
      } catch (e) {
        message.error(`Post not saved!. Error: ${error.message}`, [10]);
      }
    };
  
    return (
      &lt;Form
        name="basic"
        initialValues={{
          remember: true,
        }}
        onFinish={handleSubmit}
        // onFinishFailed={onFinishFailed}
        autoComplete="off"
      >
        &lt;Form.Item
          name="title" // bu kısım value tanımında key olarak gönderilir. mutation içindeki key ile aynı olmak zorunda.
          rules={[
            {
              required: true,
              message: "Please input a title!",
            },
          ]}
        >
          &lt;Input disabled={loading} size="large" placeholder="Title" />
        &lt;/Form.Item>
  
        &lt;Form.Item name="short_description">
          &lt;Input
            disabled={loading}
            size="large"
            placeholder="Short description"
          />
        &lt;/Form.Item>
  
        &lt;Form.Item name="description">
          &lt;Input.TextArea
            disabled={loading}
            size="large"
            placeholder="Description"
          />
        &lt;/Form.Item>
  
        &lt;Form.Item name="cover">
          &lt;Input disabled={loading} size="large" placeholder="Cover" />
        &lt;/Form.Item>
  
        &lt;Form.Item
          name="user_id"
          rules={[
            {
              required: true,
              message: "Please select user!",
            },
          ]}
        >
          &lt;Select
            disabled={get_users_loading || loading}
            loading={get_users_loading}
            size="large"
            placeholder="Select your user"
          >
            {users_data &&
              users_data.users.map((item) => (
                &lt;Option value={item.id} key={item.id}>
                  {item.fullName}
                &lt;/Option>
              ))}
          &lt;/Select>
        &lt;/Form.Item>
  
        &lt;Form.Item className={styles.buttons}>
          &lt;Button loading={loading} size="large" type="primary" htmlType="submit">
            Submit
          &lt;/Button>
        &lt;/Form.Item>
      &lt;/Form>
    );
  }
  
  export default NewPostForm;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="createNewCommentForm">
                <h1>Yorum Formunun Hazırlanması</h1>
                <p>
                  Post altına Comment klasörü açıldı ve CommentList.js altına taşındı.
                </p>
                <p>
                  Yeni comment eklemek için kullanacağımız formda yer alması için user listesini almaya yarayacak query pages\Post\Comments\queries.js içinde tanımlandı.
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  export const GET_USER = gql`
    query {
      users {
        fullName
        id
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  Comments\NewCommentForm.js dosyası içinde form tanımlandı.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { Button, Col, Form, Input, Row, Select, message } from "antd";
  import { useQuery, useMutation } from "@apollo/client";
  import { GET_USER } from "./queries";
  import styles from "./styles.module.css";
  
  const { Option } = Select;
  
  function NewCommentForm() {
    const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);
    const handleSubmit = async (values) => {
      console.log(values);
    };
  
    return (
      &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off">
        &lt;Row gutter={24}>
          &lt;Col span={6}>
            &lt;Form.Item
              name="user_id"
              rules={[
                {
                  required: true,
                  message: "Please select user!",
                },
              ]}
            >
              &lt;Select
                disabled={get_users_loading}
                loading={get_users_loading}
                size="medium"
                placeholder="Select your user"
              >
                {users_data &&
                  users_data.users.map((item) => (
                    &lt;Option value={item.id} key={item.id}>
                      {item.fullName}
                    &lt;/Option>
                  ))}
              &lt;/Select>
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={14}>
            &lt;Form.Item
              name="text"
              rules={[
                {
                  required: true,
                  message: "Please enter a message!",
                },
              ]}
            >
              &lt;Input size="medium" placeholder="Message" />
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={4}>
            &lt;Form.Item className={styles.buttons}>
              &lt;Button size="medium" type="primary" htmlType="submit">
                Submit
              &lt;/Button>
            &lt;/Form.Item>
          &lt;/Col>
        &lt;/Row>
      &lt;/Form>
    );
  }
  
  export default NewCommentForm;
                  </pre>
                </p>
                Oluşturulan kompanent Comments\CommentsList.js içinde import edildi ve kullanıldı.
                <pre class="prettyprint ms-0">
  ...
  import NewCommentForm from "./NewCommentForm";
  
  function CommentsList({ post_id }) {
    ...
  
    return (
      &lt;>
        &lt;Divider>Comments&lt;/Divider>
        {!called && (
          &lt;div className={styles.showCommentsButton}>
            &lt;Button loading={loading} onClick={() => loadComments()}>
              Show Comments
            &lt;/Button>
          &lt;/div>
        )}
  
        {!loading && data && (
          &lt;>
            &lt;List
              className="demo-loadmore-list"
              loading={false}
              itemLayout="horizontal"
              // loadMore={loadMore}
              dataSource={data.post.comments}
              renderItem={(item) => (
                &lt;List.Item>
                  &lt;List.Item.Meta
                    avatar={&lt;Avatar src={item.user.profile_photo} />}
                    title={item.user.fullName}
                    description={item.text}
                  />
                &lt;/List.Item>
              )}
            />
            &lt;Divider>New Comment&lt;/Divider>
            &lt;NewCommentForm />
          &lt;/>
        )}
      &lt;/>
    );
  }
  
  export default CommentsList;
  
                </pre>
              </div>
              <div class="row" id="mutationNewComment">
                <h1>Yeni Yorum Mutation'unun Hazırlanması</h1>
                <p>
                  yeni comment eklemek için gereken mutation Post\Comments\queries.js içine eklendi. 
                  <pre class="prettyprint ms-0">
  import { gql } from "@apollo/client";
  
  ...
  
  export const CREATE_COMMENT_MUTATION = gql`
    mutation ($data: CreateCommetInput!) {
      createComment(data: $data) {
        id
      }
    }
  `;
                  </pre>
                </p>
                <p>
                  Mutation çalışması için kullanılacak post_id verisi prop olarak Post\Comments\CommentsList.js içinden gönderilir.
                  <pre class="prettyprint ms-0">
  ...
   &lt;NewCommentForm post_id={post_id} />
  ...
                  </pre>
                </p>
                <p>
                  formdaki veriler ve prop olarak gelen post_id kullanılarak mutation fonksiyona tanımlandı ve forma eklendi.
                  <pre class="prettyprint ms-0">
  import { useRef } from "react";
  import { Button, Col, Form, Input, Row, Select, message } from "antd";
  import { useQuery, useMutation } from "@apollo/client";
  import { GET_USER, CREATE_COMMENT_MUTATION } from "./queries";
  import styles from "./styles.module.css";
  
  const { Option } = Select;
  
  function NewCommentForm({ post_id }) {
    const [createComment, { loading }] = useMutation(
      CREATE_COMMENT_MUTATION
    );
    const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);
  
    const formRef = useRef(); // formu ilk haline getirmesi için.
  
    const handleSubmit = async (values) => {
      try {
        await createComment({
          variables: {
            data: { ...values, post_id },
          },
        });
        message.success("Comment saved", [4]);
  
        formRef.current.resetFields(); // formu resetleyen fonksiyon
      } catch (e) {
        message.error(`Comment not saved!.`, [10]);
        
      }
    };
  
    return (
      &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off" ref={formRef}> 
      {/* resetleme için ref içinde formRef verildi */}
        &lt;Row gutter={24}>
          &lt;Col span={6}>
            &lt;Form.Item
              name="user_id"
              rules={[
                {
                  required: true,
                  message: "Please select user!",
                },
              ]}
            >
              &lt;Select
                disabled={get_users_loading || loading}
                loading={get_users_loading}
                size="medium"
                placeholder="Select your user"
              >
                {users_data &&
                  users_data.users.map((item) => (
                    &lt;Option value={item.id} key={item.id}>
                      {item.fullName}
                    &lt;/Option>
                  ))}
              &lt;/Select>
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={14}>
            &lt;Form.Item
              name="text"
              rules={[
                {
                  required: true,
                  message: "Please enter a message!",
                },
              ]}
            >
              &lt;Input disabled={loading} size="medium" placeholder="Message" />
            &lt;/Form.Item>
          &lt;/Col>
          &lt;Col span={4}>
            &lt;Form.Item className={styles.buttons}>
              &lt;Button
                disabled={loading}
                size="medium"
                type="primary"
                htmlType="submit"
              >
                Add
              &lt;/Button>
            &lt;/Form.Item>
          &lt;/Col>
        &lt;/Row>
      &lt;/Form>
    );
  }
  
  export default NewCommentForm;
  
                  </pre>
                </p>
              </div>
              <div class="row" id="spinnerDelay">
                <h1>Spinner Delay</h1>
                <p>
                  300 ms den kısa sürelerde olan işlemlerde loading spinerının görünmesi kullanıcı deneyimi için olumsuz bir durumdur. Bu nedenle client\src\components\Loading\index.js içinde Spin etiketine delay (gecikme) eklendi.
                  <pre class="prettyprint ms-0">
  import React from "react";
  import { LoadingOutlined } from "@ant-design/icons";
  import { Spin } from "antd";
  
  import styles from "./styles.module.css"
  
  function Loading() {
    return (
      &lt;div className={styles.loading}>
        &lt;Spin delay={300} indicator={&lt;LoadingOutlined style={{ fontSize: 32 }} spin />} />
        {/* 300 milisn ve daha kısa süren durumlarda loading görünmez. */}
      &lt;/div>
    );
  }
  
  export default Loading;
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="graphqlAndMondoDB">
              <div class="row" id="connectMongoDb">
                <h1>MongoDB Bağlantısının Gerçekleştirilmesi</h1>
                <p>
                  sevrer tarafındaki datalar mongoDB üzerine taşınacak. Oradan okunup oraya yazılacak.
                </p>
                <p>
                  <a href="https://www.mongodb.com/atlas/database">MongoDB Atlas</a>'a üye olup giriş yapıyoruz. New Project > Create Project > New Database
                </p>
                <p>
                  mongoDB compass uygulamasını yükledik (bizde zaten yüklü).
                </p>
                <p>
                  MongoDB Atlasta kurduğumuz server sayfasında connect'i tıkladık. "Allow Access from Anywhere" > IP değiştirilmeden onayla > Username: "root" password: "1234" > "Create Database User" > "Choose a connection method" > "Compass" > Bu işlemde aldığımız link mongoDB compass uygulamasında kullanıldı. (linkteki &lt;password> kısmına parolamız girildi.) 
                </p>
                <p>
                  nodejs tarafında mongoose paketini kullanacağız. server tarafında terminale <pre class="prettyprint ms-0">npm i mongoose</pre>
                </p>
                <p>
                  server/.env oluşturuldu
                  <pre class="prettyprint ms-0">
  MONGO_URI=mongodb+srv://root:1234@cluster0.83fcihf.mongodb.net/?retryWrites=true&w=majority
                  </pre>
                </p>
                <p>
                  src\db.js oluşturuldu
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  import dotenv from "dotenv";
  
  dotenv.config(); // .env dosyasından ortam değişkeni almak için kullanıldı. "process.env.MONGO_URI" bu şekilde çağırıldı.
  
  export default () => {
    mongoose.connect(
      process.env.MONGO_URI,
      {
        useUnifiedTopology: true,
      }
    );
  
    mongoose.connection.on(`open`, () =>
      console.log(`MongoDB: Connected`)
    );
    mongoose.connection.on(`error`, (e) =>
      console.log(`MongoDB: Not Connected!`, e)
    );
  };
  
                  </pre>
                </p>
                <p>
                  server\src\index.js içinde mongodb bağlantısı import edilip eklendi.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers"; 
  import typeDefs from "@type-defs"; 
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data,
    },
  });
  
  const server = createServer(yoga); 
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
              </div>
              <div class="row" id="createUserModel">
                <h1>User Modelinin Oluşturulması</h1>
                <p>
                  server\src\models\User.js içinde User modelini oluşturduk.
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const UserSchema = new Schema({
    fullName: {
      type: String, // veri tipi
      required: true, // zorunlu alan mı?
    },
    age: {
      type: Number,
      required: true,
    },
    profile_photo: String,
  });
  
  export default mongoose.model("User", UserSchema);
                  </pre>
                </p>
                <p>
                  Oluşturduğumuz User modelini server\src\index.js içinde import edip context ile gönderdik.
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  import User from "./models/User";
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers";
  import typeDefs from "@type-defs";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data, // fake DB
      _db: { // mongoDB
        User,
      }
    },
  });
  
  const server = createServer(yoga);
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
                  </pre>
                </p>
                <p>
                  context içindeki <code>_db: User</code> ifadesini server\src\graphql\resolvers\resolvers\Query.js içinde kullandık.
                  <pre class="prettyprint ms-0">
  export const Query = {
    users: async (_, __, { _db }) => { // database bağlantısı bekleneceğinden fonksiyon asenkron tanımlandı.
      const users = await _db.User.find(); // db içindeki tüm user kısmı çekildi.
      return users;
    },
    user: async (_, args, { _db }) => {
      const user = _db.User.findById(args.id);
      if (!user) {
        return new Error("User not found");
      }
  
      return user;
    },
  
    posts: (_, __, { db }) => db.posts,
    post: (parent, args, { db }) => db.posts.find((post) => post.id === args.id),
  
    comments: (_, __, { db }) => db.comments,
    comment: (_, args, { db }) =>
      db.comments.find((comment) => comment.id === args.id),
  };
                  </pre>
                </p>
                <p>
                  mongodb atlas üzerinden bir user ekledik. "browse Collections" > users > "INSERT DOCUMENT"
                </p>
              </div>
              <div class="row" id="createPostModel">
                <h1>Post Modelinin Oluşturulması</h1>
                <p>
                  Yukarıdaki işlemin aynısını Post için yapıyoruz.
                </p>
                <p>
                  server\src\models\Post.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const PostSchema = new Schema({
    title: {
      type: String,
      required: true,
    },
    description: String,
    short_description: String,
    cover: String,
  });
  
  export default mongoose.model("Post", PostSchema)
                  </pre>
                </p>
                <p>
                  server\src\index.js
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  //Models
  import User from "./models/User";
  import Post from "./models/Post";
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers";
  import typeDefs from "@type-defs";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data, // fake DB
      _db: { // mongoDB
        User,
        Post,
      }
    },
  });
  
  const server = createServer(yoga);
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Query.js
                  <pre class="prettyprint ms-0">
  export const Query = {
    users: async (_, __, { _db }) => {
      const users = await _db.User.find();
      return users;
    },
    user: async (_, args, { _db }) => {
      const user = _db.User.findById(args.id);
      if (!user) {
        return new Error("User not found");
      }
  
      return user;
    },
  
    posts: async (_, __, { _db }) => {
      const posts = await _db.Post.find();
      return posts;
    },
    post: async (_, args, { _db }) => {
      const post = await _db.Post.findById(args.id);
      return post
    },
  
    comments: (_, __, { db }) => db.comments,
    comment: (_, args, { db }) =>
      db.comments.find((comment) => comment.id === args.id),
  };
  
                  </pre>
                </p>
                <p>
                  Yapıyı test etmek için mongoDB atlas içinde post datası oluşturuldu.
                </p>
              </div>
              <div class="row" id="createCommentModel">
                <h1>Comment Modelinin Oluşturulması</h1>
                <p>
                  Yukarıdaki işlemin aynısını Comment için yapıyoruz.
                </p>
                <p>
                  server\src\models\Comment.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const CommentSchema = new Schema({
    text: {
      type: String,
      required: true,
    },
  });
  
  export default mongoose.model("Comment", CommentSchema);
  
                  </pre>
                </p>
                <p>
                  server\src\index.js
                  <pre class="prettyprint ms-0">
  import { createYoga, createSchema, createPubSub } from "graphql-yoga";
  import { createServer } from "node:http";
  
  import db from "./db"; // mongoDB
  db();
  
  //Models
  import User from "./models/User";
  import Post from "./models/Post";
  import Comment from "./models/Comment";
  
  import data from "./data.js"; // fake data
  import resolvers from "@resolvers";
  import typeDefs from "@type-defs";
  
  const pubSub = createPubSub();
  
  const yoga = createYoga({
    schema: createSchema({
      typeDefs,
      resolvers,
    }),
    context: {
      pubSub,
      db: data, // fake DB
      _db: {
        // mongoDB
        User,
        Post,
        Comment,
      },
    },
  });
  
  const server = createServer(yoga);
  server.listen(4000, () => {
    console.info("Server is running on http://localhost:4000/graphql");
  });
  
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Query.js
                  <pre class="prettyprint ms-0">
  export const Query = {
    users: async (_, __, { _db }) => {
      const users = await _db.User.find();
      return users;
    },
    user: async (_, args, { _db }) => {
      const user = _db.User.findById(args.id);
      if (!user) {
        return new Error("User not found");
      }
  
      return user;
    },
  
    posts: async (_, __, { _db }) => {
      const posts = await _db.Post.find();
      return posts;
    },
    post: async (_, args, { _db }) => {
      const post = await _db.Post.findById(args.id);
      return post;
    },
  
    comments: async (_, __, { _db }) => {
      const comments = await _db.Comment.find();
      return comments;
    },
    comment: async (_, args, { _db }) => {
      const comment = await _db.Comment.findById(args.id);
      return comment;
    },
  };
  
                  </pre>
                </p>
                <p>
                  Yapıyı test etmek için mongoDB atlas içinde comment datası oluşturuldu.
                </p>
              </div>
              <div class="row" id="relationshipMongoDb">
                <h1>MongoDB İlişkileri</h1>
                <p>
                  Verileri ilişkilendirmek için: 
                  <pre class="prettyprint ms-0">
  {
        type: Schema.Types.ObjectId,
        ref: "Comment"
      }
                  </pre>
                  yapısını kullanacağız. İlişkilendireceğimiz veri array ise <q>[]</q> içine alacağız.
                </p>
                <p>
                  server\src\models\User.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const UserSchema = new Schema({
    fullName: {
      type: String, // veri tipi
      required: true, // zorunlu alan mı?
    },
    age: {
      type: Number,
      required: true,
    },
    profile_photo: String,
    posts: [
      {
        type: Schema.Types.ObjectId,
        ref: "Post",
      },
    ],
    comments: [
      {
        type: Schema.Types.ObjectId,
        ref: "Comment"
      }
    ]
  });
  
  export default mongoose.model("User", UserSchema);
  
                  </pre>
                </p>
                <p>
                  server\src\models\Comment.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const CommentSchema = new Schema({
    text: {
      type: String,
      required: true,
    },
    user: {
      type: Schema.Types.ObjectId,
      ref: "User"
    },
    post: {
      type: Schema.Types.ObjectId,
      ref: "Post"
    }
  });
  
  export default mongoose.model("Comment", CommentSchema);
  
                  </pre>
                </p>
                <p>
                  server\src\models\Post.js
                  <pre class="prettyprint ms-0">
  import mongoose from "mongoose";
  const Schema = mongoose.Schema;
  
  const PostSchema = new Schema({
    title: {
      type: String,
      required: true,
    },
    description: String,
    short_description: String,
    cover: String,
    user: {
      type: Schema.Types.ObjectId,
      ref: "User",
    },
    comments: [
      {
        type: Schema.Types.ObjectId,
        ref: "Comment",
      },
    ],
  });
  
  export default mongoose.model("Post", PostSchema);
  
                  </pre>
                </p>
                <p>
                  resolvers yapılarını modellere uygun hale getiriyoruz.
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\User.js
                  <pre class="prettyprint ms-0">
  export const User = {
    posts: async (parent, __, { _db }) =>
      await _db.Post.find({ user: parent.id }),
    comments: async (parent, __, { _db }) =>
      await _db.Comment.find({ user: parent.id }),
  };
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Comment.js
                  <pre class="prettyprint ms-0">
  export const Comment = {
    post: async (parent, __, { _db }) => await _db.Post.findById(parent.post),
    user: async (parent, __, { _db }) => await _db.User.findById(parent.user),
  };
                  </pre>
                </p>
                <p>
                  server\src\graphql\resolvers\resolvers\Post.js
                  <pre class="prettyprint ms-0">
  export const Post = {
    comments: async (parent, __, { _db }) =>
      await _db.Comment.find({post: parent.id}),
    user: async (parent, __, { _db }) =>
      await _db.User.findById(parent.user),
  };
                  </pre>
                </p>
                <p>
                  type-defs içindeki tanımlarda artık veri tabanında kullanılmayanları siliyoruz.
                </p>
                <ul>Veri tabanı:
                  <li>users:<ul>
                    <li>id: ObjectId</li>
                    <li>fullName: String</li>
                    <li>age: String</li>
                    <li>profile_photo: String</li>
                    <li>posts: Array<ul>
                      <li>ObjectId</li>
                    </ul></li>
                    <li>comments: Array<ul>
                      <li>ObjectId</li>
                    </ul></li>
                  </ul></li>
                  <li>posts: <ul>
                    <li>id: ObjectId</li>
                    <li>title: String</li>
                    <li>short_description: String</li>
                    <li>description: String</li>
                    <li>cover: String</li>
                    <li>user: ObjectId</li>
                    <li>comments: Array<ul>
                      <li>ObjectId</li>
                    </ul></li>
                  </ul></li>
                  <li>comments: <ul>
                    <li>id: ObjectId</li>
                    <li>text: String</li>
                    <li>user: ObjectId</li>
                    <li>post: ObjectId</li>
                  </ul></li>
                </ul>
              </div>
              <div class="row" id="refactoringUserMutation">
                <h1>Refactoring User Mutations</h1>
                <p>
                  Mutation işlemlerimizi mongoose üzerinden yapmak için server\src\graphql\resolvers\resolvers\Mutation.js klasörü user alanı aşağıdaki gibi düzenlendi.
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  export const Mutation = {
    // User
    createUser: async (_, { data }, { pubSub, _db }) => {
      const newUser = new _db.User({
        ...data,
      });
  
      const user = await newUser.save();
      
      pubSub.publish("userCreated", { userCreated: user });
  
      return user;
    },
    updateUser: async (_, { id, data }, { pubSub, _db }) => {
      const is_user_exist = await _db.User.findById(id);
      if (!is_user_exist) {
        throw new Error("User not found.");
      }
  
      const update_user = await _db.User.findByIdAndUpdate(id, data, {
        new: true, // bize güncellenen kullanıcının datasını dönmesi için yazıldı.
      })
      pubSub.publish("userUpdated", { userUpdated: update_user });
      return update_user;
    },
    deleteUser: async (_, { id }, { pubSub, _db }) => {
      const is_user_exist = await _db.User.findById(id);
      if (!is_user_exist) {
        throw new Error("User not found.");
      }
  
      const deleted_user = await _db.User.findByIdAndDelete(id)
  
      pubSub.publish("userDeleted", { userDeleted: deleted_user });
      return deleted_user;
    },
    deleteAllUsers: async (_, __, { _db }) => {
      const delete_users = await _db.User.deleteMany({});
  
      return {
        count: delete_users.deletedCount,
      };
    },
    // Post
    ...
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="refactoringPostMutation">
                <h1>Refactoring Post Mutations</h1>
                <p>
                  Mutation işlemlerimizi mongoose üzerinden yapmak için server\src\graphql\resolvers\resolvers\Mutation.js klasörü post alanı aşağıdaki gibi düzenlendi.
                  <pre class="prettyprint ms-0">
  import { nanoid } from "nanoid";
  
  export const Mutation = {
    ...
    // Post
    createPost: async (_, { data }, { pubSub, _db }) => {
      const newPost = new _db.Post({
        ...data,
      });
  
      const post = await newPost.save();
  
      const user = await _db.User.findById(data.user);
      user.posts.push(post.id);
      user.save(); // bu üç satır post bilgisini ilgili usera eklemek için
  
      const postsCount = await _db.Post.countDocuments();
  
      pubSub.publish("postCreated", { postCreated: post });
      pubSub.publish("postsCount", { postsCount });
      return post;
    },
    updatePost: async (_, { id, data }, { pubSub, _db }) => {
      const is_post_exist = await _db.Post.findById(id);
      if (!is_post_exist) {
        throw new Error("Post not found.");
      }
  
      const updated_post = await _db.Post.findByIdAndUpdate(id, data, {
        new: true, // bize güncellenen kullanıcının datasını dönmesi için yazıldı.
      });
  
      pubSub.publish("postUpdated", { postUpdated: updated_post });
      return updated_post;
    },
    deletePost: async (_, { id }, { pubSub, _db }) => {
      const is_post_exist = await _db.Post.findById(id);
      if (!is_post_exist) {
        throw new Error("User not found.");
      }
  
      const postDeleted = await _db.Post.findByIdAndDelete(id);
  
      const postsCount = await _db.Post.countDocuments();
  
      pubSub.publish("postDeleted", { postDeleted });
      pubSub.publish("postsCount", { postsCount });
  
      return postDeleted;
    },
    deleteAllPosts: async (_, __, { pubSub, _db }) => {
      const deleted_posts = await _db.Post.deleteMany({});
  
      pubSub.publish("postsCount", { postsCount: 0 });
      return {
        count: deleted_posts.deletedCount,
      };
    },
  
    ...
  };
  
                  </pre>
                </p>
                <p>
                  server\src\graphql\type-defs\Post.graphql de aşağıdaki değişiklik yapıldı
                  <pre class="prettyprint ms-0">
  ...
  }
  input CreatePostInput {
    title: String!
    description: String
    short_description: String
    cover: String
    user: ID! # user_id yerine user yazıldı.
  }
  input UpdatePostInput {
    title: String
    description: String
    short_description: String
    cover: String
    user: ID
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="refactoringCommentMutation">
                <h1>Refactoring Comment Mutations</h1>
                <p>
                  Mutation işlemlerimizi mongoose üzerinden yapmak için server\src\graphql\resolvers\resolvers\Mutation.js klasörü comment alanı aşağıdaki gibi düzenlendi.
                  <pre class="prettyprint ms-0">
  export const Mutation = {
    ...
  
    // Comment
    createComment: async (_, { data }, { pubSub, _db }) => {
      const newComment = new _db.Comment(data);
      const createdComment = await newComment.save();
  
      const post = await _db.Post.findById(data.post);
      const user = await _db.User.findById(data.user);
  
      post.comments.push(createdComment.id);
      user.comments.push(createdComment.id);
  
      await post.save();
      await user.save();
  
      pubSub.publish("commentCreated", { commentCreated: createdComment });
      return createdComment;
    },
    updateComment: async (_, { id, data }, { pubSub, _db }) => {
      const is_comment_exist = await _db.Comment.findById(id);
      if (!is_comment_exist) {
        throw new Error("Comment not found.");
      }
  
      const updated_comment = await _db.Comment.findByIdAndUpdate(id, data, {
        new: true, // bize güncellenen kullanıcının datasını dönmesi için yazıldı.
      });
  
      pubSub.publish("commentUpdated", { commentUpdated: updated_comment });
  
      return updated_comment;
    },
    deleteComment: async (_, { id }, { pubSub, _db }) => {
      const is_commet_exist = await _db.Comment.findById(id);
      if (!is_commet_exist) {
        throw new Error("Comment not found.");
      }
  
      const commentDeleted = await _db.Comment.findByIdAndDelete(id);
  
      pubSub.publish("commentDeleted", { commentDeleted });
      return commentDeleted;
    },
    deleteAllComments: async (_, __, { _db }) => {
      const deleted_comment = await _db.Comment.deleteMany({});
      
      return {
        count: deleted_comment.deletedCount,
      };
    },
  };
  
                  </pre>
                </p>
                <p>
                  server\src\graphql\type-defs\Comment.graphql içindeki user_id ve post_id <q>user</q> ve <q>post</q> olarak güncellendi.
                  <pre class="prettyprint ms-0">
  type Comment {
    id: ID!
    text: String!
    post: Post!
    user: User!
  }
  input CreateCommetInput {
    text: String!
    post: ID!
    user: ID!
  }
  input UpdateCommentInput {
    text: String
    post: ID
    user: ID
  }
  
  ...
  
                  </pre>
                </p>
              </div>
              <div class="row" id="refactoringSubscriptions">
                <h1>Refactoring Subscriptions</h1>
                <p>
                  server\src\graphql\resolvers\resolvers\Subscription.js dosyasında aşağıdaki değişiklikler yapıldı.
                  <pre class="prettyprint ms-0">
  import { filter, pipe } from "graphql-yoga";
  
  export const Subscription = {
    ...
  
    // Post
    postCreated: {
      subscribe: (_, args, { pubSub }) => {
        return pipe(
          pubSub.subscribe("postCreated"), 
          filter(
            (
              value 
            ) =>
              args.user_id 
                ? value.postCreated.user == args.user_id // value.postCreated.user_id değiştirildi
                : true 
          )
        );
      },
    },
  
    ...
    postsCount: {
      subscribe: async (_, __, { pubSub, _db }) => {
        const postsCount = await _db.Post.countDocuments(); // mevcut post sayısı çekildi.
  
        setTimeout(() => {
          pubSub.publish("postsCount", { postsCount });
        });
        return pubSub.subscribe("postsCount");
      },
    },
  
    ...
    // Comment
    commentCreated: {
      subscribe: (_, args, { pubSub }) => {
        return pipe(
          pubSub.subscribe("commentCreated"),
          filter((value) =>
            args.post_id ? value.commentCreated.post == args.post_id : true // value.commentCreated.post_id değiştirildi
          )
        );
      },
    },
    ...
  };
                  </pre>
                </p>
                <p>
                  server\src\graphql\type-defs alanındaki tip tanımlarında <code>type User</code>, <code>type Post</code> ve <code>type Comment</code> alanlarındaki <code>id</code> parametresi <code>_id</code> olarak güncellendi.
                </p>
              </div>
              <div class="row" id="apolloClientUpdates">
                <h1>Apollo Client Güncellemeleri</h1>
                <p>
                  client tarafında queries.js dosyalarında <code>id</code> ifadeleri <code>_id</code> olarak güncellendi.
                </p>
                <p>
                  client\src\pages\Home\index.js dosyasında <code>item.id</code> ifadeleri <code>item._id</code> olarak güncellendi.
                </p>
                <p>
                  client\src\pages\Post\Comments\NewCommentForm.js dosyasında <code>item.id</code> ifadeleri <code>item._id</code> olarak güncellendi. <code>user_id</code> ifadesi <code>user</code> olarak güncellendi. <code>variables</code> altında <code>data</code> olarak gönderilen ifade <code>data: { ...values, post_id }</code> yerine <code>data: { ...values, post: post_id }</code> olarak güncellendi.
                </p>
                <p>
                  client\src\pages\NewPost\NewPostForm.js içinde <code>item.id</code> ifadesi <code>item._id</code> olarak güncellendi. <code>user_id</code> ifadesi <code>user</code> olarak güncellendi.
                </p>
                <p>
                  Postlar listelenirken en günceli en üstte olması için server tarafında server\src\graphql\resolvers\resolvers\Query.js dosyasında aşağıdaki güncelleme yapıldı.
                  <pre class="prettyprint ms-0">
  export const Query = {
    ...
  
    posts: async (_, __, { _db }) => {
      const posts = await _db.Post.find().sort({ _id: -1 });
      return posts;
    },
    ...
  };
  
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="hasura">
              <div class="row" id="enterToHasura">
                <h1>Hasura'ya Giriş ve Query</h1>
                <p>
                  GraphQl backendleri geliştirebileceğimiz bir ortam. <a href="https://hasura.io/">hasura.io</a>. Alternatif olarak <a href="https://www.prisma.io/graphql">prisma.io/graphql</a>
                </p>
                <p>
                  Hasura.io>"login">"project">"new project">"create free project"
                </p>
                <p>
                  Yeni proje içinden "launch console" tıklandı Gelen ekranda "Data" > "postgres" > "neon" > "connect neon database" denilerek yeni database oluşturuldu 
                </p>
                <p>
                  Oluşan database içinde public altında "new table" denildi. Gelen form dolduruldu. Tablo doldururma düzeni SQL ile aynı. Yardım gerekirse SQL notlarına bakılabilir. "add table" ile tablomuz kaydedildi
                </p>
                <p>
                  database alanında users tıklanarak oluşturduğumuz database'e ulaşıp işlem yapabiliriz.
                </p>
                <p>
                  "DATA" alanına users tablosunu oluşturduktan sonra "API" alanına döndüğümüzde bizi:
                  <ul>üç adet hazır query
                    <li><b>users(
                      distinct_on: [users_select_column!]
                      limit: Int
                      offset: Int
                      order_by: [users_order_by!]
                      where: users_bool_exp
                      )</b>: tüm userları sorgular</li>
                    <li><b>users_aggregate(
                      distinct_on: [users_select_column!]
                      limit: Int
                      offset: Int
                      order_by: [users_order_by!]
                      where: users_bool_exp
                      )</b>: toplam user sayısı</li>
                    <li><b>user_by_pk(id: Int)</b> id ye göre tekli user sorgular.</li>
                  </ul>
                  <ul>yedi adet hazır mutation:
                    <li><b>delete_users(where: users_bool_exp!)</b>: tüm userları silmek için</li>
                    <li><b>delete_users_by_pk(id: Int!)</b>: id ye göre bir user silmek için</li>
                    <li><b>insert_users(objects: [users_insert_input!]!on_conflict: users_on_conflict)</b>: birden fazla user eklemek için</li>
                    <li><b>insert_users_one(object: users_insert_input!on_conflict: users_on_conflict)</b>: bir user eklemek için</li>
                    <li><b>update_users(
                      _inc: users_inc_input
                      _set: users_set_input
                      where: users_bool_exp!
                      )</b>: tüm userları güncellemek için</li>
                    <li><b>update_users_by_pk(
                      _inc: users_inc_input
                      _set: users_set_input
                      pk_columns: users_pk_columns_input!
                      )</b>: id ye göre bir user güncellemek için</li>
                    <li><b>update_users_many(updates: [users_updates!]!)</b>: birden fazla user güncellemek için</li>
                  </ul>
                  <ul>dört hazır subscription
                    <li><b>users</b>: tablodaki her değişiklik için</li>
                    <li><b>users_aggregate(
                      distinct_on: [users_select_column!]
                      limit: Int
                      offset: Int
                      order_by: [users_order_by!]
                      where: users_bool_exp
                      )</b>: tablodaki sayısal her değişiklik için</li>
                    <li><b>users_by_pk(id: Int!)</b>: id ye göre bir userda her değişiklik için</li>
                    <li><b>users_stream(
                      batch_size: Int!
                      cursor: [users_stream_cursor_input]!
                      where: users_bool_exp
                      )</b></li>
                  </ul>
                </p>
                <p>
                  query sorguları SQL ile uyumlu. Sayfa içindeki "Explorer" sekmesi bütün sorgulanabilir parametreleri içeriyor.
                </p>
              </div>
              <div class="row" id="hasuraMutations">
                <h1>Hasura Mutations</h1>
                <p>
                  Mutationlar genel anlamda bildiğimiz gibi. SQL sorgusu yapısıyla kurallar ekleyebiliyoruz. "Explorer" kısmında hepsi var
                </p>
                <p>
                  insert_users ile birden fazla user eklemek için object içine array içinde object yapısıyla bu userlar yerleştirilir.
                </p>
              </div>
              <div class="row" id="hasuraSubscriptions">
                <h1>Hasura Subscriptions</h1>
                <p>
                  "Explorer" sekmesi ile çok rahat keşfedilebiliyor.
                </p>
                <p>
                  Hasura databasete olan her değişikliği subscribe edebiliyor.
                </p>
                <p>
                  SQL tipi limitlemeler konulabiliyor.
                </p>
              </div>
              <div class="row" id="hasuraRelationships">
                <h1>Relationships</h1>
                <p>
                  database altında todos adında bir tablo oluşturduk. Tablonun user_id parametresini "Foreign Keys" yapısı ile user tablosundaki id ile eşleştirdik. Bu sırada "On Delete Violation": "cascade" olarak seçildi. Bu durumda bir user silindiğinde ona bağlı tüm todo elemanları da silinecek.
                </p>
                <p>
                  users tablosunda "Relationships" sekmesinde bize bir array relationship öneriyor. Bunu ekleyip adını "todos" olarak seçtik.
                </p>
                <p>
                  todos tablosunda "Relationships" sekmesinde bize bir object relationship öneriyor. Bunu ekleyip adını "user" olarak seçtik.
                </p>
                <p>
                  Yaptığımız işlem sonucunda user sorgusu altında todo, todo sorgusu altında da user otomatik olarak yer alıyor.
                </p>
              </div>
              <div class="row" id="hasuraCustomActions">
                <h1>Custom Actions</h1>
                <p>
                  Hasurada "ACTIONS" sekmesi altından ulaşılıyor. Hasuranın hazır verdikleri dışında yapmak istediğimiz işlemler için kullanıyoruz.
                </p>
                <p>
                  "Action Defination" alanına yeni dahil edeceğimiz query veya mutation yazılır.
                  <pre class="prettyprint ms-0">
  type Query {
    hello: HelloOutput!
  }
                  </pre>
                </p>
                <p>
                  "Type Configuration" alanına yukarıdaki işlem için gereken yeni tip tanımı yapılır
                  <pre class="prettyprint ms-0">
  type HelloOutput {
   message: String!
  }
                  </pre>
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" verinin çekileceği yeri belirtir. (Şimdilik <q>http://host.docker.internal:3000</q> yazdık)
                </p>
                <p>
                  "Create Action" dediğimizde yeni bir query tanımlamış olduk.
                </p>
                <p>
                  Actions>hello tıklanarak "Codegen" sekmesi açıldığında backendde çalışması gereken fonksiyon görünür. "try on glich" denilerek kod <a href="https://glitch.com/">glitch.com</a> üzerinde açıldı. Bu bize backend oluşturmadan actionumuzu deneme fırsatı sunar. 
                </p>
                <p>
                  Glitch içinde src/server.js de dönen response <code>message: "world"</code> olarak düzenlendi. "preview" sekmesi sayesinde glitch projesinin linli alındı. Bu linki kendi actionumuzda handler alanına <code>.../hello</code> endpointi ile gireceğiz.
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" alanı glitch serverındaki yönlendirme ile değiştirildi:  <q>https://vintage-abalone-manuscript.glitch.me/hello</q>
                </p>
                <p>
                  API alanına 
                  <pre class="prettyprint ms-0">
  query helloQuery {
    hello {
      message
    }
  }
                  </pre>
                  yazdığımızda
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "hello": {
        "message": "world"
      }
    }
  }
                  </pre> çıktısı alınıyor.
                </p>
  
                <h2>Örnek 2</h2>
                <p>
                  "Action Defination"
                  <pre class="prettyprint ms-0">
  type Query {
    hello(data: HelloInput): HelloOutput!
  }
                  </pre>
                  "Type Configuration" > "Declare New Types"
                  <pre class="prettyprint ms-0">
  type HelloOutput {
    message: String!
  }
  
  input HelloInput{
    name: String!
  }
                  </pre>
                </p>
                <p>
                  Glitch içinde src/server.js
                  <pre class="prettyprint ms-0">
  const express = require("express");
  const bodyParser = require("body-parser");
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  // paste the code from codegen here
  
  app.post("/hello", async (req, res) => {
    const { name } = req.body.input.data;
  
    return res.json({
      message: `hello ${name}`,
    });
  });
  
  app.listen(PORT);
                  </pre>
                </p>
                <p>
                  API alanına 
                  <pre class="prettyprint ms-0">
  query helloQuery {
    hello(data: {name: "Murat"}) {
      message
    }
  }
                  </pre>
                  yazdığımızda
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "hello": {
        "message": "hello Murat"
      }
    }
  }
                  </pre> çıktısı alınıyor.
                </p>
  
                <h2>Örnek 3</h2>
                <p>
                  "Action Defination"
                  <pre class="prettyprint ms-0">
  type Mutation {
    singUp (data: SingUpInput!): SingUpOutput!
  }
                  </pre>
                  "Type Configuration" > "Declare New Types"
                  <pre class="prettyprint ms-0">
  type SingUpOutput {
    accessToken: String!
  }
  
  input SingUpInput {
    email: String!
  }
                  </pre>
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" e şimdilik <q>http://host.docker.internal:3000</q> yazdık.
                </p>
                <p>
                  "Create Action"
                </p>
                <p>
                  Actions>singUp>"Codegen">"Try on glitch"
                </p>
                <p>
                  Glitch içinde src/server.js
                  <pre class="prettyprint ms-0">
  const express = require("express");
  const bodyParser = require("body-parser");
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  app.post("/singUp", async (req, res) => {
    const { email } = req.body.input.data;
  
    return res.json({
      accessToken: `thisIsAnAccessTokenFor${email}`,
    });
  });
  
  app.listen(PORT);
  
                  </pre>
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" alanı glitch serverındaki yönlendirme ile değiştirildi:  <q>https://vintage-abalone-manuscript.glitch.me/singUp</q>
                </p>
                <p>
                  API alanına 
                  <pre class="prettyprint ms-0">
  mutation SingUp {
    singUp(data: {email: "drmuratgokduman@gmail.com"}) {
      accessToken
    }
  }
                  </pre>
                  yazdığımızda
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "singUp": {
        "accessToken": "thisIsAAccessTokenFordrmuratgokduman@gmail.com"
      }
    }
  }
                  </pre> çıktısı alınıyor.
                </p>
  
                <h2>Örnek 4</h2>
                <p>
                  Örnek 3 üzerinden devam ediyoruz.
                </p>
                <p>
                  Yaptığımız işlemin hasura üzerindeki databasee işlem yapabilmesi için "Hasura Cloud" içinde proje sayfamızdaki "Env vars" alanındaki <q>HASURA_GRAPHQL_ADMIN_SECRET</q> alanına ihtiyacımız var. Biz onu şimdilik <code>123456</code> olarak belirledik.
                </p>
                <p>
                  Glitch tarafında bu işlemi yapabilmek için iki pakete ihtiyacımız var. "+ ADD PACKAGE" ile "grapgql" ve "graphql-request" kuruldu. "graphql-request" güncel versiyon çalışmadı biz de package.json içinde "graphql-request": "^3.3.0" yazıp eski versiyonu kurdurduk. Glitch node versiyonu güncel halini çalıştıramıyor.
                </p>
                <p>
                  src/clients/hasura.js oluşturuldu.
                  <pre class="prettyprint ms-0">
  import { GraphQLClient } from "graphql-request";
  
  const headers = {
    "Content-Type": "application/json",
    "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
  };
  
  const client = new GraphQLClient(process.env.HASURA_ENDPOINT, { headers });
  
  export default client;
                  </pre>
                  .env içinde "HASURA_ENDPOINT" ve "HASURA_ADMIN_SECRET" oluşturuldu. <br>
                  src/queries.js oluşturuldu. ve içine istediğimiz işi yapacak sorgu eklendi.
                  <pre class="prettyprint ms-0">
  export const INSERT_USER_MUTATION = `
  mutation AddUser($input: users_insert_input!) {
    insert_users_one(
      object: $input
    ) {
      id
      email
      fullName
    }
  }
  `;
                  </pre>
                  tüm eklenenler src/server.js içine import edilip kullanıldı.
                  <pre class="prettyprint ms-0">
  import express from "express";
  import bodyParser from "body-parser";
  import Hasura from "./clients/hasura";
  import { INSERT_USER_MUTATION } from "./queries";
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  app.post("/singUp", async (req, res) => {
    const { email, fullName } = req.body.input.data;
  
    const { insert_users_one } = await Hasura.request(INSERT_USER_MUTATION, {
      input: {
        fullName,
        email,
      },
    });
  
    return res.json({
      id: insert_users_one.id,
    });
  });
  
  app.listen(PORT);
                  </pre>
                </p>
                <p>
                  actions>singUp (aksiyonumuz)>"Relationship">"Add a relationship" deyip tabloyu dolduruyoruz. Böylece response olarak dönen id bilgisini users tablosuna bağlıyoruz.
                </p>
                <p>
                  Hasura üzerinden aşağıdaki mutation gerçekleşince
                  <pre class="prettyprint ms-0">
  mutation MyMutation {
    singUp(data: {email: "mx@m", fullName: "Murat 3"}) {
      id
      user {
        fullName
        email
        age
        created_at
        todos {
          id
          text
        }
      }
    }
  }
                  </pre>
                  aşağıdaki sonuç alınır.
                  <pre class="prettyprint ms-0">
  {
    "data": {
      "singUp": {
        "id": 22,
        "user": {
          "fullName": "Murat 3",
          "email": "mx@m",
          "age": null,
          "created_at": "2023-07-22T18:04:09.612366+00:00",
          "todos": []
        }
      }
    }
  }
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraRemoteSchemas">
                <h1>Remote Schemas</h1>
                <p>
                  Graphql yapısı ile hazırlanmış başka bir projeyi kendi hasura projemize dahil etmek için tek gereken eklemek istediğimiz projenin endpointi.
                </p>
                <p>
                  Hasura içinde "Remote Schemas">"Add" dedikten sonra "GraphQL Service URL" alanına eklemek istediğimiz endpointi yerleştirip formu dolduruyoruz ve "Add Remote Schemas" diyoruz.
                </p>
                <p>
                  Örnek graphql api için <a href="https://github.com/graphql-kit/graphql-apis">https://github.com/graphql-kit/graphql-apis</a>
                </p>
              </div>
              <div class="row" id="hasuraEventTriggers">
                <h1>Event Triggers</h1>
                <p>
                  Veri tabanında bir değişiklik olduğunda bir olay başlatmak için kullanılır. Örneğin yeni bir kullanıcı eklendiğinde o kullanıcıya hoşgeldiniz maili göndermek gibi.
                </p>
                <p>
                  <b>Cron trigers</b> kısmında da zamana bağlı tetiklenen aksiyonlar yazılabilir.
                </p>
                <p>
                  <b>One-off Scheduled Events</b> spesifik bir zamanda çalışacak aksiyonlar yazılabilir. Örneğin meeting uygulaması geliştirirken toplantıdan 30 dk önce tüm katılımcılara mesaj at vs.
                </p>
  
                <h2>Örnek</h2>
                <p>
                  <b>Senaryo:</b> Yeni bir kullanıcı eklendiğinde kullanıcıya hoşgeldin maili gönder.
                </p>
                <p>
                  "Event Triggers">"Create"> ile gelen formu dolduruyoruz. Şimdilik Webhook (HTTP/S) Handler alanına <a href="https://requestcatcher.com/">requestcatcher.com</a> sitesinde yarattığımız <q>https://hasura.requestcatcher.com/test</q> adresini giriyoruz. Bu durumda hasurada event tetiklendiğinde giden requesti göreceğiz. Sonra "Create Event Trigger" deyip eventi ekliyoruz.
                </p>
                <p>
                  DATA alanına elle bir kullanıcı ekledik. Bunun sonucunda https://hasura.requestcatcher.com/ sayfasında
                  <pre class="prettyprint ms-0">
  POST /test HTTP/1.1
  Host: hasura.requestcatcher.com
  Accept-Encoding: gzip
  Content-Length: 570
  Content-Type: application/json
  User-Agent: hasura-graphql-engine/v2.30.0-cloud.1
  X-B3-Parentspanid: 6462ab0e7396c73e
  X-B3-Sampled: 1
  X-B3-Spanid: f36b8d8071646d5f
  X-B3-Traceid: 178ea92cb8a666af9c790c407ac51580
  
  {"created_at":"2023-07-24T04:55:44.799386","delivery_info":{"current_retry":0,"max_retries":0},"event":{"data":{"new":{"age":5,"created_at":"2023-07-24T04:55:44.799386+00:00","email":"bora@bora.com","fullName":"Bora Gökduman","id":23,"updated_at":"2023-07-24T04:55:44.799386+00:00"},"old":null},"op":"INSERT","session_variables":{"x-hasura-role":"admin"},"trace_context":{"span_id":"412a8a544a7f6506","trace_id":"178ea92cb8a666af9c790c407ac51580"}},"id":"a2946095-c160-40a4-b8b3-14c5db415a05","table":{"name":"users","schema":"public"},"trigger":{"name":"insert_user"}}
                  </pre>
                  çıktısı alındı.
                </p>
                <p>
                  Daha önce kullandığımız glitch serverina geri dönüp işlemlerimize <a href="https://glitch.com/edit/#!/vintage-abalone-manuscript">oradan</a> devam edeceğiz. Mail gönderimi için "nodemailer" paketi projeye eklendi.
                </p>
                <p>
                  server.js
                  <pre class="prettyprint ms-0">
  import express from "express";
  import bodyParser from "body-parser";
  import Hasura from "./clients/hasura";
  import { INSERT_USER_MUTATION } from "./queries";
  
  import nodemailer from "nodemailer";
  
  const app = express();
  
  const PORT = process.env.PORT || 3000;
  
  app.use(bodyParser.json());
  
  ...
  
  const transporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: "myhasurabackendd@gmail.com",
      pass: "efuvzfpjocfdemnc",
    },
  });
  
  app.post("/send-email", async (req, res) => {
    const { email, fullName } = await req.body.event.data.new;
  
    const mailOptions = {
      from: "myhasurabackendd@gmail.com",
      to: email,
      subject: "Aramıza hoşgeldin",
      text: `Aramıza hoşgeldin ${fullName}`,
    };
    
    transporter.sendMail(mailOptions, (e, i) => {
      if(e){
        throw new Error("Error while sending email")
      }
      
      res.json({
        message: "Email sent ->" + email
      })
    })
  });
  
  app.listen(PORT);
  
                  </pre>
                </p>
                <p>
                  Gmail hesabının üçüncü taraf uygulamasına kendi adına mail izni vermesi için 2 aşamalı doğrulama açılmalı ve o kısmın içinden uygulama şifresi oluşturuldu.
                </p>
                <p>
                  "Webhook (HTTP/S) Handler" alanı glitch serverındaki yönlendirme ile değiştirildi:  <q>https://vintage-abalone-manuscript.glitch.me/send-email</q>
                </p>
                <p>
                  Bu durumda her yeni kullanıcı oluştuğunda kullanıcıya mail atılır.
                </p>
              </div>
            </div>
            <div class="row" id="commentAppWithHasura">
              <div class="row" id="commentHasuraDocker">
                <h1>Hasura Docker Yapılandırması</h1>
                <p>
                  Bu bölümde daha önce yaptığımız comment uygulamasının backendini hasura ile yazacağız.
                </p>
                <p>
                  Lokalde hasura çalışturmak için <a href="https://hasura.io/docs/latest/getting-started/docker-simple/">Quickstart with Hasura using Docker</a> dökümanını kullanacağız. Bunun için <a href="https://docs.docker.com/get-docker/">Docker</a> ve <a href="https://docs.docker.com/compose/install/">Docker Compose version 2.0 or higher</a> ilgili adreslerden indirilip kurulur. Docker Compose yeni versiyonlard Docşker içinde gelmektedir. Bu nedenle ayrıca kurmaya gerek yoktur.
                </p>
                <p>
                  Yeni bir proje klasörü oluşturduk: "comment-challenge-with-hasura" ve altına server klasörü oluşturduk. Terminalde bu server klasörüne gidip <pre class="prettyprint ms-0">curl https://raw.githubusercontent.com/hasura/graphql-engine/stable/install-manifests/docker-compose/docker-compose.yaml -o docker-compose.yml</pre> dedik ve cevap olarak server içinde <q>docker-compose.yml</q> dosyası oluştu. 
                </p>
                <p>
                  docker desktop yönetici olarak açıldı ve girildi. Docker'ın açılması için bilgisayara WSL kuruldu ve WSL 2 ye updaye edildi. Bunun için <a href="https://learn.microsoft.com/tr-tr/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">bu döküman</a> kullanıldı 
                </p>
                <p>
                  Terminale <pre class="prettyprint ms-0">docker-compose up</pre> yazmak gerekir ancak bu işlev yönetici yetkisi olmadan iş bilgisayarında açılmıyor. Bu nedenle server klasöründe dosya>"windows powersheli aç">"windows powersheli yönetici olarak aç" denir ve burada konut girilir.
                </p>
                <p>
                  "docker-compose up" için "postgres:15" ve "hasura/graphql-engine:v2.30.0"ve "hasura/graphql-data-connector:v2.30.0" image dosyaları gerekiyor. Bunları kendisi indiriyor. Sonra server <a href="http://localhost:8080/">http://localhost:8080/</a> ayağa kalkıyor. Burada hasura arayüzü bizi karşılıyor. 
                </p>
                <p>
                  DATA altından "Connect Database" kısmında "Connect Existing Database" denilir ve Database URL kısmında server\docker-compose.yml dosyasında "HASURA_GRAPHQL_METADATA_DATABASE_URL": karşısındaki url yazılır.
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">hasura consol</pre> yazıp çalıştırmak için Hasura CLI bilgisayara kuruldu ve Hasura'yı global olarak erişilebilir kılmak için yolu PATH ortam değişkenine ekledik. sonra terminale <pre class="prettyprint ms-0">hasura init</pre> yazdık ve enter yaptık. server altında hasura adlı bir dizin oluştu. Bunun içindeki metadata hasurada oluşturduğumuz actionları vs, migration tablo oluşturmak için kullanılan sql konutlarını, seeds içinde de tanımları saklar. 
                </p>
                <p>
                  <pre class="prettyprint ms-0">
  cd hasura
  hasura console
                  </pre>
                  yazınca <a href="http://localhost:9695/">http://localhost:9695/</a> portunda hasura açıldı. Burada yaptığımız her düzenleme hasura dizininde kaydedilir.
                </p>
                <p>
                  localhost:8080 tarafında yaptığımız işlemler kaydedilmeyeceğinden bu kısımda çalışmamıza gerek yok. Buraya girişi engellemek için server\docker-compose.yml içindeki environment altında <code>HASURA_GRAPHQL_ENABLE_CONSOLE:</code> ifadesi false yapılır. ve terminal server'dayken <pre class="prettyprint ms-0">docker-compose up --build</pre> denilerek değişiklikler devreye alınır.
                </p>
                <p>
                  hasura, <code>hasura console</code> tanımıyla çalıştırılırken şifre istesin istiyorsak server\docker-compose.yml içindeki environment altında <code>HASURA_GRAPHQL_ADMIN_SECRET:</code> karşısına bir değer eklenir ve hasura tekrar build edilir. Production ortamı için gerekli. development ortamı için olmasına gerek yok.
                </p>
              </div>
              <div class="row" id="commentHasuraData">
                <h1>Veritabanı Mimarisinin Oluşturulması</h1>
                <p>
                  Bu kısımda lokalde çalıştırdığımız Hasura kullanıldı. Daha önceki hasura derslerindeki yol ile "DATA" altında users, posts ve comments tabloları "DATA" oluşturuldu. Aralarında forign key yapısı ile bağ kuruldu. "Relationship" ile de üç tablo birbirine bağlandı.
                </p>
              </div>
              <div class="row" id="commentHasuraClient1">
                <h1>Client Entegrasyonu - 1</h1>
                <p>
                  Daha önce comment-app olarak oluşturduğumuz client bu projeye kopyalandı. Bunun üzerinde çalışacağız
                </p>
                <p>
                  porjemiz graphql-yoga tarafındayken subscription web soket paketine ihtiyaç olmadan alınıyordu. Hasura backendinde apolloclient bu pakete ihtiyaç duyuyor. Bunun için client içinden terminale <pre class="prettyprint ms-0">npm i subscriptions-transport-ws</pre> yazılır. Ve client\src\apollo.js dosyası aşağıdaki şekilde düzenlenir.
                  <pre class="prettyprint ms-0">
import { ApolloClient, InMemoryCache, split, HttpLink } from "@apollo/client";
import { WebSocketLink } from "@apollo/client/link/ws";
import { getMainDefinition } from "@apollo/client/utilities";

const wsLink = new WebSocketLink({
  uri: "ws://localhost:8080/v1/graphql",
  options: {
    reconnect: true
  }
})

const httpLink = new HttpLink({
  uri: "http://localhost:8080/v1/graphql"
})

const splitLink = split(
  ({query }) => {
    const defination = getMainDefinition(query)
    return defination.kind === 'OperationDefinition' && defination.operation === "subscription"
  },
  wsLink,
  httpLink
)

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

export default client;
                  </pre>
                </p>
                <p>
                  client\src\components\PostCounter\queries.js adresindeki postları sayan subscriptionu hasuraya göre güncelledik.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const POST_COUNT_SUBSCRIPTION = gql`
  subscription postCount {
    posts_aggregate {
      aggregate {
        count
      }
    }
  }
`;
                  </pre>
                  yeni veri yapısına uygun olarak subscriptiondan veri çekip client\src\components\PostCounter\index.js içinde kullandık.
                  <pre class="prettyprint ms-0">
import styles from "./styles.module.css";
import { Badge } from "antd";
import { useSubscription } from "@apollo/client";
import { POST_COUNT_SUBSCRIPTION } from "./queries";

function PostCounter() {
  const {loading, data} = useSubscription(POST_COUNT_SUBSCRIPTION);

  const postCount = data?.posts_aggregate?.aggregate?.count
  
  return (
    &lt;div className={styles.container}>
      &lt;Badge count={loading ? "?" : postCount }>
        &lt;span className={styles.counterTitle}>Post{loading ? "" : postCount > 1 && "s"}&lt;/span>
      &lt;/Badge>
    &lt;/div>
  );
}

export default PostCounter;

                  </pre>
                </p>
                <p>
                  Hasura içinde bütün postları getiren ve değişikliğini takip eden bir subscription var. Biz daha önce query ile postları çekip güncellemeyi subscription ile takip ediyorduk. Yeni halinde direk subscription kullandık. client\src\pages\Home\queries.js:
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const POSTS_SUBSCRIPTION = gql`
  subscription posts {
    posts(order_by: { id: desc }) {
      id
      title
      short_description
      user {
        profile_photo
      }
    }
  }
`;
                  </pre>
                  client\src\pages\Home\index.js
                  <pre class="prettyprint ms-0">
import { Avatar, List } from "antd";
import { useSubscription } from "@apollo/client";
import Loading from "components/Loading";
import { POSTS_SUBSCRIPTION } from "./queries";
import { Link } from "react-router-dom";
import styles from "./styles.module.css";

function Home() {
  const { loading, error, data } = useSubscription(POSTS_SUBSCRIPTION);

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;div>Error: {error.message}&lt;/div>;
  }
  return (
    &lt;div>
      &lt;List
        className="demo-loadmore-list"
        loading={false}
        itemLayout="horizontal"
        // loadMore={loadMore}
        dataSource={data.posts}
        renderItem={(item) => (
          &lt;List.Item key={item._id}>
            &lt;List.Item.Meta
              avatar={&lt;Avatar src={item.user.profile_photo} />}
              title={
                &lt;Link to={`/post/${item.id}`} className={styles.listTitle}>
                  {item.title}
                &lt;/Link>
              }
              description={
                &lt;Link to={`/post/${item.id}`} className={styles.listItem}>
                  {item.short_description}
                &lt;/Link>
              }
            />
          &lt;/List.Item>
        )}
      />
    &lt;/div>
  );
}

export default Home;

                  </pre>
                </p>
              </div>
              <div class="row" id="commentHasuraClient2">
                <h1>Client Entegrasyonu - 2</h1>
                <p>
                  client\src\pages\Post\queries.js dosyasında tekil post detayı veren sorgu güncellendi.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const GET_POST = gql`
  query post($id: Int!) {
    posts_by_pk(id: $id) {
      id
      title
      description
      cover
      user {
        id
        fullName
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\index.js dosyasında gelen veriyi almak için gereken düzenleme yapıldı.
                  <pre class="prettyprint ms-0">
import styles from "./styles.module.css";

import Loading from "components/Loading";
import { useParams } from "react-router-dom";
import { useQuery } from "@apollo/client";
import { GET_POST } from "./queries";
import { Typography, Image } from "antd";
import CommentsList from "./Comments/CommentsList";
const { Title } = Typography;

function Post() {
  const { id } = useParams();

  const { loading, error, data } = useQuery(GET_POST, {
    variables: {
      id,
    },
  });

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;div>Error: {error.message}&lt;/div>;
  }

  const { posts_by_pk: post } = data;

  return (
    &lt;div>
      &lt;Title level={3}>{post.title}&lt;/Title>
      &lt;Image src={post.cover} />
      &lt;div className={styles.description}>{post.description}&lt;/div>
      &lt;CommentsList post_id={id}/>
    &lt;/div>
  );
}

export default Post;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\Comments\queries.js dosyasında commentleri listeleyen ve yeni comment oluşturan sorgular düzenlendi.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const GET_USER = gql`
  query {
    users {
      fullName
      id
    }
  }
`;

export const CREATE_COMMENT_MUTATION = gql`
  mutation createComment($input: comments_insert_input!) {
    insert_comments_one(object: $input) {
      id
    }
  }
`;

export const COMMENTS_SUBSCRIPTION = gql`
  subscription getComment($post_id: Int!) {
    comments(where: { post_id: { _eq: $post_id } }) {
      id
      text
      user {
        fullName
        profile_photo
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\Comments\CommentsList.js dosyasında listeleme için gereken düzenlemeler yapıldı.
                  <pre class="prettyprint ms-0">
import Loading from "components/Loading";
import { Divider } from "antd";
import { useSubscription } from "@apollo/client";
import { COMMENTS_SUBSCRIPTION } from "./queries";
import { Avatar, List } from "antd";
import NewCommentForm from "./NewCommentForm";

function CommentsList({ post_id }) {
  const { data, error, loading } = useSubscription(COMMENTS_SUBSCRIPTION, {
    variables: {
      post_id,
    },
  });
  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;div>Error: {error.message}&lt;/div>;
  }

  return (
    &lt;>
      &lt;Divider>Comments&lt;/Divider>

      {!loading && data && (
        &lt;>
          &lt;List
            className="demo-loadmore-list"
            loading={false}
            itemLayout="horizontal"
            // loadMore={loadMore}
            dataSource={data.comments}
            renderItem={(item) => (
              &lt;List.Item key={item.id}>
                &lt;List.Item.Meta
                  avatar={&lt;Avatar src={item.user.profile_photo} />}
                  title={item.user.fullName}
                  description={item.text}
                />
              &lt;/List.Item>
            )}
          />
          &lt;Divider>New Comment&lt;/Divider>
          &lt;NewCommentForm post_id={post_id} />
        &lt;/>
      )}
    &lt;/>
  );
}

export default CommentsList;
                  </pre>
                </p>
                <p>
                  client\src\pages\Post\Comments\NewCommentForm.js dosyasında yeni comment eklenmesi için gereken düzenlemeler yapıldı.
                  <pre class="prettyprint ms-0">
import { useRef } from "react";
import { Button, Col, Form, Input, Row, Select, message } from "antd";
import { useQuery, useMutation } from "@apollo/client";
import { GET_USER, CREATE_COMMENT_MUTATION } from "./queries";
import styles from "./styles.module.css";

const { Option } = Select;

function NewCommentForm({ post_id }) {
  const [createComment, { loading }] = useMutation(CREATE_COMMENT_MUTATION);
  const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);

  const formRef = useRef(); // formu ilk haline getirmesi için.

  const handleSubmit = async (values) => {
    try {
      await createComment({
        variables: {
          input: { ...values, post_id },
        },
      });
      message.success("Comment saved", [4]);

      formRef.current.resetFields(); // formu resetleyen fonksiyon
    } catch (e) {
      message.error(`Comment not saved!.`, [10]);
    }
  };

  return (
    &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off" ref={formRef}>
      {/* resetleme için ref içinde formRef verildi */}
      &lt;Row gutter={24}>
        &lt;Col span={6}>
          &lt;Form.Item
            name="user_id"
            rules={[
              {
                required: true,
                message: "Please select user!",
              },
            ]}
          >
            &lt;Select
              disabled={get_users_loading || loading}
              loading={get_users_loading}
              size="medium"
              placeholder="Select your user"
            >
              {users_data &&
                users_data.users.map((item) => (
                  &lt;Option value={item.id} key={item.id}>
                    {item.fullName}
                  &lt;/Option>
                ))}
            &lt;/Select>
          &lt;/Form.Item>
        &lt;/Col>
        &lt;Col span={14}>
          &lt;Form.Item
            name="text"
            rules={[
              {
                required: true,
                message: "Please enter a message!",
              },
            ]}
          >
            &lt;Input disabled={loading} size="medium" placeholder="Message" />
          &lt;/Form.Item>
        &lt;/Col>
        &lt;Col span={4}>
          &lt;Form.Item className={styles.buttons}>
            &lt;Button
              disabled={loading}
              size="medium"
              type="primary"
              htmlType="submit"
            >
              Add
            &lt;/Button>
          &lt;/Form.Item>
        &lt;/Col>
      &lt;/Row>
    &lt;/Form>
  );
}

export default NewCommentForm;
                  </pre>
                </p>
              </div>
              <div class="row" id="commentHasuraClient3">
                <h1>Client Entegrasyonu - 3</h1>
                <p>
                  client\src\pages\NewPost\queries.js dosyasında yeni post oluşturan mutation güncellendi.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const GET_USER = gql`
  query {
    users {
      fullName
      id
    }
  }
`;

export const NEW_POST_MUTATION = gql`
  mutation createPost($data: posts_insert_input!) {
    insert_posts_one(object: $data) {
      id
      title
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\NewPost\NewPostForm.js dosyasında gereken düzenlemeler yapıldı.
                  <pre class="prettyprint ms-0">
import React from "react";
import { Button, Form, Input, Select, message } from "antd";
import { useNavigate } from "react-router-dom";
import { useQuery, useMutation } from "@apollo/client";
import { GET_USER, NEW_POST_MUTATION } from "./queries";
import styles from "./styles.module.css";

const { Option } = Select;

function NewPostForm() {
  const navigate = useNavigate();

  const [
    savePost, // bizim mutation fonksiyonuna verdiğimiz ad.
    { loading, error }, // işlem sonunda dönen data
  ] = useMutation(NEW_POST_MUTATION);

  const { loading: get_users_loading, data: users_data } = useQuery(GET_USER);

  const handleSubmit = async (values) => {
    try {
      await savePost({
        variables: {
          data: values,
        },
      });
      message.success("Post saved", [4]);
      navigate("/");
    } catch (e) {
      message.error(`Post not saved!. Error: ${error.message}`, [10]);
    }
  };

  return (
    &lt;Form name="basic" onFinish={handleSubmit} autoComplete="off">
      &lt;Form.Item
        name="title" // bu kısım value tanımında key olarak gönderilir. mutation içindeki key ile aynı olmak zorunda.
        rules={[
          {
            required: true,
            message: "Please input a title!",
          },
        ]}
      >
        &lt;Input disabled={loading} size="large" placeholder="Title" />
      &lt;/Form.Item>

      &lt;Form.Item name="short_description">
        &lt;Input
          disabled={loading}
          size="large"
          placeholder="Short description"
        />
      &lt;/Form.Item>

      &lt;Form.Item name="description">
        &lt;Input.TextArea
          disabled={loading}
          size="large"
          placeholder="Description"
        />
      &lt;/Form.Item>

      &lt;Form.Item name="cover">
        &lt;Input disabled={loading} size="large" placeholder="Cover" />
      &lt;/Form.Item>

      &lt;Form.Item
        name="user_id"
        rules={[
          {
            required: true,
            message: "Please select user!",
          },
        ]}
      >
        &lt;Select
          disabled={get_users_loading || loading}
          loading={get_users_loading}
          size="large"
          placeholder="Select your user"
        >
          {users_data &&
            users_data.users.map((item) => (
              &lt;Option value={item.id} key={item.id}>
                {item.fullName}
              &lt;/Option>
            ))}
        &lt;/Select>
      &lt;/Form.Item>

      &lt;Form.Item className={styles.buttons}>
        &lt;Button loading={loading} size="large" type="primary" htmlType="submit">
          Submit
        &lt;/Button>
      &lt;/Form.Item>
    &lt;/Form>
  );
}

export default NewPostForm;

                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="voting">
              <div class="row" id="votingHasuraBackend">
                <h1>Hasura Backend'in Oluşturulması</h1>
                <p>
                  proje klasörü içinde terminale
                  <pre class="prettyprint ms-0">
mkdir backend
cd backend
curl https://raw.githubusercontent.com/hasura/graphql-engine/stable/install-manifests/docker-compose/docker-compose.yaml -o docker-compose.yml
hasura init
                  </pre>
                </p>
                <p>
                  backend\docker-compose.yml içinde "HASURA_GRAPHQL_ENABLE_CONSOLE": false yapıldı. 
                </p>
                <p>
                  backend klasörü içinde "powershell" yönetici olarak açıldı ve içine <pre class="prettyprint ms-0">docker-compose up</pre> yazılarak server ayağa kaldırıldı.
                </p>
                <p>
                  backend\hasura konumunda terminale <pre class="prettyprint ms-0">hasura console</pre> yazılır. Hasura <a href="http://localhost:9695/">http://localhost:9695/</a> portunda açıldı.
                </p>
                <p>
                  backend\docker-compose.yml içinde HASURA_GRAPHQL_METADATA_DATABASE_URL: keyine karşılık gelen "postgres://postgres:postgrespassword@postgres:5432/postgres" urli DATA içinde database eklerken kullandık. Altına da 3 tane tablo açtık.
                  <ul>
                    <li>questions<ul>
                      <li>id: integer(auto-increment), primary key</li>
                      <li>title: text</li>
                    </ul></li>
                    <li>options<ul>
                      <li>id: integer(auto-increment), primary key</li>
                      <li>title: text</li>
                      <li>question_id: foreign key -> questions(table) -> id</li>
                    </ul></li>
                    <li>votes<ul>
                      <li>id: integer(auto-increment), primary key</li>
                      <li>option_id: foreign key -> options(table) -> id</li>
                    </ul></li>
                  </ul> 
                  
                </p>
                <p>
                  "Relationship" kısmında ilişkiler belirtildi.
                </p>
              </div>
              <div class="row" id="votingApolloClientAndReactRouter">
                <h1>Apollo Client ve React Router Kurulumu</h1>
                <p>
                  Terminale
                  <pre class="prettyprint ms-0">
mkdir client
cd client
npx create-react-app .
                  </pre>
                  Kurulumun ardından terminale
                  <pre class="prettyprint ms-0">
npm install @apollo/client graphql
                  </pre> 
                  Kurulumun ardından terminale
                  <pre class="prettyprint ms-0">
npm i react-router-dom
                  </pre>
                </p>
                <p>
                  client\src\index.js içi aşağıdaki gibi güncellendi.
                  <pre class="prettyprint ms-0">
import React from "react";
import ReactDOM from "react-dom/client";
import "./index.css";
import App from "./App";
import { ApolloProvider } from "@apollo/client";
import client from "./apollo";

import { BrowserRouter as Router } from "react-router-dom";

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  &lt;ApolloProvider client={client}>
    &lt;Router> 
      {/* Router sarmalaması App.js yerine burada yapıldı.*/}
      &lt;App />
    &lt;/Router>
  &lt;/ApolloProvider>
);
                  </pre>
                  Hem "apollo client"in hem de "react router dom"un providerleri ile proje sarmalandı.
                </p>
                <p>
                  "apollo provider"de kullanıdğımız ve bizim backende bağlanmamızı sağlayan client tanımı client\src\apollo.js dosyasında oluşturuldu.
                  <pre class="prettyprint ms-0">
import { ApolloClient, InMemoryCache, split, HttpLink } from "@apollo/client";
import { WebSocketLink } from "@apollo/client/link/ws";
import { getMainDefinition } from "@apollo/client/utilities";

const wsLink = new WebSocketLink({
  uri: "ws://localhost:8080/v1/graphql",
  options: {
    reconnect: true
  }
})

const httpLink = new HttpLink({
  uri: "http://localhost:8080/v1/graphql"
})

const splitLink = split(
  ({query }) => {
    const defination = getMainDefinition(query)
    return defination.kind === 'OperationDefinition' && defination.operation === "subscription"
  },
  wsLink,
  httpLink
)

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

export default client;
                  </pre>
                  Bu tanım için gereken paketi yüklemek için terminale
                  <pre class="prettyprint ms-0">
npm i subscriptions-transport-ws
                  </pre>
                </p>
                <p>
                  client\src\App.js içinde routing yapısı kuruldu.
                  <pre class="prettyprint ms-0">
import { Routes, Route, Link } from "react-router-dom";
import Questions from "./pages/Questions";
import NewQuestion from "./pages/New";

function App() {
  return (
    &lt;div className="App">
      &lt;nav>
        &lt;Link to="/">Questions&lt;/Link>
        &lt;Link to="/new">New Question&lt;/Link>
      &lt;/nav>
      &lt;hr />
      &lt;Routes>
        &lt;Route path="/" element={&lt;Questions />} />
        &lt;Route path="/new" element={&lt;NewQuestion />} />
      &lt;/Routes>
    &lt;/div>
  );
}

export default App;
                  </pre>
                  Bu yapıda kullanılan kompanentler yer tutucu olarak oluşturuldu.
                </p>
                client\src\index.css içine stil tanımları yapıldı.
                <pre class="prettyprint ms-0">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

.App {
  padding: 20px;
}

nav > a {
  padding: 0 10px 10px 0;
  color: #000;
  text-decoration: none;
}

nav > a:hover {
  text-decoration: underline;
}
                </pre>
              </div>
              <div class="row" id="votingRealTimeListing">
                <h1>Oylamaların Gerçek Zamanlı Listelenmesi</h1>
                <p>
                  Soruları listeleyecek subscription hasurada belirlendi ve client\src\pages\Questions\queries.js dosyasında yazıldı.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const QUESTIONS_SUBSCRIPTION = gql`
  subscription {
    questions(order_by: { id: desc }) {
      id
      title
    }
  }
`;
                  </pre>
                </p>
                <p>
                  Yazılan subscription client\src\pages\Questions\index.js dosyasında kullanıldı.
                  <pre class="prettyprint ms-0">
import React from "react";
import { useSubscription } from "@apollo/client";
import { QUESTIONS_SUBSCRIPTION } from "./queries";
import Loading from "../../components/Loading";
import { Link } from "react-router-dom";

function Questions() {
  const { loading, data } = useSubscription(QUESTIONS_SUBSCRIPTION);

  if (loading) {
    return &lt;Loading />;
  }

  return (
    &lt;div>
      {data.questions.map((question) => (
        &lt;div key={question.id}>
          &lt;Link to={`/q/${question.id}`}>{question.title}&lt;/Link>
        &lt;/div>
      ))}
    &lt;/div>
  );
}

export default Questions;

                  </pre>
                </p>
                <p>
                  loading durumunda kullanılan kompanent client\src\components\Loading\index.js dosyasına yazıldı.
                  <pre class="prettyprint ms-0">
client\src\components\Loading\index.js
                  </pre>
                </p>
              </div>
              <div class="row" id="votingNewVoting1">
                <h1>Yeni Oylama Oluşturma Ekranının Hazırlanması - 1</h1>
                <p>
                  client\src\pages\New\index.js içinde form tanımları yapıldı.
                  <pre class="prettyprint ms-0">
import { useState } from "react";

const initialOptions = [{ title: "" }, { title: "" }];

function NewQuestion() {
  const [title, setTitle] = useState();
  const [options, setOptions] = useState(initialOptions);

  const handleChangeOption = ({target}) => {
    const newArray = options;
    newArray[target.id].title = target.value

    setOptions([...newArray])
  }

  return (
    &lt;div>
      &lt;h2>Question&lt;/h2>
      &lt;input
        placeholder="Type your question..."
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />

      &lt;h2>Options&lt;/h2>
      {options.map((option, i) => (
        &lt;div key={i}>
          &lt;input
            placeholder="Type your option..."
            value={option.title}
            id={i}
            onChange={handleChangeOption}
          />
        &lt;/div>
      ))}
      &lt;button onClick={() => setOptions([...options, { title: "" }])}>
        New Option
      &lt;/button>

      &lt;button>Save&lt;/button>
    &lt;/div>
  );
}

export default NewQuestion;
                  </pre>
                </p>
                <p>
                  client\src\index.css içinde input ve button için stil tanımı yapıldı.
                  <pre class="prettyprint ms-0">
...
input{
  padding: 6px;
  font-size: 18px;
}

button{
  padding: 6px;
  margin-top: 10px;
}
                  </pre>
                </p>
              </div>
              <div class="row" id="votingNewVoting2">
                <h1>Yeni Oylama Oluşturma Ekranının Hazırlanması - 2</h1>
                <p>
                  Hasura içinde yeni question ve options eklemek için gereken mutation tanımlandı ve client\src\pages\New\queries.js dosyasında kullanıldı.
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const NEW_QUESTION_MUTATION = gql`
  mutation newQuestion($input: questions_insert_input!) {
    insert_questions_one(object: $input) {
      id
      title
    }
  }
`;
                  </pre>
                </p>
                <p>
                  İlgili mutation client\src\pages\New\index.js dosyasında formdan gelen veriler ile kullanıldı. 
                  <pre class="prettyprint ms-0">
import { useState } from "react";

import { useMutation } from "@apollo/client";
import { NEW_QUESTION_MUTATION } from "./queries";

const initialOptions = [{ title: "" }, { title: "" }];

function NewQuestion() {
  const [addQuestion, { loading }] = useMutation(NEW_QUESTION_MUTATION);

  const [title, setTitle] = useState();
  const [options, setOptions] = useState(initialOptions);

  const handleChangeOption = ({ target }) => {
    const newArray = options;
    newArray[target.id].title = target.value;

    setOptions([...newArray]);
  };

  const handleSave = () => {
    const filledOptions = options.filter((option) => option.title !== ""); // Boşları database e göndermemek için optionlardan sadece title değeri olanları filtreledi.

    if (title === null || filledOptions.length < 2) return false;

    addQuestion({
      variables: {
        input: {
          title,
          options: {
            data: filledOptions,
          },
        },
      },
    });

    setOptions(initialOptions);
    setTitle("");
  };

  return (
    &lt;div>
      &lt;h2>Question&lt;/h2>
      &lt;input
        placeholder="Type your question..."
        value={title}
        onChange={(e) => setTitle(e.target.value)}
        disabled={loading}
      />

      &lt;h2>Options&lt;/h2>
      {options.map((option, i) => (
        &lt;div key={i}>
          &lt;input
            placeholder="Type your option..."
            value={option.title}
            id={i}
            onChange={handleChangeOption}
            disabled={loading}
          />
        &lt;/div>
      ))}
      &lt;button
        onClick={() => setOptions([...options, { title: "" }])}
        disabled={loading}
      >
        New Option
      &lt;/button>

      &lt;button onClick={handleSave} disabled={loading}>
        Save
      &lt;/button>
    &lt;/div>
  );
}

export default NewQuestion;

                  </pre>
                </p>
              </div>
              <div class="row" id="votingVotingDetail1">
                <h1>Oylama Detay Ekranının Hazırlanması - 1</h1>
                <p>
                  client\src\App.js içinde route yapısı düzenlendi.
                  <pre class="prettyprint ms-0">
import { Routes, Route, Link } from "react-router-dom";
import Questions from "./pages/Questions";
import NewQuestion from "./pages/New";
import Detail from "./pages/Detail";

function App() {
  return (
    &lt;div className="App">
      &lt;nav>
        &lt;Link to="/">Questions&lt;/Link>
        &lt;Link to="/new">New Question&lt;/Link>
      &lt;/nav>
      &lt;hr />
      &lt;Routes>
        &lt;Route path="/" element={&lt;Questions />} />
        &lt;Route path="/new" element={&lt;NewQuestion />} />
        &lt;Route path="/q/:id" element={&lt;Detail />} />
      &lt;/Routes>
    &lt;/div>
  );
}

export default App;
                  </pre>
                </p>
                <p>
                  client\src\pages\Detail\queries.js içinde question detaylarını çeken subscription ve yeni oy ekleyen mutation kullanıldı. 
                  <pre class="prettyprint ms-0">
import { gql } from "@apollo/client";

export const QUESTION_DETAIL_SUBSCRIPTION = gql`
  subscription questionDetail($id: Int!) {
    questions_by_pk(id: $id) {
      id
      title
      options {
        id
        title
        votes_aggregate {
          aggregate {
            count
          }
        }
      }
    }
  }
`;

export const NEW_VOTE_MUTATIONS = gql`
  mutation newVote($id: Int) {
    insert_votes_one(object: { option_id: $id }) {
      id
      option {
        title
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  client\src\pages\Detail\index.js dosyasında bu sorgular kullanıldı. 
                  <pre class="prettyprint ms-0">
import { useState } from "react";
import { useParams } from "react-router-dom";
import { useMutation, useSubscription } from "@apollo/client";
import { NEW_VOTE_MUTATIONS, QUESTION_DETAIL_SUBSCRIPTION } from "./queries";
import Loading from "../../components/Loading";
import Error from "../../components/Error";

function Detail() {
  const { id } = useParams();

  const [selectedOptionId, setSelectedOptionId] = useState();

  const { data, loading, error } = useSubscription(
    QUESTION_DETAIL_SUBSCRIPTION,
    {
      variables: {
        id,
      },
    }
  );

  const [newVote, { loading: loadingVote }] = useMutation(NEW_VOTE_MUTATIONS);

  const handleClickVote = () => {
    newVote({
        variables: {
            id: selectedOptionId
        }
    })
  };

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;Error message={error.message} />;
  }

  const {
    questions_by_pk: { options, title },
  } = data;
  console.log(data.questions_by_pk);
  return (
    &lt;div>
      &lt;h2>{title}&lt;/h2>

      {options.map((option, i) => (
        &lt;label htmlFor={i} key={i}>
          &lt;input
            type="radio"
            name="selected"
            value={option.id}
            onChange={({ target }) => setSelectedOptionId(target.value)}
          />
          &lt;span>{option.title}&lt;/span>
        &lt;/label>
      ))}

      &lt;button disabled={loadingVote} onClick={handleClickVote}>Vote&lt;/button>
    &lt;/div>
  );
}

export default Detail;
                  </pre>
                </p>
                <p>
                  Error kompanenti client\src\components\Error\index.js dosyasında oluşturuldu. 
                  <pre class="prettyprint ms-0">
import React from 'react'

function Error({message}) {
  return (
    &lt;div>Error: {message}&lt;/div>
  )
}

export default Error
                  </pre>
                </p>
                <p>
                  client\src\index.css içine label stil tanımı eklendi. 
                  <pre class="prettyprint ms-0">
label{
  display: block;
  margin-bottom: 8px;
}
                  </pre>
                </p>
              </div>
              <div class="row" id="votingVotingDetail2">
                <h1>Oylama Detay Ekranının Hazırlanması - 2</h1>
                <p>
                  Oyların dağılımını gösteren progress tagını kullandık. Oy verme durumunda butonu ortadan kaldırıp güncel oy sayılarını gösterdik. 
                </p>
                <p>
                  client\src\pages\Detail\index.js dosyasının son hali: 
                  <pre class="prettyprint ms-0">
import { useState } from "react";
import { useParams } from "react-router-dom";
import { useMutation, useSubscription } from "@apollo/client";
import { NEW_VOTE_MUTATIONS, QUESTION_DETAIL_SUBSCRIPTION } from "./queries";
import Loading from "../../components/Loading";
import Error from "../../components/Error";

function Detail() {
  const { id } = useParams();

  const [isVoted, setIsVoted] = useState(false);
  const [selectedOptionId, setSelectedOptionId] = useState();

  const { data, loading, error } = useSubscription(
    QUESTION_DETAIL_SUBSCRIPTION,
    {
      variables: {
        id,
      },
    }
  );

  const [newVote, { loading: loadingVote }] = useMutation(NEW_VOTE_MUTATIONS, {
    onCompleted: () => {
      // işlem tamamlandığında
      setIsVoted(true); // bunu çalıştır
    },
  });

  const handleClickVote = () => {
    newVote({
      variables: {
        id: selectedOptionId,
      },
    });
  };

  if (loading) {
    return &lt;Loading />;
  }

  if (error) {
    return &lt;Error message={error.message} />;
  }

  const {
    questions_by_pk: { options, title },
  } = data;

  const total = options.reduce(
    (t, value) => t + value.votes_aggregate.aggregate.count,
    0
  ); // 0 dan başlayarak tüm değerleri toplar

  return (
    &lt;div>
      &lt;h2>{title}&lt;/h2>

      {options.map((option, i) => (
        &lt;div key={i}>
          &lt;label htmlFor={i}>
            &lt;input
              type="radio"
              name="selected"
              id={i}
              value={option.id}
              onChange={({ target }) => setSelectedOptionId(target.value)}
            />
            &lt;span>{option.title}&lt;/span>
            {isVoted && (
              &lt;span className="vote_count">
                (%
                {(
                  (option.votes_aggregate.aggregate.count /
                    (total === 0 ? 1 : total)) *
                  100
                ).toFixed(2)}
                ){/* virgülden sonra 2 karakter gösterilmesini sağlar. */}
              &lt;/span>
            )}
          &lt;/label>

          {isVoted && (
            &lt;div>
              &lt;progress
                value={option.votes_aggregate.aggregate.count}
                max={total}
              />
            &lt;/div>
          )}
        &lt;/div>
      ))}

      {!isVoted && (
        &lt;button disabled={loadingVote} onClick={handleClickVote}>
          Vote
        &lt;/button>
      )}
    &lt;/div>
  );
}

export default Detail;
                  </pre>
                </p>
                <p>
                  client\src\index.css dosyasının son hali:
                  <pre class="prettyprint ms-0">
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen",
    "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, "Courier New",
    monospace;
}

.App {
  padding: 20px;
}

nav > a {
  padding: 0 10px 10px 0;
  color: #000;
  text-decoration: none;
}

nav > a:hover {
  text-decoration: underline;
}

input {
  padding: 6px;
  font-size: 18px;
}

button {
  padding: 6px;
  margin-top: 10px;
}

label {
  display: block;
  margin-bottom: 4px;
}

.vote_count {
  font-size: 16;
  margin-left: 4px;
}

progress {
  margin-bottom: 8px;
}
                  </pre>
                </p>
              </div>
            </div>
            <div class="row" id="hasuraDeployment">
              <div class="row" id="hasuraDigitalOceanDeployment">
                <h1>Hasura DigitalOcean Deployment</h1>
                <p>
                  Docker'ın çalıştığı herhangi bir sunucuda hasura backendimiz de çalışır. <a href="https://hasura.io/docs/latest/deployment/deployment-guides/index/">Bu dökümandan faydalandık.</a>
                </p>
                <p>
                  Biz <a href="https://www.digitalocean.com/">DigitalOcean</a> kullanacağız. DigitalOcean aws üzerinden bir makina açıp kullanımıza sunuyor. 
                </p>
                <p>
                  DigitalOcean'a kayıt yapıp giriş yapıyoruz. "Create">"Create Droplets">"Ubuntu"
                </p>
                <p>
                  "Choose Region" da en yakın yeri seçtik. Devamında en ucuz makineyi seçiyoruz. Formun devamını dolduruyoruz. Parola belirliyoruz vs. En son "Create" deyip sunucuyu oluşturuyoruz. 
                </p>
                <p>
                  terminale <pre class="prettyprint ms-0">ssh root@&lt;host-id></pre> ile bağlanıyoruz. Host id digitalOcean içinden alıyoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
sudo apt-get update
sudo apt-get install ca-certificates curl gnupg
apt install docker.io
apt install docker-compose
                  </pre>
                  ile gerekli olan şeyleri kuruyoruz. (detaylar docker dersinde)
                </p>
                <p>
                  <pre class="prettyprint ms-0">systemctl status docker</pre> dockerın çalışma durumunu sorguluyoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">
cd /tmp
mkdir hasura
cd hasura
                  </pre>
                  ile temp içinde hasura klasörü oluşturup içine giriyoruz.
                </p>
                <p>
                  <pre class="prettyprint ms-0">curl https://raw.githubusercontent.com/hasura/graphql-engine/stable/install-manifests/docker-compose/docker-compose.yaml -o docker-compose.yml</pre>
                  ile hasurayı ayağa kaldıracak olan docker-compose.yml dosyasını indiriyoruz.
                </p> 
                <p>
                  <pre class="prettyprint ms-0">docker-compose up</pre> ile docker ayağa kaldırıldı.
                </p>
                <p>
                  host-ip:8080 ile ayağa kalkan projenin konsoluna ulaşabiliriz. Burada DATA alanında docker-compose.yml içindeki endpoint ile makineye hasura kurulurken kurulan postgreSQL endpointini kullanarak database bağlantısını sağladık.
                </p>
                <p>
                  Proje dizinimizde terminale <pre class="prettyprint ms-0">cd backend/hasura</pre> yazarak migration tanımlarını olduğu klasöre geldik. <pre class="prettyprint ms-0">hasura metadata apply --endpoint --adminsecret</pre> sintaxında endpointten sonra kendi endpointimizi girdik. Bizde: <pre class="prettyprint ms-0">hasura metadata apply --endpoint http://134.122.78.209:8080</pre> admin secret olmadığından gönderilmedi.
                </p>
                <p>
                  İşlem tamamlanınca deploy edilen tarafın arayüzünde bizi karşılayan ekranda "reload metadata" diyoruz.
                </p>
                <p>
                  Tablolarımız geldi. Şimdi de migration işlemini yapacağız.
                </p>
                <p>
                  <pre class="prettyprint ms-0">hasura migrate apply --endpoint --adminsecret</pre> sintaxında endpointten sonra kendi endpointimizi girdik. Bizde: <pre class="prettyprint ms-0">hasura migrate apply --endpoint http://134.122.78.209:8080</pre> admin secret olmadığından gönderilmedi.
                </p>
                <p>
                  İşlem tamamlanınca deploy edilen tarafın arayüzünde bizi karşılayan ekranda "Reload all databases" i seçip "reload metadata" diyoruz.
                </p>
              </div>
              <div class="row" id="reactClientNetlifyDeployment">
                <h1>React Client Netlify Deployment</h1>
                <p>
                  Netlfy kayıt ol ve giriş yap. Git repomuzu kaydettik.
                </p>
                <p>
                  Client bir git reposuna alındı.
                </p>
                <p>
                  Netlify>new site> ilgili repo seçilir. Form kontrol edilir ve deploy tıklanır.
                </p>
                <p>
                  client\src\apollo.js içinde hala local endpointlerimiz var. Bunları deploy ettiğimiz hasuranın endpointi ile güncelliyoruz. Tekrar git push yapıyoruz ki değişiklikler netlifyde uygulansın.
                </p>
                <p>
                  hasura docker-compose ile yüklendiğinde https/wss yapısını desteklemiyor. Bu nedenle de websoket tarafında sorun yaşıyoruz. Bu kısmı daha sonra tekrar zorlarız.

                </p>
                <p>
                  Kök dizin dışından açma ve sayfa yenileme işlemlerinde sorun yaşamamak için client\public\_redirects dosyası oluşturuldu ve içine <pre class="prettyprint ms-0">/*    /index.html   200</pre> yazıldı.
                </p>
              </div>
            </div>
            <div class="row" id="hasuraMeetingApp">
              <div class="row" id="hasuraMeetingDb">
                <h1>Hasura Kurulumu ve DB Yapısının Oluşturulması</h1>
                <p>
                  Toplantı planlama uygulaması. Görüşmeye birileri davet edilebilecek. Kabul edenlere son 1 saat kala yeni bir mail gelecek.
                </p>
                <p>
                  Hoca docker ile lokal kurup ilerliyor. Biz hasura cloud ile ilerleyeceğiz. Çünkü daha sonra digitalocean ile deploy etmeye çalışınca hata alıyoruz.
                </p>
                <p>
                  hasura cloud üzerinde yeni bir server oluşturduk. DB olarak postgreSQL bağladık.
                </p>
                <p>
                  users adında bir tablo oluşturduk.
                  <ol>
                    <li><b>id:</b> integer, primary key, unique, default: nextval('users_id_seq'::regclass)</li>
                    <li><b>email:</b>text, unique</li>
                    <li><b>name:</b> text</li>
                    <li><b>surname:</b> text</li>
                    <li><b>password:</b> text</li>
                  </ol>
                </p>
                <p>
                  meetings adında bir tablo oluşturduk.
                  <ol>
                    <li><b>id:</b> integer, primary key, unique, default: nextval('meetings_id_seq'::regclass)</li>
                    <li><b>title:</b> text</li>
                    <li><b>meeting_date:</b> date</li>
                    <li><b>created_at:</b> timestamp with time zone, default: now()</li>
                    <li><b>updated_at:</b> timestamp with time zone, default: now()</li>
                    <li><b>user_id:</b>integer, foreign key(user_id → users.id) On Delete Violation: cascade</li>
                  </ol>
                  Bu tabloda relationship kısmında user adında object tipinde bir ilişki kuruldu. users tablosunda da meetings adında array tipinde bir ilişki kuruldu.
                </p>
                <p>
                  participants adında bir tablo oluşturduk.
                  <ol>
                    <li><b>id: </b>integer, primary key, unique, default: nextval('participants_id_seq'::regclass)</li>
                    <li><b>user_id:</b> integer, foreign key (user_id → users . id) On Delete Violation: cascade</li>
                    <li><b>meeting_id:</b> integer, foreign key (meeting_id → meetings . id ) On Delete Violation: cascade</li>
                  </ol>
                  Bu tabloda relationship kısmında user ve meeting adında object tipinde iki ilişki kuruldu. meeting tablosunda participants adında array tipinde bir ilişki kuruldu. Users tablosunda ilişki kurulmadı.
                </p>
                <p>
                  Örnek veriler girildi ve test edildi.
                </p>
              </div>
              <div class="row" id="hasuraExpressBackend">
                <h1>Express Backending Hazırlanması</h1>
                <p>
                  Login, register vs için kullanılacak backendi hazırlayacağız.
                </p>
                <p>
                  proje dosyasında terminale
                  <pre class="prettyprint ms-0">
cd backend
npm init -y
                  </pre>
                  ile npm başlatıldı.
                </p>
                <p>
                  <pre class="prettyprint ms-0">npm i express</pre> ile express indirildi. <pre class="prettyprint ms-0">npm i --save-d nodemon</pre> ile nodemon dev dependencies olarak kuruldu.
                </p>
                <p>
                  backend\src\app.js
                  <pre class="prettyprint ms-0">
const express = require("express");
const app = express();
const port = process.env.PORT || 3001;

app.use(express.json());

app.post("/register", (req, res) => {
  const input = req.body.input.data;
  console.log(input);

  res.json({
    accessToken: "accessToken",
  });
});

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));
                  </pre>
                </p>
                <p>
                  backend\package.json script alanına nodemon eklendi (gerçi çok da işimize yaramadı.)
                  <pre class="prettyprint ms-0">
"scripts": {
    "dev": "nodemon ./src/app.js"
  },
                  </pre>
                </p>
                <p>
                  Hasura cloud üzerinden action>create>new action
                </p>
                <p>
                  Action Definition
                  <pre class="prettyprint ms-0">
type Mutation {
  register (data: RegisterInput!): RegisterOutput
}
                  </pre>
                  Type Configuration
                  <pre class="prettyprint ms-0">
type RegisterOutput {
  accessToken: String!
}

input RegisterInput {
  email: String!
  password: String!
}
                  </pre>
                </p>
                <p>
                  hoca new action için webhook işlemini lokalde docker-compose üzerinden env olarak yapıyor. Biz online serverda çalıştığımızdan backendimizi de deta.space ile online'a aldık. <br>
                  Webhook (HTTP/S) Handler: https://backend-1-m7357908.deta.app/register
                </p>
                <p>
                  Online'a almak için backend\Spacefile 
                  <pre class="prettyprint ms-0">
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: backend
    src: ./
    engine: nodejs16
    primary: true
    run: node ./src/app.js
    public: true
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraSucraseHasuraClientRoutingErrorHandling">
                <h1>hasuraSucraseHasuraClientRoutingErrorHandling</h1>
                <p>
                  Yapımızda EC6 kullanabilmek için sucrase isimli bir araç kullanacağız. Sucrase bir babel alternatifi. Terminale <pre class="prettyprint ms-0">npm i sucrase</pre> yazılarak kuruldu.
                </p>
                <p>
                  artık app.js içinde EC6 söz dizimini kullanabilriz.
                  <pre class="prettyprint ms-0">
import express from "express";
const app = express();
const port = process.env.PORT || 3001;

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Hello World");
});

app.post("/register", (req, res) => {
  const input = req.body.input.data;
  console.log(input);

  res.json({
    accessToken: "accessToken",
  });
});

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));
                  </pre>
                </p>
                <p>
                  nodemon kullanılırken de sucrase nin çalışması için backend\nodemon.json dosyası oluşturuldu ve içine
                  <pre class="prettyprint ms-0">
{
    "execMap": {
        "js": "node -r sucrase/register"
    }
}
                  </pre>
                  yazıldı.
                </p>
                <p>
                  backend\package.json dosyasında scripts alanı düzenlendi.
                  <pre class="prettyprint ms-0">
"scripts": {
    "dev": "nodemon ./src/app.js",
    "build": "sucrase ./src -d ./dist --transforms imports"
  },
                  </pre>
                  terminale <pre class="prettyprint ms-0">npm run build</pre> yazılarak build alındı. Alınan buildi bir türlü deta.space içine dahil edemeyince ben de kopyalayıp test adlı bir klasöre koydum. Buna bağlı olarak da backend\Spacefile dosyası güncellendi.
                  <pre class="prettyprint ms-0">
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: backend
    src: ./
    engine: nodejs16
    primary: true
    public: true
    run: node test/app.js
                  </pre>
                </p>
                <p>
                  route tanımlarını app.js içinden ayrı bir yere taşıdık. Bunun için backend\src\routes\auth\index.js dosyası oluşturduk ve içine
                  <pre class="prettyprint ms-0">
import express from "express";
const router = express.Router();

router.post("/register", (req, res) => {
  const input = req.body.input.data;
  res.json({ accessToken: "accessToken" });
});

export default router;
                  </pre>
                  yazdık. Bu routerı backend\src\app.js içinde import edip kullandık.
                  <pre class="prettyprint ms-0">
import express from "express";
const app = express();

import auth from "./routes/auth";

const port = process.env.PORT || 3001;

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Hello World");
});

app.use("/auth", auth);

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));
                  </pre>
                </p>
                <p>
                  Bu hali ile hasura cloud üzerindeki action endpointimiz kökdizin/register -> kökdizin/auth/register haline geldi. Bu güncellemeyi de hasura claud üzerinde yaptık.
                </p>
                <p>
                  package.json üzerindeki dist tanımını da test ile değiştirdik ki buildler bizim oluşturduğumuz test klasörüne gelsin :D
                  <pre class="prettyprint ms-0">
"scripts": {
    "dev": "nodemon ./src/app.js",
    "build": "sucrase ./src -d ./test --transforms imports"
  },
                  </pre>
                </p>
                <p>
                  Hasuraya bağlanabilmek için terminale <pre class="prettyprint ms-0">npm i graphql-request</pre> yazarak gerekli kütüphaneyi kurduk.
                </p>
                <p>
                  backend\src\clients\hasura.js dosyasını oluşturup hasura bağlantısını sağladık.
                  <pre class="prettyprint ms-0">
import { GraphQLClient } from "graphql-request";

const headers = {
  "Content-Type": "application/json",
  "x-hasura-admin-secret": "test1234",
};

export default new GraphQLClient(
  "https://meeting-app-server.hasura.app/v1/graphql",
  {
    headers,
  }
);

                  </pre>
                </p>
                <p>
                  Hata olduğunda onu göndermek için bir kütüphane kurduk. <pre class="prettyprint ms-0">npm i boom</pre>
                </p>
                <p>
                  backend\src\app.js üzerinde error catching tanımlarını girdik.
                  <pre class="prettyprint ms-0">
import express from "express";
import Boom from "boom";
import auth from "./routes/auth";

const app = express();

const port = process.env.PORT || 3001;

app.use(express.json());

app.get("/", (req, res) => {
  res.send("Hello World");
});

app.use("/auth", auth);

//route tanımı olmayan bir sayfaya istek yapıldığında:
app.use((req, res, next) => {
  return next(Boom.notFound("Not Found"));
});

//hata gönderildiğinde:
app.use((err, req, res, next) => {
  if (err) {
    if (err.output) {
      return res.status(err.output.statusCode || 500).json(err.output.payload);
    }
  }

  return res.status(500).json(err);
});

app.listen(port, () => console.log(`Server is up and running. Port: ${port}`));

                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\index.js içinde ilk validasyon işlemimizi tanımladık.
                  <pre class="prettyprint ms-0">
import Boom from "boom";
import express from "express";
const router = express.Router();

router.post("/register", (req, res, next) => {
  const input = req.body.input.data;

  if (!input.email || !input.password) {
    return next(Boom.badRequest("Email and Password are requared!"));
  }
  res.json({ accessToken: "accessToken" });
});

export default router;
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraUserRegisterRoute">
                <h1>User Register Route</h1>
                <p>
                  <pre class="prettyprint ms-0">npm i graphql</pre>
                </p>
                <p>
                  hasura cloud üzerinde action>register>Type Configuration alanı name ve surname alması için aşağıdaki gibi düzenlendi.
                  <pre class="prettyprint ms-0">
input RegisterInput {
  email: String!
  name: String!
  surname: String!
  password: String!
}

type RegisterOutput {
  accessToken: String!
}
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\queries.js altında gerekli sorgular yapıldı.
                  <pre class="prettyprint ms-0">
// Kullanıcının varlığını sorgulayan query
export const IS_EXIST_USER = `
  query isExist($email: String!) {
    users(where: {email: {_eq: $email}}) {
      id
    }
  }
`;

// Kullanıcı ekleyen mutation
export const INSERT_USER_MUTATION = `
  mutation insertUser ($input: users_insert_input!){
    insert_users_one(object: $input) {
      id
      name
    }
  }
`;
                  </pre>
                  Bu sorgular backend\src\routes\auth\index.js içinde kullanılacak.
                </p>
                <p>
                  Validasyon için <pre class="prettyprint ms-0">npm install joi</pre> kuruldu
                </p>
                <p>
                  backend\src\routes\auth\validations.js içinde validasyon tanımları yapıldı.
                  <pre class="prettyprint ms-0">
import Joi from "joi";

export const registerSchema = Joi.object({
  email: Joi.string().email().required(),
  name: Joi.string().min(1).max(60).required(),
  surname: Joi.string().min(1).max(60).required(),
  password: Joi.string().min(6).max(60).required(),
});
                  </pre>
                  Bu tanım backend\src\routes\auth\index.js içinde kullanılacak.
                </p>
                <p>
                  Parolaları şifrelemek için: <pre class="prettyprint ms-0">npm i bcryptjs</pre> kuruldu.
                </p>
                <p>
                  backend\src\routes\auth\index.js
                  <pre class="prettyprint ms-0">
import express from "express";
import Boom from "boom";
import bcrypt from "bcryptjs";
import Hasura from "../../clients/hasura";
import { IS_EXIST_USER, INSERT_USER_MUTATION } from "./queries";
import { registerSchema } from "./validations";

const router = express.Router();

router.post("/register", async (req, res, next) => {
  const input = req.body.input.data;

  input.email = input.email.toLowerCase();

  // validasyon işlemi
  const { error } = registerSchema.validate(input);
  if (error) {
    return next(Boom.badRequest(error.details[0].message));
  }

  try {
    const isExistUser = await Hasura.request(IS_EXIST_USER, {
      email: input.email,
    });

    // user zaten varsa hata ver
    if (isExistUser.users.length > 0) {
      throw Boom.conflict(`user already exist (${input.email})`);
    }

    // Parola şifreleme işlemi
    const salt = await bcrypt.genSalt(10);
    const hash = await bcrypt.hash(input.password, salt); // şifrelenmiş parola

    // user yoksa user oluştur
    const user = await Hasura.request(INSERT_USER_MUTATION, {
      input: {
        ...input,
        password: hash,
      },
    });

    res.json({ accessToken: "accessToken" });
  } catch (err) {
    return next(Boom.badRequest(err));
  }
});

export default router;
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraJWTAuthRegister">
                <h1>Hasura JWT Authentication (Register)</h1>
                <p>
                  accessToken ile auth işlemleri
                </p>
                <p>
                  Öncelikle product ortamında görünmesini istemediğimiz "HASURA_ADMIN_SECRET" ve bu uygulamada accessToken üretmek için kullanacağımız "JWT_ACCESS_TOKEN_SECRET" key/value çiftlerini backend\.env dosyasına taşıdık.
                  <pre class="prettyprint ms-0">
JWT_ACCESS_TOKEN_SECRET=b***4
HASURA_ADMIN_SECRET=t***4
                  </pre>
                  Bunların bizim deta.space uygulamamızda da çalışması için Spacefile dosyasını güncelledik.
                  <pre class="prettyprint ms-0">
# Spacefile Docs: https://go.deta.dev/docs/spacefile/v0
v: 0
micros:
  - name: backend
    src: ./
    engine: nodejs16
    primary: true
    public: true
    run: node test/app.js
    presets:
      env:
        - name: JWT_ACCESS_TOKEN_SECRET
          description: JWT access token için secret
          default: "b***4"
        - name: HASURA_ADMIN_SECRET
          description: hasura admin secret
          default: "t***4"
                  </pre>
                </p>
                <p>
                  .env dosyasının okunabilmesi için <pre class="prettyprint ms-0">npm i dotenv</pre> ile ilgili paket kuruldu. backend\src\app.js içinde çalıştırıldı.
                  <pre class="prettyprint ms-0">
...
import dotenv from "dotenv";

...

dotenv.config();
...
                  </pre>
                  backend\src\clients\hasura.js içinde de aynı işlem tekrarlandı.
                  <pre class="prettyprint ms-0">
import { GraphQLClient } from "graphql-request";
import dotenv from "dotenv";

dotenv.config();

const headers = {
  "Content-Type": "application/json",
  "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
};

export default new GraphQLClient(
  "https://meeting-app-server.hasura.app/v1/graphql",
  {
    headers,
  }
);
                  </pre>
                </p>
                <p>
                  accessToken üretmek için <pre class="prettyprint ms-0">npm i jsonwebtoken</pre> ile ilgili paket yüklendi. backend\src\routes\auth\helpers.js içine
                  <pre class="prettyprint ms-0">
import JWT from "jsonwebtoken";
import Boom from "boom";

export const singAccessToken = (user) => {
  return new Promise((resolve, reject) => {
    const payload = {
      "https://hasura.io/jwt/claims": {
        // hasurada kullanabilmemiz için gereken tanımlar.
        "x-hasura-allowed-roles": ["user"],
        "x-hasura-default-role": "user",
        "x-hasura-user-id": user.id.toString(),
      },
      email: user.email,
    };

    const options = {
      expiresIn: "100d", // ne kadar süre için geçerli
      issuer: "graphql-egitimi", // tokenı kim vermiş
      audience: user.id.toString(), // token kime verilmiş
    };

    JWT.sign(
      payload,
      process.env.JWT_ACCESS_TOKEN_SECRET,
      options,
      (err, token) => {
        if (err) {
          return reject(Boom.internal("JWT sing error"));
        }
        resolve(token);
      }
    ); // ilk parametre payload, ikinci parametre access token secret, üçüncü parametre options, dördüncü parametre callback fonksiyon
  });
};
                  </pre>
                </p>
                <p>
                  user tanımı içinde email olması için backend\src\routes\auth\queries.js içinde gerekli güncelleme yapıldı.
                  <pre class="prettyprint ms-0">
// Kullanıcının varlığını sorgulayan query
export const IS_EXIST_USER = `
  query isExist($email: String!) {
    users(where: {email: {_eq: $email}}) {
      id
    }
  }
`;

// Kullanıcı ekleyen mutation
export const INSERT_USER_MUTATION = `
  mutation insertUser ($input: users_insert_input!){
    insert_users_one(object: $input) {
      id
      email
    }
  }
`;
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\helpers.js içinde ürettiğimiz accessToken üretme fonksiyonu backend\src\routes\auth\index.js içinde import edilip kullanıldı.
                  <pre class="prettyprint ms-0">
import express from "express";
import Boom from "boom";
import bcrypt from "bcryptjs";
import { singAccessToken } from "./helpers"; // accessToken için import edildi.

import Hasura from "../../clients/hasura";
import { IS_EXIST_USER, INSERT_USER_MUTATION } from "./queries";
import { registerSchema } from "./validations";

const router = express.Router();

router.post("/register", async (req, res, next) => {
  const input = req.body.input.data;

  input.email = input.email.toLowerCase();

  // validasyon işlemi
  const { error } = registerSchema.validate(input);
  if (error) {
    return next(Boom.badRequest(error.details[0].message));
  }

  try {
    const isExistUser = await Hasura.request(IS_EXIST_USER, {
      email: input.email,
    });

    // user zaten varsa hata ver
    if (isExistUser.users.length > 0) {
      throw Boom.conflict(`user already exist (${input.email})`);
    }

    // Parola şifreleme işlemi
    const salt = await bcrypt.genSalt(10);
    const hash = await bcrypt.hash(input.password, salt); // şifrelenmiş parola

    // user yoksa user oluştur
    const { insert_users_one: user } = await Hasura.request(
      INSERT_USER_MUTATION,
      {
        input: {
          ...input,
          password: hash,
        },
      }
    );

    const accessToken = await singAccessToken(user); // accessToken üretildi.

    res.json({ accessToken });
  } catch (err) {
    return next(Boom.badRequest(err));
  }
});

export default router;
                  </pre>
                </p>
                <p>
                  <a href="https://jwt.io/">jwt.io</a> sitesinde aldığımız accesstoken içinde neyi barındırıyor görebiliriz.
                </p>
                <p>
                  Hasura cloudun accessToken'ı tanıması için https://cloud.hasura.io/project içinde projemize girip "Env vars" alanına "HASURA_GRAPHQL_JWT_SECRET" adında <pre class="prettyprint ms-0">{"key":"buraya_secret_key_yazıyoruz_1234","type":"HS256"}</pre> tanımında bir girdi eklenir. "key" karşısına bizim belirlediğimiz "JWT_ACCESS_TOKEN_SECRET" değeri girildi.
                  Aynı alana yetkisiz kullanıcı tanımı için: "HASURA_GRAPHQL_UNAUTHORIZED_ROLE" adında <pre class="prettyprint ms-0">anonymous</pre> değeri girildi
                </p>
                <p>
                  hasura cloud console alanında "DATA">users>"Permissions" alanında user ve anonymous tanımarı eklendi.
                </p>
                <p>
                  hasura cloud console alanında "Request Headers" alanına "key": "Authorization", "value": "Bearer &lt;acessToken>" yazılır ve "x-hasura-admin-secret" tiki kaldırılırsa sadece "user" için verilen yetkiyle yapılacak işlemler görünür. Diğer işlemlere izin vermez.
                </p>
              </div>
              <div class="row" id="hasuraJWTAuthLogin">
                <h1>Hasura JWT Authentication (Login)</h1>
                <p>
                  Login için gereken action oluşturulacak.
                </p>
                <p>
                  Hasura Cloud Console > "ACTIONS" > "Create"
                </p>
                <p>
                  Action Definition
                  <pre class="prettyprint ms-0">
type Mutation {
  # Define your action here
  login (data: LoginInput!): LoginOutput!
}
                  </pre>
                  Type Configuration
                  <pre class="prettyprint ms-0">
type LoginOutput {
  accessToken: String!
}

input LoginInput {
  email: String!
  password: String!
}
                  </pre>
                  "Webhook (HTTP/S) Handler": https://backend-1-m7357908.deta.app/auth/login <br>
                  "Forward client headers to webhook" seçildi. ve "Create Action" tıklandı.
                </p>
                <p>
                  "Actions" > "login" > "Permissions" alanında "anonymous" için yrtki verildi. "user" bu yetkiye sahip değil. Aynı işlem register için de tekrarlandı.
                </p>
                <p>
                  backend\src\routes\auth\queries.js dosyasına login için gereken query eklendi. 
                  <pre class="prettyprint ms-0">
...
export const LOGIN_QUERY = `
  query login($email: String!) {
    users(
      where: {
        email: {
          _eq: $email
        }
      }
      limit: 1
    ){
      id
      email
      password
    }
  }
`;
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\validations.js dosyasına login validasyonu eklendi.
                  <pre class="prettyprint ms-0">
...
export const loginSchema = Joi.object({
  email: Joi.string().email().required(),
  password: Joi.string().min(6).max(60).required(),
});
                  </pre>
                </p>
                <p>
                  backend\src\routes\auth\index.js içine login işlemi tanımlandı.
                  <pre class="prettyprint ms-0">
...
router.post("/login", async (req, res, next) => {
  const input = req.body.input.data;
  input.email = input.email.toLowerCase();

  const { error } = loginSchema.validate(input);
  if (error) {
    return next(Boom.badRequest(error.details[0].message));
  }

  try {
    const { users } = await Hasura.request(LOGIN_QUERY, {
      email: input.email,
    });

    if (users.length === 0) {
      throw Boom.unauthorized("Email or password is incorrect");
    }

    const user = users[0];

    const isMatch = await bcrypt.compare(input.password, user.password);

    if (!isMatch) {
      throw Boom.unauthorized("Email or password is incorrect");
    }

    const accessToken = await singAccessToken(user);
    return res.json({ accessToken });
  } catch (err) {
    return next(err);
  }
});
...
                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraMeQuery">
                <h1>Me Query</h1>
                <p>
                  accessToken üzerinden kullanıcıyı bulacağız.
                </p>
                <p>
                  Hasura Cloud Console alanıda "Actions" > "Create" <br>
                  Action Definition
                  <pre class="prettyprint ms-0">
type Query {
  me: MeOutput
}
                  </pre>
                  Type Configuration
                  <pre class="prettyprint ms-0">
type MeOutput {
  user_id: String!
}
                  </pre>
                  "Webhook (HTTP/S) Handler": https://backend-1-m7357908.deta.app/auth/me <br>
                  "Forward client headers to webhook" seçildi. ve "Create Action" tıklandı.
                </p>
                <p>
                  Permission alanında "user" rolüne yetki verildi.
                </p>
                <p>
                  backend\src\routes\auth\helpers.js içinde token verfy işlemi için fonksiyon yazıldı. 
                  <pre class="prettyprint ms-0">
...

export const verifyAccessToken = (req, res, next) => {
  const authHeader = req.headers.authorization || req.query.token?.toString();

  if (!authHeader) {
    return next(Boom.unauthorized("No token provided"));
  }

  const bearerToken = authHeader.split(" ");
  const token = bearerToken[bearerToken.length - 1];

  JWT.verify(token, process.env.JWT_ACCESS_TOKEN_SECRET, (err, decoded) => {
    if (err) {
      const message =
        err.name === "JsonWebTokenError" ? "Unouthorized" : err.message;
      return next(Boom.unauthorized(message));
    }
    req.payload = decoded;
    req.token = token;
    next();
  });
};
                  </pre>
                </p>
                <p>
                  Bu fonksiyon backend\src\routes\auth\index.js içinde import edildi ve "/me" route'u içinde kullanıldı. "/me" route'u ve verifyAccessToken fonksiyonu kullanılarak header ile gelen accessToken'ın ait olduğu id dönüldü.
                  <pre class="prettyprint ms-0">
...

router.post("/me", verifyAccessToken, async (req, res, next) => {
  const { aud } = req.payload;

  return res.json({
    user_id: aud,
  });
});
...
                  </pre>
                </p>
                <p>
                  "Actions" > "me" > "Relationship" > "Add a relationship"
                </p>
                <p>
                  Gelen formda user_id ile user tablosundaki id eşleştirildi. Bu sayede me ile elde ettiğimiz user_id ile userın izin verilen tüm bilgilerine ulaşabildik.
                </p>
              </div>
              <div class="row" id="hasuraPermissions">
                <h1>hasuraPermissions</h1>
                <p>
                  Önce meeting ile görmek istediğimiz veri için bir sorgu yazıyoruz. İzinleri bunun üzerinden kurgulayacağız.
                  <pre class="prettyprint ms-0">
query MyQuery {
  meetings{
    id
    title
    user{
      id
      name
      surname
    }
    participants{
      user{
        id
        name
        surname
      }
    }
  }
}
                  </pre>
                </p>
                <p>
                  "DATA" altından her tablo için "Permissions" alanında izinler tanımlanır.
                </p>
                <p>
                  meetings > permissions alanında user için "Without any checks" ile tüm alanlara izin verildi. "Allow role user to make aggregation queries" de seçildi. aynı işlem participants > permissions altında da yapıldı.
                </p>
                <p>
                  Bu haliyle kullanıcı kendisinin dahil olmadığı meetingleri de görür. Bunu engellemek için "Without any checks" "With custom check" olarak güncellendi.
                  <pre class="prettyprint ms-0">
{
  "_or":[
    {
      "user_id":{
        "_eq":"X-Hasura-User-Id"
      }
    },
    {
      "participants":{
        "user_id":{
          "_eq":"X-Hasura-User-Id"
        }
      }
    }
  ]
}
                  </pre>
                </p>
                <p>
                  Bu durumda user sadece oluşturduğu veya katılımcısı olduğu meeting'leri görüntüler.
                </p>
              </div>
              <div class="row" id="hasuraComputedFields">
                <h1>Computed Fields</h1>
                <p>
                  Oluşturduğumuz tabloda olmayan ama tablodaki alanlarla hesaplanarak oluşturulabilen alanlardır. Örneğin user tablosunda name ve surname var. Bunlarla fullname yapılabilir.
                </p>
                <p>
                  "DATA" > "users" > "Modify" > "Computed Fields"
                </p>
                <p>
                  Computed Field Name: fullName <br>
                  Function Schema:public <br>
                  Function Name: "Create New" ile postgreSQL dilinde bir fonksiyon yazıyoruz.
                  <pre class="prettyprint ms-0">
CREATE FUNCTION user_full_name(user_row users)
RETURNS TEXT AS $$
  SELECT user_row.name || ' ' || user_row.surname
$$ LANGUAGE sql STABLE;
                  </pre>
                  fonksiyonu kaydediyoruz. Sonra baştaki adımları tekrar yapıyoruz. Function Name: kısmında az önce oluşturduğumuz fonksiyonu seçiyoruz ve kaydediyoruz.
                </p>
                <p>
                  DATA > users > permissions alanıda user için bu alana da izin verdikten sonra artık sorguda fullName diye bir parametremiz de oluyor.
                </p>
              </div>
              <div class="row" id="hasuraEventTrigers">
                <h1>Event Triggers</h1>
                <p>
                  meeting katılımcılarına mail gönderme işlemi. Öncelikle <a href="https://www.mailspons.com/">mailspons.com</a> üzerinden her user için fake mail alıp veri tabanımıza ekledik. Bu istediğimiz gibi çalışmadığından (biraz yavaş) <a href="https://www.tempinbox.xyz/mailbox">tempinbox.xyz</a> üzerinden tekrar fake mail alıp user'larımıza tanımladık.
                </p>
                <p>
                  Hasura Cloud Console > "EVENT" > "Event Triggers" > "Create"
                </p>
                <p>
                  Trigger Name: meeting_created <br>
                  Database: default <br>
                  Schema/Table: public, meetings <br>
                  Trigger Operations: Insert <br>
                  Webhook (HTTP/S) Handler: https://backend-1-m7357908.deta.app/webhooks/meeting_created <br>
                  "Create Event Triger"
                </p>
                <p>
                  backend\src\app.js içinde webhooks için gereken routing yapıldı.
                  <pre class="prettyprint ms-0">
...
// routes
...
import webhooks from "./routes/webhooks";
...
                  </pre>
                </p>
                <p>
                  backend\src\routes\webhooks\queries.js içinde webhook ile weri çekilecek sorgu yazıldı.
                  <pre class="prettyprint ms-0">
export const GET_MEETING_PARTICIPANTS = `
query meeting_participant($id: Int!) {
    meetings_by_pk(id: $id) {
      title
      user {
        fullName
      }
      participants {
        user {
          email
        }
      }
    }
  }
`;
                  </pre>
                </p>
                <p>
                  mail gönderebilmek için
                  <pre class="prettyprint ms-0">npm i nodemailer</pre>
                  paketi kuruldu.
                </p>
                <p>
                  backend\src\routes\webhooks\index.js içinde events triger ile gelen veri alındı. Bu veri ile sorgu yapıldı. Sorgudan gelen veriler ile de mail gönderildi.
                  <pre class="prettyprint ms-0">
import express from "express";
import nodemailer from "nodemailer";

import Hasura from "../../clients/hasura";
import { GET_MEETING_PARTICIPANTS } from "./queries";

const router = express.Router();

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "myhasurabackendd@gmail.com",
    pass: "efuvzfpjocfdemnc",
  },
});

router.get("/meeting_created", (req, res) => {
  res.send("Hello World");
});

router.post("/meeting_created", async (req, res, next) => {
  const meeting = req.body.event.data.new;

  const { meetings_by_pk } = await Hasura.request(GET_MEETING_PARTICIPANTS, {
    id: meeting.id,
  });

  const title = meeting.title;
  const { fullName } = meetings_by_pk.user;
  const participants = meetings_by_pk.participants
    .map(({ user }) => user.email)
    .toString();

  const mailOptions = {
    from: "myhasurabackendd@gmail.com",
    to: participants,
    subject: `${fullName} sizi bir görüşmeye davet etti`,
    text: `${fullName} sizi ${title} adlı görüşmeye davet etti.`,
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      throw new Error(error);
    }

    res.json({ info });
  });
});

export default router;

                  </pre>
                </p>
                <p>
                  Bu dosyada kullanılan process.env.... kısımları backend\.env ve backend\Spacefile dosyalarına eklendi.
                </p>
              </div>
              <div class="row" id="hasuraMeetingApproveInvitation">
                <h1>Meeting Approve Invitation</h1>
                <p>
                  Mail il gelen daveti kabul etmek
                </p>
                <p>
                  "Hasura Cloud Console" > "DATA" > participants kısmına "is_approved" adında "boolean" default değeri "false" bir sütun oluşturduk.
                </p>
                <p>
                  "Hasura Cloud Console" > "DATA" > participants > "Permissions" altında user için update kısmına "With custom check" ile <pre class="prettyprint ms-0">{"user_id":{"_eq":"X-Hasura-User-Id"}}</pre> koşulu ile "is_approved" alanına izin verdik. "is_approved" için select izni de verdik
                </p>
              </div>
              <div class="row" id="hasuraOneOffScheduledEvents1">
                <h1>One Off Scheduled Events - 1</h1>
                <p>
                  Görüşmeye yarım saat kala katılımcılara mail gönder.
                </p>
                <p>
                  "Hasura Cloud Console" > "EVENTS" > One-off Scheduled Events içinde <a href="https://hasura.io/docs/latest/api-reference/schema-metadata-api/scheduled-triggers/#create-scheduled-event">bu dökümandan</a> faydalanarak backend\src\routes\webhooks\index.js içinde bir obje oluşturuyoruz.
                </p>
                <p>
                  zaman tanımları için <pre class="prettyprint ms-0">npm i moment</pre> ile kurduğumuz paketi kullanacağız. İstek göndermek için de <pre class="prettyprint ms-0">npm i axios</pre> kuruldu.
                </p>
                <p>
                  "Hasura Cloud Console" > "DATA" > meeting içinde "meeting_date" data tipi "timestamp with time zone" olarak güncellendi.
                </p>
                <p>
                  meeting_date bilgisini alabilmek için backend\src\routes\webhooks\queries.js içindeki query güncellendi.
                </p>
                <p>
                  backend\src\routes\webhooks\index.js içinde Scheduled Events oluşturacak yapı kurgulandı. 
                  <pre class="prettyprint ms-0">
...
import moment from "moment";
import axios from "axios";

...

router.post("/meeting_created", async (req, res, next) => {
  ...

  const schedule_event = {
    // zamanlanmış görev eklemek için gereken obje
    type: "create_scheduled_event",
    args: {
      webhook: "https://backend-1-m7357908.deta.app/webhooks/meeting_reminder", //görev başlatılınca çalıştırılacak webhook
      schedule_at: moment(meetings_by_pk.meeting_date).subtract(2, "min"), // görev başlangıç tarihinden 2 dk çıkardık.
      payload: {
        //webhook tetiklendiğinde gönderilecek data
        meeting_id: meeting.id,
      },
    },
  };

  const add_event = await axios(
    "https://meeting-app-server.hasura.app/v1/query",
    {
      // endpoint olarak hasura endpointimizi sonuna qraphql yerine query yazarak kullanıyoruz.
      method: "POST",
      data: JSON.stringify(schedule_event), // ile hazırladığımız Scheduled Events gönderildi.
      headers: {
        "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
      },
    }
  );

  const event_data = add_event.data;

  ...
});

router.post("/meeting_reminder", async (req, res, next) => {
  // Scheduled Events ile tetiklenecek işlev.
});

export default router;

                  </pre>
                </p>
              </div>
              <div class="row" id="hasuraOneOffScheduledEvents2">
                <h1>One Off Scheduled Events - 2</h1>
                <p>
                  insert_meeting_one mutation'unu user kullanıcısı ile kullanamabilmek için, "DATA" > "meetings" > "Permissions" alanında user > insert için "with custom check" <pre>{"user_id":{"_eq":"X-Hasura-User-Id"}}</pre> kontrolü ile, "Column insert permissions": "title, meeting_date" seçili, "Column presets" - "user_id" - "from session variable" -> "X-Hasura-user-id" izin verildi.
                </p>
                <p>
                  participant ekleyebilmesi için de "DATA" > "meetings" > "Permissions" alanında "with custom check" <pre>{"meeting":{"user_id":{"_eq":"X-Hasura-User-Id"}}}</pre> kontrolü ile, "Column insert permissions": "meeting_id, user_id" seçili izin verildi.
                </p>
                <p>
                  backend\src\routes\webhooks\queries.js içine aşağıdaki sorguyu ekledik.
                  <pre>
export const GET_MEETING_PARTICIPANTS_REMINDER = `
  query meeting_participant($id: Int!) {
    meetings_by_pk(id: $id) {
      title
      meeting_date
      user {
        fullName
        email
      }
      participants(
        where: {
          is_approved: {
            _eq: true
          }
        }
      ) {
        user {
          email
        }
      }
    }
  }
`;
                  </pre>
                  bu sorguda bize sadece katılımını onaylayan katılımcıları verdi.
                </p>
                <p>
                  backend\src\routes\webhooks\index.js içinde katılımcılara ve meeting oluşturana mail gönderecek olan fonksiyonlar yazıldı. Dosyanın son hali:
                  <pre>
import express from "express";
import nodemailer from "nodemailer";
import moment from "moment";
import axios from "axios";

import Hasura from "../../clients/hasura";
import {
  GET_MEETING_PARTICIPANTS,
  GET_MEETING_PARTICIPANTS_REMINDER,
} from "./queries";

const router = express.Router();

const transporter = nodemailer.createTransport({
  service: "gmail",
  auth: {
    user: "myhasurabackendd@gmail.com",
    pass: "efuvzfpjocfdemnc",
  },
});

router.get("/meeting_created", (req, res) => {
  res.send("Hello World");
});

router.post("/meeting_created", async (req, res, next) => {
  const meeting = req.body.event.data.new;

  const { meetings_by_pk } = await Hasura.request(GET_MEETING_PARTICIPANTS, {
    id: meeting.id,
  });

  const title = meeting.title;
  const { fullName } = meetings_by_pk.user;
  const participants = meetings_by_pk.participants
    .map(({ user }) => user.email)
    .toString();

  const schedule_event = {
    // zamanlanmış görev eklemek için gereken obje
    type: "create_scheduled_event",
    args: {
      webhook: "https://backend-1-m7357908.deta.app/webhooks/meeting_reminder", //görev başlatılınca çalıştırılacak webhook
      schedule_at: moment(meetings_by_pk.meeting_date).subtract(2, "min"), // görev başlangıç tarihinden 2 dk çıkardık.
      payload: {
        //webhook tetiklendiğinde gönderilecek data
        meeting_id: meeting.id,
      },
    },
  };

  const add_event = await axios(
    "https://meeting-app-server.hasura.app/v1/query",
    {
      // endpoint olarak hasura endpointimizi sonuna qraphql yerine query yazarak kullanıyoruz.
      method: "POST",
      data: JSON.stringify(schedule_event),
      headers: {
        "x-hasura-admin-secret": process.env.HASURA_ADMIN_SECRET,
      },
    }
  );

  const event_data = add_event.data;

  const mailOptions = {
    from: "myhasurabackendd@gmail.com",
    to: participants,
    subject: `${fullName} sizi bir görüşmeye davet etti`,
    text: `${fullName} sizi ${title} adlı görüşmeye davet etti.`,
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      throw new Error(error);
    }

    res.json({ info });
  });
});

router.post("/meeting_reminder", async (req, res, next) => { // One-off Scheduled Events tetiklendiğinde yönleneceği endpoint route'u
  const { meeting_id } = req.body.payload; // One-off Scheduled Events ile gönderilen data

  const { meetings_by_pk } = await Hasura.request(
    GET_MEETING_PARTICIPANTS_REMINDER,
    {
      id: meeting_id,
    }
  );

  const title = meetings_by_pk.title;
  const { email } = meetings_by_pk.user;
  const participants = meetings_by_pk.participants.map(
    ({ user }) => user.email
  );

  participants.push(email);

  const mailOptions = {
    from: "myhasurabackendd@gmail.com",
    to: participants.toString(),
    subject: `"${title}" başlıklı görüşmeniz birazdan başlayacak`,
    text: `"${title}" başlıklı görüşmeniz iki dakika sonra başlayacak Katılmak için aşağıdaki bağlantıyı kullanın`,
  };

  transporter.sendMail(mailOptions, (error, info) => {
    if (error) {
      throw new Error(error);
    }

    res.json({ info });
  });
});

export default router;
                  </pre>
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>