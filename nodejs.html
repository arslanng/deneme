<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.JS</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
        }
    </style>
</head>
<body>
    <!-- Navbar Start -->
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">Node.JS</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2 class="text-center">Konu Listesi </h2>
            <ul style="max-height: 400px; overflow: auto;">
                <li><a href="#nedir">Node.js Nedir?</a></li>
                <li><a href="#asalSayi">Asal Sayılar Çalışması</a></li>
                <li><a href="#repl">REPL</a></li>
                <li><a href="#asenkronJs">Node.js'in Asenkron Yapısı</a></li>
                <li><a href="#callback">Callback Nedir?</a></li>
                <li><a href="#promise">Promise Nedir?</a></li>
                <li><a href="#asyncAwait">Async Await Yapısı</a></li>
                <li><a href="#module">Modül Kavramı</a></li>
                <li><a href="#fsModule">FS Modülü Kullanımı</a></li>
                <li><a href="#npm">NPM ve Package.json Kavramları</a></li>
                <li><a href="#requestResponse">Request - Response Döngüsü</a></li>
                <li><a href="#webSunucusu">Bir Web Sunucusu Oluşturmak</a></li>
                <li><a href="#express">Express.js Giriş</a></li>
                <h3>Pcat</h3>
                <li><a href="#start">PCAT Çalışma Ortamını Hazırlamak</a></li>
                <li><a href="#static">Statik Dosyalar - Middleware Giriş</a></li>
                <li><a href="#templateEngine">Template Engine Kavramı</a></li>
                <li><a href="#mongoDB">MongoDB Giriş</a></li>
                <li><a href="#MongoDBcrud">MongoDB - CRUD İşlemleri</a></li>
                <li><a href="#mongoose">Mongoose - CRUD İşlemleri</a></li>
                <li><a href="#requestBody">Request Body Nesnesi</a></li>
                <li><a href="#modelVeDinamikIcerik">Model ve Dinamik İçerik</a></li>
                <li><a href="#tekilSayfa">Tekil Fotoğraf Sayfaları</a></li>
                <li><a href="#gorselUpload">Görsel Yüklemek</a></li>
                <li><a href="#gorselUpdate">Fotoğraf Bilgisi Güncellemek</a></li>
                <li><a href="#gorselDelete">Fotoğraf Silmek</a></li>
                <li><a href="#MCV">MVC Yeniden Düzenleme</a></li>
                <li><a href="#pagination">Pagination (Sayfalama)</a></li>
                <li><a href="#atlasCloud">RENDER - MongoDB Atlas Deployment</a></li>

                <h3>SmartEdu</h3>
                <li><a href="#Ortam">SmartEdu Ortam Hazırlama</a></li>
                <li><a href="#httpStatus">HTTP Status Codes (HTTP Yanıt Durumu Kodları)</a></li>
                <li><a href="#template">Template Engine</a></li>
                <li><a href="#routing">Routing</a></li>
                <li><a href="#kursModeli">Kurs Modeli</a></li>
                <li><a href="#apiPostman">Postman ve API</a></li>
                <li><a href="#kursListeleme">Kursları Listelemek</a></li>
                <li><a href="#tekliKurs">Tekil Kurs Sayfası ve Slugify</a></li>
                <li><a href="#kategori">Kategori Oluşturmak ve Listelemek</a></li>
                <li><a href="#kayitSayfasiVeBcrypt">Kayıt Sayfası ve Bcrypt Paketi</a></li>
                <li><a href="#giris">Giriş Sayfası ve Giriş İşlemi</a></li>
                <li><a href="#session">Session Nedir?</a></li>
                <li><a href="#cikis">Çıkış İşlemi</a></li>
                <li><a href="#kullaniciSayfasi">Kişiye Özel İçerik</a></li>
                <li><a href="#ozelMiddleware">Özel Middleware</a></li>
                <li><a href="#kullaniciRolleri">Kullanıcı Rolleri</a></li>
                <li><a href="#courseCreate">Kurs Oluşturmak</a></li>
                <li><a href="#kursOgretmen">Kurs - Öğretmen İlişkisi</a></li>
                <li><a href="#kursOgrenci">Kurs - Öğrenci İlişkisi</a></li>
                <li><a href="#search">Search Alanı</a></li>
                <li><a href="#contactAndMail">İletişim Sayfası ve Mail Göndermek</a></li>
                <li><a href="#bildirim">Flash Bildirimleri</a></li>
                <li><a href="#dogrulama">Kayıt ve Kullanıcı Doğrulama</a></li>
                <li><a href="#hata">Bir hata ile karşılaştık</a></li>
                <li><a href="#deleteCourse">Kurs Silmek</a></li>
                <li><a href="#updateCourse">Kurs Güncellemek</a></li>
                <li><a href="#admin">Admin Alanı ve Kullanıcı Silmek</a></li>
                <li><a href="#category">Kategori Eklemek ve Silmek</a></li>
                <li><a href="#homePage">Anasayfa düzeni</a></li>
                <li><a href="#deployment">Deployment</a></li>
            </ul>

        </div>
        <div class="col-sm-9">
          <div class="row" id="nedir">
            <h1>Node.js Nedir?</h1>
            <p>
              Node.js, Chrome V8 JavaScript Engine'i temel alan bir JavaScript çalışma ortamıdır. Bu çalışma ortamı sayesinde bizler Javascript kodlarını kullanmak için tarayıcı kısıtlamalarından kurtulmuş oluruz. 
            </p>
    
            <h2>Nasıl Çalışır</h2>
    
            <h3>Event-Driven:</h3>
            <p>
              Node.js olay odaklı (event-driven) çalışır. Tek thread kullanmasından, yani aynı anda sadece bir işlem yapabilmesi nedeniyle node.js kendisinden istenilen işleri bir olay döngüsünün içerisinde değerlendirir.
            </p>
    
            <h3>Non-Blocking:</h3>
            <p>
              Node.js işlem sırasına koyduğu bir olayın tamamlanmasını beklemeden diğer olayı işleme alabilir, bunun sonucu olarak Node.js iş akışını engellemez.
            </p>
    
            <h3>Asynchronous:</h3>
            <p>
              Node.js asenkron (asynchronous) çalışır. Asenkron çalışma, kod akışının yukarıdan aşağıya ilerlemediği, işlemlerin birbirini beklemediği çalışma türüdür. Bu sayede işlem sırası olaya göre belirlenebilir.
            </p>
    
          </div>
          <div class="row" id="asalSayi">
            <h1>Asal Sayılar Çalışması</h1>
            <p>
              <code>
                function showPrimeNumbers(lownumber, highnumber){ <br>
                  for(let i = lownumber; i<=highnumber; i++){ <br>
                     let isPrime = true; <br>
                     for (let j = 2; j <= i; j++){ <br>
                      if (i%j===0 && j !==i){ <br>
                          isPrime = false <br>
                      } 
                     }  <br>
                     if(isPrime){ <br>
                      console.log(i); <br>
                     } 
                  }
              } <br>
              
              showPrimeNumbers(2, 9)
              </code> bize 2 ve 9 arasındaki asal sayıları verir. Bunu terminalde görmek için <code>node uygulama_adi</code> yazılır.
            </p>
    
            <h2>Terminalden veri almak</h2>
            <p>
              process nesnesi nodeJS e ait global nesnelerden biridir. Bize o anki işlemle ilgili bilgiler verir. <br>
              <code>
                console.log(process)
              </code> ifadesi js klasörüne ilave edilerek bu bilgilere ulaşılabilir. Çok fazla bilgi verir. Bir kısmı bize gerekir.
            </p>
            <p>
              <strong>process.argv</strong> özelliği bize node.exe ve çalışan js dosyasının parametrelerini verir. <br>
              <code>console.log(process.argv)</code> koda ilave olunca bu iki veriyi konsola 2 maddeli <strong>array</strong> olarak yazdırır.
            </p>
            <p>
              içinde <code>console.log(process.argv)</code> ifadesi bulunan kodu çalıştırırken terminalde boşluk bırakıp ifade girilirse boşluktan sonraki her maddeyi arraye ekler. <br>
              <code>
                node uygulama_adi 1 12
              </code>
            </p>
            <p>
              uygulamanın içindeki kod bir array metodu olan slice ile ilk iki parametresi alınmayacak şekilde yazılırsa çıktı olarak terminalde kodun sonuna yazılan değerleri verir. <br>
              <code>
                console.log(process.argv.slice(2));
              </code>
            </p>
            <p>
              <code>
                process.argv.slice(2)
              </code> değeri js üzerinden bir değişkene tanımlanır ise bu sayede terminalden veri alınabilir.
              
            </p>
            <h2>Terminalden Alınan Veriyi Programda Kullanma</h2>
            <p>
              asal sayı bulma kodunun başına <br>
              <code>
                const arguments = process.argv.slice(2);
              </code> ile alınacak değişkenler eklenir.
            </p>
            <p>
              Son kısma da çıktı almak için <br>
              <code>
                showPrimeNumbers(arguments[0], arguments[1]); 
              </code> uygulanır
            </p>
          </div>
          <div class="row" id="repl">
            <h1>REPL</h1>
            <p>
              Node.js Javascript çalışma ortamının terminal ekranı. 
            </p>
            <p>
              REPL ortamını başlatmak için node komutunu terminal ekranına yazmak yeterli olacaktır.
            </p>
            <p>
              <code>alert</code> benzeri bazı kodlar tarayıcıda çalışırken REPL içinde çalışmayabilir. Tam tersi de olabilir.
            </p>
            <h2>REPL Komutları - Açıklamaları</h2>
            <p>
              <strong>help</strong> - Tüm komutları listeler. <br>
              <strong>break</strong> - Çok satırlı ifadeden çıkar. <br>
              <strong>ctrl + c</strong> - Çalışan komutu durdurur.<br>
              <strong>ctrl + d</strong> - REPL ortamını sonlandırır.<br>
              <strong>save dosya_adi</strong> - REPL ortamındaki kodları dosyaya kaydeder.<br>
              <strong>load dosya_adi</strong> - Dosyadaki kodları REPL ortamına alır.
            </p>
          </div>
          <div class="row" id="asenkronJs">
            <h1>Node.js'in Asenkron Yapısı</h1>
            <p>
              Asenkron programlama uzun süren bir işlemi beklemeden diğer işlemlere devam edebilmektir, işlemlerin sırasıyla devam etme zorunluluğu yoktur. Önce bir dosya okuyalım, aaa ama bu dosya okumak uzun sürüyor, eee ne yapalım o zaman? Bu işlemin bitmesini beklemeden diğer işleme geçebiliriz. Bir işlem yapılırken diğer işlemler bloklanmaz.
            </p>
            <p>
              Node.js için temel amaç mümkün olan en kısa sürede beklemeden fazla sayıda işlem yapmaktır.
            </p>
            <p>
              Aynı anda başladığı işleri hangi sırayla sunacağını da <strong>olay döngüsü (event-loop)</strong> belirler.
            </p>
          </div>
          <div class="row" id="callback">
            <h1>Callback Nedir?</h1>
            <p>
              klasik js kod sırasına göre sıralı ilerler (senkron çalışma) ve aynı anda tek bir işlem yapar (single thread)
            </p>
            <p>
              Node.JS nin ise asenkron bir doğası vardır.
            </p>
            <p>
              Callback fonksiyonu başka bir fonksiyon içerisinde argüman olarak kullanılabilen fonksiyon anlamına gelmektedir.
            </p>
            <p>
              <code>
                const func1 = () => { <br>
                  console.log('func 1 tamamlandı') <br>
                  func2(); 
                };<br>
                const func2 = () => { <br>
                  console.log('func 2 tamamlandı') <br>
                  func3();
                }; <br>
                const func3 = () => { <br>
                  console.log('func 3 tamamlandı')
                };<br>
          
              func1();
              </code> bu kod çalıştığında önce func1 aktive olur. Sonra onun içine argüman olarak eklenen func2 aktive olur. Sonra onun içine argüman olarak eklenen func3 aktive olur.
            </p>
            <p>
              Örnekler için: <strong>callback.js</strong>
            </p>
    
          </div>
          <div class="row" id="promise">
            <h1>Promise Nedir?</h1>
            <p>
              Bir işlemin sonucunu temsil eden bir JS nesnesidir.
            </p>
            <p>
              Promise bir işlemin sonucunu temsil eden bir Javascript nesnesidir. Promise nesnesi Resolve ve Reject adında iki tane parametre alır ve olumlu durumlarda Resolve ile belirtilen işlemlerin, olumsuz durumlarda da Reject ile belirtilen işlemlerin yapılacağına dair güvence verir. Promise yapısı olumlu sonuçları .then(), olumsuz sonuçları da .catch() ile karşılar.
            </p>
            <p>
              <code>
                const promise1 = new Promise((resolve, reject) => { <br>
                  resolve('Veriler Alındı');<br>
                  reject('Bağlantı Hatası');
              });
              </code> ile promise kurulur.
            </p>
            <p>
    
            </p>
            <p>
              <code>
                promise1 <br>
                  .then(value => { <br>
                      console.log(value); <br>
                  });
              </code> ile resorve durumu yakalar.
            <p>
              <code>
                promise1 <br>
                  .catch(error => { <br>
                      console.log(error); <br>
                  });
              </code> ile reject durumu yakalar.
            </p>
            <p>
              <code>
                promise1 <br>
                  .then(value => { <br>
                      console.log(value); <br>
                  }).catch(error => { <br>
                      console.log(error); <br>
                  });
              </code> ile her iki durumu da yakalar.
            </p>
            <p>
              Örnek için <strong>promise.js</strong>
            </p>
          </div>
          <div class="row" id="asyncAwait">
            <h1>Async Await Yapısı</h1>
            <p>
              Async - Await yapısı ES8 ile birlikte gelmiştir ve Promise yapısının daha anlaşılır bir söz dizimi ile yazılmasıdır.
            </p>
            <p>
              Bir fonksiyon async anahtar kelimesi ile birlikte tanımlanırsa, fonksiyonun olumlu sonuçlanması sonucunda bir Promise döner. Bir async fonksiyon await anahtar kelimesi ile birlikte kullanılırsa ilgili Promise olumlu bir şekilde dönene kadar async fonksiyonunun çalışması bekletilir.
            </p>
            <p>
              asenkron fonksiyon (<code>async function</code>) içinde bekle (<code>await</code>) komutu ile daha önce <code>promise</code> kalıbında yazılan verinin <code>await</code> ten sonraki kısmı true ise <code>resolve</code> çıktısı, false ise <code>reject</code> tipik reject hatası alınır. Bu hatayı almamak için tüm yapı <code>try-catch</code> bloğuna alınır.
            </p>
            <p>
              özellikle sıralı işlemler için kullanılır.
            </p>
            
            <h2>Örnek</h2>
            <p>
              <code>
                function getData(data) { <br>
                  return new Promise((resolve, reject) => {<br>
                      console.log('Veriler alınmaya çalışılıyor..');<br>
                      if (data) {<br>
                          resolve('Veriler alındı');<br>
                      } else {<br>
                          reject('Veriler alınamadı')
                      }
                  })
                }<br><br>
              
                function cleanData(receivedData) {<br>
                  return new Promise((resolve, reject) => {<br>
                      console.log('Veriler düzenleniyor..');<br>
                      if (receivedData) {<br>
                          resolve('Veriler düzenlendi')<br>
                      } else {<br>
                          reject('Veriler düzenlenemedi')
                      }
                  })
                }<br>
              </code> ifadelerinde önce birinci fonksiyon, sonra 2. fonksiyon çalışmalıdır.
            </p>
            <p>
              Bu ifadelerin sırayla ve doğrulanarak ilerlemesi için <strong>promise</strong> yapsında: <br>
              <code>
                getData(true) <br>
                  .then(result => {<br>
                      console.log(result);<br>
                      return cleanData(true)<br>
                  }).then(result =>{<br>
                      console.log(result)<br>
                  }).catch(error => {<br>
                      console.log(error)<br>
                  });<br>
              </code> yapısı kullanılır.
            </p>
            <p>
              <strong>async-await</strong> yapısı için ise: <br>
              <code>
                async function processData(){ <br>
                  try{<br>
                      const receivedData = await getData(false);</code> // devam etmek için bunu bekle.<br><code>
                      console.log(receivedData);<br>
                      const cleanedData = await cleanData(true);</code> // devam etmek için bunu bekle.<br> <code>
                      console.log(cleanedData);<br>
                  } catch(error) {<br>
                      console.log(error)
                  }
                  }<br><br>
                  
                  
                  processData();
              </code> kullanılır.
            </p>
    
    
            
          </div>
          <div class="row" id="module">
            <h1>Modül Kavramı</h1>
    
            <h2>Modül Nedir?</h2>
            <p>
              Node.js uygulaması farklı görevleri olan farklı Javascript dosyalarından oluşur ve Node.js içerdiği tüm Javascript dosyalarına bir modül olarak davranır. Modül genelde belirli özel bir işlevi olan Javascript dosyasıdır. Bu şekilde Node.js uygulamaya ait olan dosyaları farklı bölümlere ayırarak kodun daha modülarize olmasını ve aynı zamanda bu kod kontrolünün ve hata yakalamanın daha kolay olmasını sağlar.
            </p>
            
            <h2>Asal Sayılar Örneği</h2>
            <p>
              Burada daha önce üzerine konuştuğumuz asal sayılar örneğimizi daha modüler hale getirelim ve sonrasında diğer dosyaların bu modülümüze ulaşmasını sağlayalım.
            </p>
            <p>
              primeNumber.js => primeNumberModule.js adıyla yeniden kopyalandı ve dizenlendi
            </p>
            <p>primeNumberModule.js içinde: <br>
              <code>
                function showPrimeNumbers(lownumber, highnumber){<br>
                  for(let i = lownumber; i<=highnumber; i++){<br>
                     let isPrime = true;<br>
                     for (let j = 2; j <= i; j++){<br>
                      if (i%j===0 && j !==i){<br>
                          isPrime = false
                      }
                     } <br>
                     if(isPrime){<br>
                      console.log(i);
                     }
                  }
              }<br><br>
              
              
              module.exports = {showPrimeNumbers}; 
              </code>Bu işlem ile fonksiyonu diğer dosyaların kullanımına açıyoruz. {} içine aralarına virgül koyarak birden fazla fonksiyon export edilebilir.
            </p>
            <p>
              Başka bir js dosyası içinde: <br>
              <code>
                const primeNumbers = require('./primeNumbersModule');
              </code> değişkene modül atanır. <br>
              <code>
                primeNumbers.showPrimeNumbers(10,22);
              </code> değişken üzerinden fonksiyon çağırılır.
            </p>
            <p>
              Birden fazla fonksiyon export ettiğimizde, örneğin: <br>
              <code>
                module.exports = {
                  showPrimeNumbers,
                  showFivePrimes
                } 
              </code><br>
              Çağırıken bir değişkene atayıp tek tek çağırabiliriz:
              <code>
                const primeNumbers = require('./primeNumbers');<br>
                primeNumbers.showPrimeNumbers(10, 22);<br>
                primeNumbers.showFivePrimes();
              </code><br>
              ya da object destructuring yöntemiyle parçalayıp kullanabiliriz. <br>
              <code>
                const { showPrimeNumbers, showFivePrimes } = require('./primeNumbers');<br>
                showPrimeNumbers(10, 22); <br>
                showFivePrimes();
              </code>
            </p>
    
            <h2>ES6 Import Söz Dizimi</h2>
            <p>
              Burada ES6 Import söz dizimini kullanarak da aynı işlemi yerine getirebiliriz. Fonksiyonu export ederken tek bir fonksiyon için default anahtar kelimesini kullanırız.
            </p>
            <p>
              <code>
                export default showPrimeNumbers;
              </code>
            </p>
            <p>
              import ederken ise bu kez dosya uzantısını kullanmak durumundayız.
            </p>
            <p>
              <code>
                import showPrimeNumbers  from './primeNumbers.js';
              </code>
            </p>
          </div>
          <div class="row" id="fsModule">
            <h1>FS Modülü Kullanımı</h1>
            <p>
              FS (File System) modülü Node.js'in dosya ve klasör işlemleri yaparken kullandığı bir çekirdek modülüdür. Buradaki çekirdek modülü kavramıyla Node.js yazılımıyla birlikte gelmesidir, tekrar oluşturulmasına gerek yoktur ve kullanıma hazırdır. FS modülünü kullanmak için: <br>
              <code>
                import { readFile } from 'node:fs';
              </code>
            </p>
            <p>
              yeni node sürümü <code>const fs = require('fs');</code> kodunu kabul etmiyor. ES6 ya göre yazılması için ise <strong>package.json</strong> içine <code>"type":"module",</code> eklenmesi gerekiyor.
            </p>
    
            <h2><code>"type": "module" </code>Hakkında</h2>
            <p>
              <strong>package.json</strong> içine <code>"type":"module",</code> eklenmesi <strong>require</strong> kullanımını engeller. Sadece ES6 ya göre olan yazımı kabul eder.
              <a href="https://isotropic.co/how-to-fix-referenceerror-require-is-not-defined-in-javascript/">Açıklama için tıklayınız</a>
            </p>
            <h2>Dosya Okumak</h2>
            <p>
              <code>
                readFile('../password.txt','utf8', (err, data) => { <br>
                  if (err) console.log(err); <br>
                  console.log(data); <br>
                  console.log('dosya okundu') 
                 }); <br>
              </code> ile password.txt içindeki veri konsola yazdırılır.
            </p>
    
            <h2>Dosya Oluşturmak</h2>
            <p>
              <code>
                import { writeFile } from 'node:fs';
              </code> ile writeFile import edildi. <br>
              <code>
                writeFile('../example.txt', 'kodluyoruzzz', 'utf8', (err)=>{ <br>
                  if (err) console.log(err); <br>
                  console.log('dosya başarılı bir şekilde oluşturuldu')
              }); 
              </code> ile example.txt oluşturuldu ve içine kodluyoruzzz yazıldı.
            </p>
            
            <h2>Dosyaya Veri Eklemek</h2>
            <p>
              <code>
                import { appendFile } from 'node:fs';
              </code> ile appendFile import edildi. <br>
              <code>
                appendFile('../example.txt', '\nkodluyoruz 2222', 'utf8', (err)=>{ <br>
                  if (err) console.log(err); <br>
                  console.log('yeni veri eklendi')
              }); 
              </code> ile yeni veri eklendi. verinin başındaki \n verinin son satırın altına yeni bir satıra yazılmasını sağlar.
            </p>
    
            <h2>Dosya Silmek</h2>
            <p>
              <code>
                import { unlink } from 'node:fs';
              </code> ile unlink import edildi. <br>
              <code>
                unlink('../example.json', (err)=>{ <br>
                  if(err) console.log('silemedim:('); <br>
                  else console.log('DOSYA SİLİNDİ'); 
                });
              </code> ile example.json silindi.
            </p>
    
            <h2>Klasör Oluşturmak</h2>
            <p>
              <code>
                import { mkdir } from 'node:fs';
              </code> ile mkdir import edildi. <br>
              <code>
                mkdir('../uploads/json', { recursive: true }, (err)=>{ <br>
                  if(err) console.log(err); <br>
                  else console.log('Klasörler Oluşturuldu');
                })
              </code> ile uploads/json dosyaları iç içe oluşturuldu. İç içe oluşturabilmek için <code>{ recursive: true },</code> eklendi. Tek bir klasör oluşturulacaksa buna gerel yok.
            </p>
    
            <h2>Klasör Silmek</h2>
            <p>
              <code>
                import { rmdir } from 'node:fs';
              </code> ile rmdir import edildi. <br>
              <code> 
                rmdir('../uploads', { recursive: true }, (err)=>{ <br>
                  if(err) console.log(err); <br>
                  else console.log('Klasörler silindi');
                });
              </code> ile uploads ve altındaki tüm klasörler silindi. Hem kökü hem de altındakileri silmek için <code>{ recursive: true },</code> eklendi. Tek bir klasör silinecek ise buna gerel yok.
            </p>
    
            <h2>Tüm File System Modülünü Tek Seferde İmport Etmek</h2>
            <p>
              <code>
                import * as fs from 'node:fs';
              </code> ile tüm fs import edilir. Ancak import edilen kodları kullanmak için başına <code>fs.</code> eklenir.
            </p>
            <p>
              Örnek: <br>
              <code>
                fs.appendFile('../example.txt', '\nkodluyoruz 2222', 'utf8', (err)=>{ <br>
                  if (err) console.log(err); <br>
                  console.log('yeni veri eklendi')
              });
              </code>
            </p>
          </div>
          <div class="row" id="npm">
            <h1>NPM ve Package.json Kavramları</h1>
            <p>
              NPM: node package manager. Hem kayıtlı paketlerin olduğu web sayfasını hem de paket indirmeyi sağlayan kod satırı uygulamasını içerir.
            </p>
            <p>
              paket: bir veya daha fazla modülden oluşan ve içerdiği modüller konusunda bilgi veren package.json dosyasına sahip bir klasör sistemi.
            </p>
            <p>
              İşimize yarayan paketler npm den hazır indirilebilir.
            </p>
    
            <h2>Package.json</h2>
            <p>
              Tüm bu kodları yönetmemiz için bizim bu bilgileri taşıyan bir dosyaya ihtiyacımız var, işte bu dosyanın adı package.json. Bu dosyayı oluşturmak için: <br>
              <code>
                npm init
              </code> yazıp gelen soruları cevaplayabiliriz. <br>
              <code>
                npm init -y
              </code> tüm sorular varsayılan olarak doldurulur.
            </p>
            <p>
              Artık npm den paket indirebiliriz.
            </p>
    
            <h2>Paket Yüklemek</h2>
            <p>
              <code>npm i paketAdi</code> veya <code>npm install paketAdi</code>
            </p>
            <p>
              Bu işlemden sonra package.json dosyasında <br>
              <code>
                "dependencies": { <br>
                  "paketAdi": "^4.17.1" <br>
                } 
              </code> benzeri bir ifade yer alır.
            </p>
    
            <h2>Paket Silmek</h2>
            <p>
              <code>
                npm uninstall paketAdi
              </code>
            </p>
    
            <p>
              Dosya olarak silinen veya gite aktarılmadan bırakılan bağlı paketleri yüklemek için: <br>
              <code>
                npm install
              </code> <br>Bu nedenle paket dosyalarını git'e aktarmaya gerek yoktur.
            </p>
    
            <h2>NPM İçine Kısayol Ekleme</h2>
            <p>
              <code>
                package.json
              </code> dosyası içine
              <code>
                "script"
              </code> kısmına istediğimiz kısayolu
              <code>
                "kisayolAdi": "dosyaYolu"
              </code> şeklinde yazabiliriz. <br>
              Kullanmak için komut satırına: <br>
              <code>
                npm kisayolAdi
              </code> yazılır.
            </p>
          </div>
          <div class="row" id="requestResponse">
            <h1>Request - Response Döngüsü</h1>
            <p>
              Node.js ile yazılan bir web uygulaması temelde bir request - response (istek - cevap) döngüsüdür. Bizler internet tarayıcımıza www.google.com yazmakla, aslında uzaktaki sunucuya bir request gönderiyoruz. Uzaktaki sunucu ise bize gördüğümüz Google sayfasını göstererek bir response dönüyor.
              <br><br>
              Sayfa > incele > ağ yaptığımızda: Request HEADERS içerisinde yaptığımız istek, Response HEADERS içerisinde ise aldığımız cevap ile ilgili bilgiler taşınır. Bunlardan bazıları istek metodu, remote address, cantent-type, path vs..
            </p>
    
            <h2>IP Address</h2>
            <p>
              Sunucunun sahip olduğu IP (Internet Protocol) adresi sunucuya ulaşmamızı sağlar. Aslında biz www.google.com yazmakla arka plandaki DNS sunucusu yardımıyla rakamlardan oluşan IP adresine ulaşır ve chunk ismi verilen parçalar halinde karşı sunucudaki web sayfası kendi bilgisayarımızda gösterilmeye başlar.
            </p>
            
            <h2>TCP - IP Protokolü</h2>
            <p>
              TCP/IP (Transmission Control Protocol/Internet Protocol), istemci - sunucu arasında veri iletme, alma birimleri arasında organizasyonu sağlayan, böylece bir yerden diğerine veri iletişimini olanaklı kılan ve farklı protokollerden oluşan yapıya verilen genel addır.
            </p>
    
            <h2>HTTP</h2>
            <p>
              Sunucu ile istemci arasında iletişim için kullanılan protokoldür.
            </p>
            <p>
              <strong>https</strong> http protokolünün ek güvenlik önlemlerine sahip versiyonudur.
            </p>
    
            <h2>Status Code</h2>
            <p>
              İstemci ile sunucu arasındaki iletişimin başarılı kurulma durumunu gösterir. <br>
              Örn: 404: sayfa bulunamadı.
            </p>
          </div>
          <div class="row" id="webSunucusu">
            <h1>Bir Web Sunucusu Oluşturmak</h1>
            <p>
              Node.js ile bir web sunucusu oluşturmanın çeşitli yolları vardır ve biz burada başlangıç olarak Node.js çekirdek modülü olan "http" modülünü kullanacağız. server.js dosyası oluşturup önce bu modülü çağıralım.
            </p>
            <p>
              <code>
                import * as http from 'node:http';
              </code>
            </p>
    
            <h2><code>createServer</code></h2>
            <p>
              http modülü ile bir web sunucusu oluşturmak için createServer metodunu kullanacağız. createServer metodu, callback fonksiyon parametreleri olarak request ve response nesnelerini (request - response döngüsünün elemanları) alır. Doğal olarak biz bir web sunucusu oluşturuyorsak bu sunucumuz üzerinde isteklerde bulunmak ve bunlara gerekli cevapları almak isteriz.
            </p>
            <p>
              <code>
                const server = http.createServer((req, res)=>{
              </code> <br>
              <code>
                const url = req.url;
              </code> ile istek yapılan url alınır <br>
              <code>
                if(url === '/'){
                  res.writeHead(200, {'Content-Type': 'text/html'});
              </code> ile status code ve tipi belirtilir <br>
              <code>
                res.write('İndex Sayfası');
              </code> ile cevap iletilir. Cevap tipi html olarak bildirildiği için cevap html elementi olarak da yazılabilir. <br>
              <code>
              } else if (url === '/about'){ <br>
                res.writeHead(200, {'Content-Type': 'text/html'}); <br>
                res.write('Hakkımda Sayfası'); <br>
            } else if (url === '/contact'){ <br>
                res.writeHead(200, {'Content-Type': 'text/html'}); <br>
                res.write('İletişim Sayfası'); <br>
            } else { <br>
                res.writeHead(404, {'Content-Type': 'text/html'}); <br>
                res.write('404 Sayfa Bulunamadı'); 
            }
              </code><br>
              <code>
                res.end();
              </code> ile cevap sonlandırılır <br>
              <code>
              });
              </code>
            </p>
    
            <h2>Port Belirlemek</h2>
            <p>
              Biz kendi bilgisayarızımı sunucuya çevirdik ve aşağıdaki kod ile portu belirttik
            </p>
            <p>
              <code>
                const port = 3000; <br>
                server.listen(port, ()=>{ <br>
                  console.log(`Sunucu Port ${port} de başlatıldı.`);
                });
              </code>
            </p>
            <p>
              konsola <code>node webSunucusu</code> yazdığımız anda <strong>localhost:3000</strong> adresi için sunucumuz hazır.
            </p>
          </div>
          <div class="row" id="express">
            <h1>Express.js Giriş</h1>
            <p>
              Express.js, Node.js üzerine yazılmış bir web çatısıdır. Express bize node.js ile yazması biraz karmaşık olan işlemleri daha basit bir şekilde oluşturmamızı sağlar. 
            </p>
            <p>
              express'i kurmak için konsola önce <br>
              <code>npm init</code> (:daha önce yapılmadıysa) <br>
              sonra <br>
              <code>npm i express</code> (express'in kurulumu) yazılır. 
            </p>
    
            <p>
              <code>
                import express from 'express';
              </code> ile import edilir. <br>
              <code>
                const app = express();
              </code> JS de fonksiyonlar da değişkenlere atanabiliyor.
            </p>
            <p>
              <code>
                app.get('/', (req, res) => { <br>
                  res.status(200).send('Hello World')
                });
              </code> ile ana sayfaya status code 200 olarak gönderilir ve Hello World aktarılır. <br>
              <code>
                app.get('/about', (req, res) => { <br>
                  res.status(200).send('About Sayfası')
                }); <br>
                app.get('/contact', (req, res) => { <br>
                  res.status(200).send('Contact Sayfası')
                });
              </code><br><br>
              <code>
                app.get('*', (req, res) => {
                  res.status(404).send('404 Sayfa Bulunamadı')
                });
              </code> ile ana sayfaya status code 404 olarak gönderilir ve 404 Sayfa Bulunamadı aktarılır.
            </p>
            <p>
              <code>
                const port = 3000; <br>
                app.listen(port, ()=>{ <br>
                  console.log(`Sunucu port ${port} da çalışmaya başladı`);
                });
              </code> ile port açılır.
            </p>
          </div>
          <div class="row pcatproject" style="background-color: rgba(128, 128, 128, 0.203);">
            <div class="row" id="start">
              <h1>PCAT Çalışma Ortamını Hazırlamak</h1>
  
              <h2>git ve github</h2>
              <p>Bunları biliyoruz</p>
  
              <h2>VSC içinde hazırlık</h2>
              <p>prettier - code formatter eklenti olarak indirilir.</p>
              <p>
                  ctrl + shift + p -> Prettier: Create Configuration File ile proje
                  dosyasında .prettierrc dosyası oluşturulur.
              </p>
              <p>
                  prettier'in çalışması için gereken dosya npm ile kurulur. <br />
                  <code> npm init </code> <br />
                  <code> npm install prettier -D --save-exact </code> --save-exact bizde
                  yüklü olan prettier ile aynı versiyonu indirmeyi sağlar.
              </p>
  
              <h2>.prettierrc Ayarları</h2>
              <p>
                  <code>"semi":true</code> her satırın sonuna noktalı virgül ekler.
                  <br />
                  <code>"singleQuote": true</code> tek tırnak içine almak için. <br />
                  <code>"trailingComma": "es5"</code>
              </p>
              <p>
                  Bu kurulum kodu yazdıktan sonra tümünü seçip sağ tıklayıp "format
                  document" yapınca kodun istediğimiz gibi görünmesini sağlar.
              </p>
  
              <h2>.gitignore</h2>
              <p>
                  hazır .gitignore dosyası oluşturmak için:
                  <a href="https://www.toptal.com/developers/gitignore">toptal.com/developers/gitignore</a>
              </p>
  
              <h2>Template Dosyası İndirmek</h2>
              <p>
                  Orjinali için:
                  <a href="https://templatemo.com/tm-552-video-catalog">https://templatemo.com/tm-552-video-catalog</a>
                  <br />
                  Biz hocanın düzenlediği versiyon ile çalışacağız.
              </p>
  
              <h2>Express Modülü</h2>
              <p>
                  <code> npm i express --save </code>
              </p>
              <p>
                  express <strong>dependencies</strong>. yani bu kodun çalışması için
                  elzem. <br />
                  prettier sie <strong>devDependencies</strong>. yani kodun çalışması
                  için gerekli değil. Kodu yazarken bize yardımcı.
              </p>
              <p>
                  <code>
                      const express = require('express'); <br />
                      const app = express();
                  </code>
                  ile express import edildi.
              </p>
              <p>
                  <code>
                      const port = 3000 <br />
                      app.listen(port, ()=>{ <br />
                      console.log(`Sunucu ${port} portunda başlatıldı`) })
                  </code>
                  3000 portu açıldı.
              </p>
              <p>
                  <code>
                      app.get('/', (req, res)=>{ <br />
                      res.send('Merhaba') })
                  </code>
                  ile kök dizine gönderildi.
              </p>
  
              <h2>NODEMON</h2>
              <p>
                  her işlemden sonra sunucuyu kapatıp açmayı otomatik hale getirmeye
                  yarar.
              </p>
              <p>
                  <code> npm install --save-dev nodemon </code>
              </p>
              <p>--save-dev: nodemon devDependenciestir.</p>
              <p>
                  çalışması için package.json -> script içine: <br />
                  <code> "start": "nodemon app.js" </code> eklenir.
              </p>
              <p>
                  terminale:
                  <code> npm start </code> yazarak aktifleştirilir. app.js her
                  kaydedildiğinde port baştan başlatılır.
              </p>
            </div>
            <div class="row" id="static">
                <h1>Statik Dosyalar - Middleware Giriş</h1>
    
                <h2>Middleware</h2>
                <p>req-res döngüsündeki herşeye Middleware denir.</p>
                <p>
                    Middlewarelar yularıdan aşağı sıra ile çalışır. req-res döngüsü
                    bitmeden bir sonrakine ilerleyemez. İlerlemeyi sağlama için
                    <code>next()</code> methodu kullanılır.
                </p>
                <p>get request yapısı da middlewaredir.</p>
    
                <h3>Örnek Middleware</h3>
                <p>
                    <code>
                        const myLogger = (req, res, next)=>{ <br />
                        console.log("Middleware log 1"); <br />
                        next() }
                    </code>
                    ile fonksiyonumuz tanımlanır. isteğe cevap olmadığından döngü next()
                    ile bozulur.
                </p>
                <p><code> app.use(myLogger); </code> ile fonksiyon kullanıma alınır.</p>
    
                <h2>Statik Dosyaları Kullanmak</h2>
                <p>
                    <code> app.use(express.static('public')) </code> ile ekspress için
                    statik dosyalarla çalışabileceği Middleware import edildi.
                </p>
                <p>
                    kodu kullanmak için public isimli dosya oluşturuldu ve statik dosyalar
                    içine yüklendi.
                </p>
    
                <h2>Response Olarak Dosya Göndermek</h2>
                <p>
                    <code>
                        app.get('/', (req, res) => { <br />
                        res.sendFile(path.resolve(__dirname, 'temp/index.html')); });
                    </code>
                </p>
                <p>
                    <code> path.resolve() </code> yöntemi, bir yol dizisini veya yol
                    segmentlerini mutlak bir yola çözümler. <br />
                    <code> __dirname </code> yürütülmekte olan kaynak dosyayı içeren
                    dizinin mutlak yoludur.
                </p>
                <p>
                    Kodun işe yaraması için core modül olarak: <br />
                    <code> const path = require('path'); </code> import edilir.
                </p>
            </div>
            <div class="row" id="templateEngine">
                <h1>Template Engine Kavramı</h1>
                <p>
                    Template engine bize değişen içeriği html kodu içerisinde dosya
                    uzantısı değiştirilerek kullanmamızı sağlar. Template engineler
                    sayesinde bir static dosyaları ve değieşen dinamik içeriği birlikte
                    kullanabiliriz. Farklı template engineler kullanılabiliriz, biz bu
                    çalışmamızda EJS template engine yapısını kullanacağız.
                </p>
                <p><strong>ejs </strong> Embedded JavaScript templates</p>
                <p>
                    Terminale: <br />
                    <code> npm install ejs </code>
                </p>
                <p>
                    JS koduna: <br />
                    <code> const ejs = require('ejs'); </code>
                </p>
                <p>
                    <code> app.set("view engine", "ejs"); </code> ile express'e template
                    engine olarak esj kullanacağımızı belirtiriz. Bu durumda esj views
                    klasörünün içine bakar. Bu nedenle bu isimde bir dosya oluşturup html
                    dosyaları içine konuldu. Dosya uzantıları ejs olarak değiştirildi.
                </p>
                <p>
                    JS içindeki <br />
                    <code> 
                        app.get('/', (req, res) => { </code><br />
                    <code style="text-decoration: line-through">
                        res.sendFile(path.resolve(__dirname, 'temp/index.html'));
                    </code>
                    yerine <br />
                    <code> 
                        res.render('index'); 
                    </code> yazılır. <br />
                    <code>
                        }); 
                    </code> diğer sayfalar da bu şablona göre eklenir.
                </p>
    
                <h2>Partials Klasörü</h2>
                <p>
                    Html olarak yazdığımız dosyalardaki ortak kodları birleştirmek için
                    kullanılır.
                </p>
                <p>views klasörünün içinde partials klasörü oluşturulur.</p>
                <p>
                    Daha önce .html olarak yazılmış ve .ejs ye dönüştürülmüş sayfalardaki
                    ortak kodlar için .ejs uzantılı dosyalar partials içinde oluşturulur.
                    <strong>Örnek:</strong> _header.ejs <br />
                    Bu dosyanın içine ortak olan header kodu yapıştırılır.
                </p>
                <p>
                    Yapıştırılan kod diğer sayfalardan silinir ve yerine: <br />
                    <code> <%- include('partials/_header') -%> </code> yazılır.
                </p>
                <p>Bu kalıp diğer kodlara da uyarlanır.</p>
                <p>
                    Bu sayede sayfaların ortak noktaları tek elden yönetilebilir. Örneğin
                    js kodunda link olarak verilen "/about" navbar içindeki "about.html"
                    yerine yazıldığında tüm sayfalarda geçerli olur.
                </p>
            </div>
            <div class="row" id="mongoDB">
                <h1>MongoDB Giriş</h1>
    
                <h2>SQL vs NoSQL</h2>
                <p>SQL tablolarla çalışır. NoSQL döküman tabanlıdır.</p>
                <p>JS json tabanlı NoSQL ile daha rahat çalışır.</p>
                <p>
                    SQL de tutulacak bilgiler tüm sütunlarda sabittir. NoSQL de böyle bir
                    şart bulunmaz.
                </p>
    
                <h2>MongoDB</h2>
                <p>setup ve path eklenmesi videoda var.</p>
            </div>
            <div class="row" id="MongoDBcrud">
                <h1>MongoDB - CRUD İşlemleri</h1>
    
                <h2>MongoDB Shell</h2>
                <p>
                    Dökümantasyon için
                    <a href="https://www.mongodb.com/docs/v4.4/">tıklayınız.</a>
                </p>
                <p><code>show dbs</code> mevcut veri tabanlarını gösterir.</p>
                <p>
                    <code>use</code> ile veri tabanları arasında geçiş yapılabilir ve yeni
                    veri tabanı oluşturulabilir. <br />
                    örnek yeni veri tabanı: <code>use pcat-test-db</code> oluşturulur. İçi
                    boşken db listesinde görünmez.
                </p>
                <p>
                    <code>
                        db.photos.insertOne( <br />
                        ... {title: "photo 1", description: "Photo desc lorem ipsum dolor!",
                        qty: 20} <br />
                        ... )
                    </code>
                    ile ilk örnek verimizi girdik. ve karşılığında: <br />
                    <code>
                        { "acknowledged" : true, <br />
                        "insertedId" : ObjectId("63a564428fa9a29730595280") }
                    </code>
                    çıktısını aldık.
                </p>
                <p>
                    <code> db.photos.find() </code> ile db içindeki photosta yer alan
                    veriye ulaştık. Çıktı olarak: <br />
                    <code>
                        { "_id" : ObjectId("63a564428fa9a29730595280"), "title" : "photo 1",
                        "description" : "Photo desc lorem ipsum dolor!", "qty" : 20 }
                    </code>
                    aldık. Biz belirmediğimiz halde <strong>"_id" : </strong>olarak
                    mongoDB her eklenen ögeye eşsiz ID ekler. Bu ID primary key görevi
                    görür.
                </p>
                <p>
                    <code> show collections </code> ile içinde olduğumuz dbin
                    collectionslarını gösterir.
                </p>
                <p>
                    Birden fazla veri ekleme örneği: <br />
                    <code>
                        db.photos.insertMany( [ <br />
                        ... {title: "photo 2", description: "Photo 2 desc", qty: 50}, <br />
                        ... {title: "photo 3", description: "Photo 3 desc", qty: 100}, ])
                    </code>
                </p>
                <p>
                    <code> db.photos.find({title: "photo 1"}) </code> title değeri photo 1
                    olan veriyi verir.
                </p>
                <p>
                    <code> db.photos.find({title: "photo 1", qty: 100}) </code> title
                    değeri photo 1 olan <strong>ve</strong> qty değeri 100 olan veriyi
                    verir. Böyle bir veri yoksa boş döner.
                </p>
                <p>
                    <code>
                        db.photos.find( <br />
                        {qty: {$lt: 200}} <br />
                        ).limit(2)
                    </code>
                    qty değeri 200 den az olan 2 veri getirir.
                </p>
                <p>
                    <code>
                        db.photos.updateOne( <br />
                        ... {title: "photo 1"}, <br />
                        ... { $set: {qty: 222}} )
                    </code>
                    title değeri photo 1 olan ilk verinin qty değeri 222 olarak
                    güncellendi.
                </p>
                <p>
                    db.photos.deleteOne( <br />
                    ... { qty: {$lt: 500}} )
                </p>
                    qty değeri 500 den küçük olan değerlerden birini siler.
                <p>
                    <strong>Asla Kullanma</strong> geri dönüşü yok. Onay sormadan siler.
                    <br /><br />
                    Önce doğru db yi sildiğinden emin ol. <br />
                    <code> use pcat-test-db </code> <br />sonra sil: <br />
                    <code> db.dropDatabase() </code>
                </p>
            </div>
            <div class="row" id="mongoose">
                <h1>Mongoose CRUD İşlemleri</h1>
                <p>Mongoose bir ODC (Object Document Mapper) aracıdır.</p>
                <p>
                    terminalde:
                    <code> npm i mongoose </code>
                </p>
                <p>test.js oluşturuldu.</p>
                <p>
                    test.js içine: <br />
                    <code>
                        const mongoose = require('mongoose'); <br />
                        const Schema = mongoose.Schema;
                    </code>
                    ile mongoose çağırıldı. ve Schema metodu değişkene atandı.
                </p>
                <p>
                    database e bağlanmak için: <br />
                    <code> mongoose.connect('mongodb://localhost/pcat-test-db'); </code>
                    pcat-test-db varsa bağlanır. Yoksa önce yaratır sonra bağlanır.
                </p>
                <p>
                    şema oluşturmak: <br />
                    <code>
                        const PhotoSchema = new Schema({ <br />
                        title: String, <br />
                        description: String, });
                    </code>
                </p>
                <p>
                    koleksiyon oluşturmak: <br />
                    <code> const Photo = mongoose.model('Photo', PhotoSchema); </code>
                    mongoose 'Photo' verisini alıp photos collectiona dönüştürüyor.
                </p>
                <p>
                    Koleksiyona veri eklemek: <br />
                    <code>
                        Photo.create({ <br />
                        title: 'Photo Title 1', <br />
                        description: 'Photo 1 desc. lorem ipsum', });
                    </code>
                </p>
                <p>
                    Verileri okumak: <br />
                    <code>
                        Photo.find({}, (err, data) => { <br />
                        console.log(data); });
                    </code>
                    ile veriler okunur ve konsola yazdırılır.
                </p>
                <p>
                    Verileri güncellemek: <br />
                    <code> 
                        const id = '63a57f07705931fa74b54a35'; 
                    </code> ile silinecek
                    verinin id numarası değişkene atanır. <br />
                    <code>
                        Photo.findByIdAndUpdate( <br> 
                        id, <br>
                        { title: 'Photo Title 1 updated', <br>
                        description: 'Photo desc 1 updated'}, <br>
                        { new: true }, <br>
                        (err, data) => { <br> 
                        console.log(data); } );
                    </code> ile veriler güncellenir. <code>{ new: true },</code> ile konsola yazılan datanın yeni olması
                    sağlanır.
                </p>
                <p>
                    Verileri silmek <br>
                    <code>
                    const id = '63a5861957e7afe19e3caa81'; <br>
                    Photo.findByIdAndDelete(id, (err, data) => { <br>
                      console.log('foto silindi');
                    }); 
                </code>
                </p>
            </div>
            <div class="row" id="requestBody">
                <h1>Request Body Nesnesi</h1>
                <p>
                    add.ejs içindeki form istediğimize uygun hale getirildi.
                </p>
                <p>
                    Form elementine method="POST" ve action="/photos" eklendi.
                </p>
                <p>
                    action="/photos" ile yapılan yönlendirmeyi add.js içinde //Routes altında bu kod ile yakalıyoruz: <br> 
                    <code>
                        app.post('/photos', (req, res) => { <br>
                            console.log(req.body); <br>
                            res.redirect('/') <br>
                          });
                    </code> ile gelen veri konsola yazdırılmaya çalışıldı ancak <code>undefined</code> alındı. Verinin okunması için 2 adet middleware kullanılır. <br>
                    <code>res.redirect('/')</code> yönlendirmesi ile req, res döngüsü sonlandırılır. 
                </p>
                <p>
                    verinin doğru okunması için middleware: <br>
                    <code>
                        app.use(express.urlencoded({extended:true}));
                    </code> url deki datayı okumamızı sağlar. <br>
                    <code>
                        app.use(express.json());
                    </code> url deki datayı jsona çevirir.                
                </p>
                <p>
                    Bu noktada formdan gelen bilgiyi yakaladık.
                </p>
            </div>
            <div class="row" id="modelVeDinamikIcerik">
                <h1>Model ve Dinamik İçerik</h1>
                <p>
                    kök dizine models klasörü ve içine Photo.js dosyası oluşturuldu.
                </p>
                <p>
                    Photo.js içinde <br>
                    <code>
                        const mongoose = require('mongoose'); <br>
                        const Schema = mongoose.Schema; <br>
                    </code> ile mongoose ve mongoose.Schema import edildi <br>
                    <code>
                        const PhotoSchema = new Schema({ <br>
                            title: String, <br>
                            description: String, <br>
                            image: String, <br>
                            dateCreated: { <br>
                                type: Date, <br>
                                default: Date.now, 
                            },
                        });
                    </code> ile şema oluşturuldu ve default date olarak o anki tarih atandı. <br>
                    <code>
                        const Photo = mongoose.model('Photo', PhotoSchema);
                    </code> ile Photo şemasını photos koleksiyonu oluşturmak için kullandık. <br> 
                    <code>
                        module.exports = Photo
                    </code> ile export ettik.
                </p>
                <p>
                    app.js içine: <br>
                    <code>
                        const Photo = require('./models/Photo');
                    </code> ile import edilir. <br>
                    <code>
                        const mongoose = require('mongoose');
                    </code> ile mongoose import edilir. <br>
                    <code>
                        mongoose.set('strictQuery', true); <br>
                        mongoose.connect('mongodb://localhost/pcat-test-db');
                    </code> ile database bağlantısı sağlanır. <br>
                    daha önce oluşturduğumuz ve formdan veri almamızı sağlayan <code>app.post(...)</code> kodu: <br>
                    <code>
                        app.post('/photos', async (req, res) => { <br>
                            await Photo.create(req.body) <br>
                            res.redirect('/')
                          });
                    </code> olarak düzenlenir. Bu sayede formdan gelen veri database e kaydedilir.
                </p>
                <p>
                    Database içindeki verinin okunup ilgili sayfaya gönderilmesi için veri template engine içinde gönderilir. <br>
                    <code>
                        app.get('/', async (req, res) => {
                    </code> <br>
                    <code>
                        const photos = await Photo.find({}).sort('-dateCreated')
                    </code> ile photos değişkenine databaseten gelen veri atanır. sort içine yazılan parametreye göre veriler sıralanır.<br>
                    <code>
                        res.render('index', {
                        photos: photos
                    </code> ile database üzerinden gelen veri kök sayfaya gönderilir. <br>
                    <code>
                            });
                        });
                    </code>
                </p>
                <p>
                    veriyi ilgili template engine içine gömmek için index.ejs içindeki kartların biri hariç hepsini sildik. Kalanı da kendi verimiz için kalıp olarak kullanacağız. 
                </p>
                <p>
                    .ejs içinde js kodu kullanmak için <code><%</code> ile <code>%></code> içine yazılır.
                </p>
                <p>
                    photos içindeki tüm verileri almak için .ejs içinde for döngüsü kurulur. <br>
                    <code>
                        <% for (let i = 0; i < photos.length; i++ ){ %> 
                    </code> ile for döngüsü başlatılır. <br>
                    <code>
    
                        &lt;div class="col-lg-4 col-md-6 col-sm-12 tm-catalog-item"&gt; <br>
                        &lt;div class="position-relative tm-thumbnail-container"&gt; <br>
                        &lt;img src="img/tn-01.jpg" alt="Image" class="img-fluid tm-catalog-item-img"&gt;    <br>
                        &lt;a href="video-page.html" class="position-absolute tm-img-overlay"&gt; <br>
                        &lt;i class="fas fa-play tm-overlay-icon"&gt;&lt;/i&gt; <br>
                        &lt;/a&gt; <br>
                        &lt;/div&gt;    <br>
                        &lt;div class="p-4 tm-bg-gray tm-catalog-item-description"&gt; <br>
                    </code>
                    <code>
    
                        &lt;h3 class="tm-text-primary mb-3 tm-catalog-item-title"&gt; &lt;%= photos[i].title %&gt;&lt;/h3&gt; 
                    </code> ile photos[i].title yerleştirildi. <br>
                    <code>
                        &lt;p class="tm-catalog-item-text"&gt;&lt;%= photos[i].description %&gt;&lt;/p&gt;
                    </code> ile photos[i].description yerleştirildi. <br>
                    <code>
                        &lt;/div&gt; <br>
                        &lt;/div&gt; <br>
                        
                        <% } %>
                    </code> ile for döngüsü sonlandırılır.
                    
                </p>
    
            </div>
            <div class="row" id="tekilSayfa">
                <h1>Tekil Fotoğraf Sayfaları</h1>
                <p>
                    MongoDB bizim için her kayıt için ıd oluşturuyor. Biz de onu kullanacağız.
                </p>
                <p>
                    index.ejs içinde daha önce düzenlediğimiz kodda altı çizili değişikliği yapıyoruz.<br>
                    <code>
                        <% for (let i = 0; i < photos.length; i++ ){ %> 
                    </code><br>
                    <code>
    
                        &lt;div class="col-lg-4 col-md-6 col-sm-12 tm-catalog-item"&gt; <br>
                        &lt;div class="position-relative tm-thumbnail-container"&gt; <br>
                        &lt;img src="img/tn-01.jpg" alt="Image" class="img-fluid tm-catalog-item-img"&gt;    <br>
                        &lt;a href=" <strong><span style="text-decoration: underline;">photos/<%= photos[i]._id %></span></strong> " class="position-absolute tm-img-overlay"&gt; <br>
                        &lt;i class="fas fa-play tm-overlay-icon"&gt;&lt;/i&gt; <br>
                        &lt;/a&gt; <br>
                        &lt;/div&gt;    <br>
                        &lt;div class="p-4 tm-bg-gray tm-catalog-item-description"&gt; <br>
                    </code>
                    <code>
    
                        &lt;h3 class="tm-text-primary mb-3 tm-catalog-item-title"&gt; &lt;%= photos[i].title %&gt;&lt;/h3&gt; 
                    </code><br>
                    <code>
                        &lt;p class="tm-catalog-item-text"&gt;&lt;%= photos[i].description %&gt;&lt;/p&gt;
                    </code><br>
                    <code>
                        &lt;/div&gt; <br>
                        &lt;/div&gt; <br>
                        
                        <% } %>
                    </code> <br>
                    Bu sayede verinin id sini yakalıyoruz.
                </p>
                <p>
                  app.js içine <br>
                  <code> 
                    app.get('/photos/:id', async (req, res) => {
                    </code> ile yakaladığımız id üzerinden req alıyoruz. <br>
                    <code>
                        const photo = await Photo.findById(req.params.id)
                    </code> ile ilgili ıd ye ait veriyi photo değişkenine atadık. <br>
                    <code>
                        res.render('photo', { <br>
                            photo
                        })
                        });
                    </code> ile değişkeni photo.ejs ye gönderdik.
                </p>
                <p>
                    photo.ejs içinde <br>
                    başlık kısmını <code><%= photo.title %></code> ile ve tanım kısmını <code><%= photo.description %></code> ile değiştiriyoruz.
                </p>
                <p>
                    sayfadaki css yapısındaki bozulmayı düzeltmek için dosya yolunu relative yapacağız. Bunun için partials dosyasında link olarak yazmadığımız tüm linklerin başına / koyuyoruz.
                </p>
    
            </div>
            <div class="row" id="gorselUpload">
                <h1>Görsel Yüklemek</h1>
                <p>
                    Bunun için express-fileupload modülünü kullanacağız. <br>
                    terminale: <br>
                    <code>
                        npm i express-fileupload
                    </code> <br>
                    app.js core module içine: <br>
                    <code>
                        const fileUpload = require('express-fileupload');
                    </code> <br>
                    app.js middleware içine: <br>
                    <code>
                        app.use(fileUpload());
                    </code> <br>
                    add.ejs input içine: <br>
                    <code>
                        name="image" type="file" 
                    </code> <br>
                    add.ejs form içine: <br>
                    <code>
                        encType="multipart/form-data"
                    </code> forma görsel yüklemeyi sağlar.
                </p>
                <p>
                    <code>
                        app.post('/photos', async (req, res) => {...}
                    </code> kodunun içine: <br>
                    <code>
                        console.log(req.files.image);
                    </code> <br>
                    yazılarak aşağıdaki çıktı konsola yazdırılır. <br>
                    <code>
                        {
                            name: 'car_unsplash.jpg', <br>
                            data: &lt;Buffer ff d8 ff e0 00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00 ff e1 00 22 45 78 69 66 00 00 4d 4d 00 2a 00 00 00 08 00 01 01 12 00 03 00 00 00 01 00 01 ... 637876 more bytes&gt;, <br>
                            size: 637926, <br>
                            encoding: '7bit', <br>
                            tempFilePath: '', <br>
                            truncated: false, <br>
                            mimetype: 'image/jpeg', <br>
                            md5: 'bb9f681142d25dee6e6f251188018846', <br>
                            mv: [Function: mv] 
                          }
                    </code>
                </p>
                <p>
                    Yukarıda bilgileri alabildiğimizi gördükten sonra app.post(...) aşağıdaki gibi düzenlenir. <br>
                    <code>
                        app.post('/photos', async (req, res) => {
                    </code> <br> <br>
                    <code>
                        const uploadDIR = 'public/uploads';
                    </code> ile upload edilecek dosya belirtilir.<br>
                    <code>
                        if(!fs.existsSync(uploadDIR)){
                    </code> eğer dosya yok ise: <br>
                    <code>
                        fs.mkdirSync(uploadDIR)
                    </code> oluştur. <br>
                    <code>
                    }
                    </code> Bu işlem tamamlanmadan devam edilmemesi için fonksiyon senkron (Sync) yazılır. <br> <br>
                    <code>
                        let uploadedImage = req.files.image;
                    </code> ile yüklenen dosyanın bilgileri uploadedImage değişkenine atanır.<br>
                    <code>
                        let uploadPath = __dirname + '/public/uploads/' + uploadedImage.name;
                    </code> ile yüklenen dosyanın yüklenme yolu değişkene atanır. Dosya oluşturmak için fs modülü import edilir ve kullanılır.<br>
                    <code>
                        uploadedImage.mv(uploadPath, async () => { 
                    </code> ile yüklenen dosyanın ekleneceği yer belirtilrir. <br>
                    <code>
                        await Photo.create({ <br>
                            ...req.body, <br>
                            image: '/uploads/' + uploadedImage.name,
                          });
                    </code> ile database üzerine veri eklenir. <br>
                    <code>
                        res.redirect('/');
                        });
                        });
                    </code> ile ana sayfaya yönlenirilir ve kod sonlandırılır.
                    <br><br>
                    Görselin indexte ve tekli foto sayfasında görünmesi için template içine görsel tanımlanır. <br>
                    <code>
                        img src="<%= photo.image %>"
                    </code>
    
                </p>
                <p>
                    index sayfasında son eklenenin en üstte görünmesi için <code>.sort()</code> kullanılır. <br>
                    <code>
                        app.get('/', async (req, res) => { <br>
                            const photos = await Photo.find({}).sort('-dateCreated');
                    </code> ile dateCreated verisine göre tersten (azalan) sıralanır. Başında "-" olmasaydı artan sıralanırdı. <br>
                    <code>
                        ......})
                    </code>
                </p>
    
    
    
            </div>
            <div class="row" id="gorselUpdate">
              <h1>Fotoğraf Bilgisi Güncellemek</h1> 
              <p>
                views içine edit.ejs oluşturulur.
              </p>
              <p>
                add.ejs içeriği kopyalanıp edit.ejs içine yapıştırılıp düzenlenir.
              </p>
              <p>
                photo.ejs içinde edit butonu link olarak düzenlenir: <br>
                <code>
                    &lt;<span style="text-decoration: underline;">a href="/photos/edit/&lt;%= photo._id %&gt;"</span> class="btn btn-primary p-0 mb-4 tm-btn-animate tm-btn-download tm-icon-download"&gt;&lt;span>Update Details&lt;/span&gt;<span style="text-decoration: underline;">&lt;/a&gt;</span>
                </code>
              </p>
              <p>
                app.js routes içine: <br>
                <code>
                    app.get('/photos/edit/:id', async (req, res) => { <br>
                        const photo = await Photo.findOne({ _id: req.params.id }); <br>
                        res.render('edit', { <br>
                          photo, <br>
                        }); 
                      });
                </code>
              </p>
              <p>
                edit.ejs içinde title ve description alanları düzenlenir: <br>
                <code>
                    &lt;div class="form-group"&lt; <br>
                        &lt;input type="text" name="title" <span style="text-decoration: underline;">value="&lt;%= photo.title %&gt;"</span> class="form-control rounded-0" placeholder="Photo Title"&gt; <br>
                      &lt;/div&gt; <br>
                      &lt;div class="form-group"&gt; <br>
                        &lt;textarea rows="8" name="description" class="form-control rounded-0" placeholder="Photo Description" <br>
                                  required&gt;<span style="text-decoration: underline;">&lt;%= photo.description %&gt;</span>&lt;/textarea&gt; <br>
                      &lt;/div&gt; 
                </code>   
              </p>
              <p>
                Bu noktada put request (değiştir) işlemine ihtiyacımız var ancak pek çok tarayıcı sadece get ve post request üzerinden çalışır. Bu nedenle put requesti post request ile yapacağız. Bunun için <strong>methıd-override</strong> modülünü kullanacağız.<br>
                konsola: <br>
                <code>
                    npm i method-override
                </code> <br>
                app.js içine core modul:<br>
                <code>
                    const methodOverride = require('method-override');
                </code> <br>
                app.js içine middleware:<br>
                <code>
                    app.use(methodOverride('_method'));
                </code>
              </p>
              <p>
                edit.ejs form etiketinde action: <br>
                <code>
                    action="/photos/<%= photo._id %>?_method=PUT"
                </code> olarak güncellendi. Bu sayede <code>method="POST"</code> olmasına rağmen yöntem PULL olarak request edildi.
              </p>
              <p>
                edit.ejs formdan gelen put requesti karşılama için add.js router içine: <br>
                <code>
                    app.put('/photos/:id', async (req, res) => {
                </code> <br>
                <code>
                    const photo = await Photo.findOne({ _id: req.params.id }); 
                </code> <br>
                <code>
                    photo.title = req.body.title; <br>
                    photo.description = req.body.description; 
                </code> ile değişiklikleri ekledik. <br>
                <code>
                    photo.save(); 
                </code> ile değişiklikleri database e kaydettik. <br>
                <code>
                    res.redirect(`/photos/${req.params.id}`) 
                </code> ile fotoğrafın sayfasında döndük. <br>
                <code>
                });  
                </code>
              </p>
            </div>
            <div class="row" id="gorselDelete">
                <h1>Fotoğraf Silmek</h1>
                <p>
                    Delete butonunu kullanabilmek için buton link haline getirilir ve aşağıdaki düzenleme yapılır. <br>
                    <code>
                        &lt;<span style="text-decoration: underline;">a <br> 
                        href="/photos/&lt;%= photo._id %&gt;?_method=DELETE"</span>
                    </code> ile linkten delete request alınır.<br>
                    <code>
                        class="btn btn-danger p-0 tm-btn-animate tm-btn-download tm-icon-download"<br>
                    </code>
                    <code>    
                        <span style="text-decoration: underline;">onclick="return confirm('ARE YOU SURE?')"</span>
                    </code> ile delete işlemi için popup comfirm kutusu açılır.<br>
                    <code>
                        &gt;&lt;span&gt;Delete Photo&lt;/span&gt;<span style="text-decoration: underline;">&lt;/a&gt;</span>
                    </code>  
                </p>
                <p>
                    DELETE metodunun çalışması için middleware alanında kullanılacak metotların belirtilmesi gerekir. İlgili kod aşağıdakine modifiye edilir. <br>
                    <code>
                        app.use( <br>
                            methodOverride('_method', { <br>
                                methods: ['POST', 'GET'],
                    </code> ile gerekli metotlar eklenir. <br>
                    <code>
                        })
                        );
                    </code>
                </p>
                <p>
                    Delete requestin alınması, ve çalışması için app.js router alanına: <br>
                    <code>
                        app.delete('/photos/:id', async (req, res) => {
                    </code> ile delete request karşılanır. <br>
                    <code>
                        const photo = await Photo.findOne({ _id: req.params.id });
                    </code> ile silinecek data tanımlanır. <br>
                    <code>
                        let deletedImage = __dirname + '/public' + photo.image;
                    </code> ile silinecek dosyanın yolu tanımlanır. <br>
                    <code>
                        fs.unlinkSync(deletedImage);
                    </code> ile dosya silinir. <br>
                    <code>
                        await Photo.findByIdAndRemove(req.params.id);
                    </code> ile database'ten data silinir. <br>
                    <code>
                            res.redirect('/');
                        });
                    </code>
                </p>
                <p>
                    Bu noktada dosya eklemeden data girmeye çalışırsak hata alırız ve server donar. Bunu engellemek için <code>input type="file"</code> alanına <code>required</code> eklenir.
                </p>
                <p>
                    Aynı isimde iki dosya yüklediğimizde upload klasöründe tek dosya oluşuyor. Bunu engelleme için dosya adının başına id veya tarih (<code>Date.now()</code> vs) eklenip uniqe hale getirilebilir. Bunun için tarihi değişkene atamak mantıklı. Aksi takdirde tarihteki saniyelik sapma dosya adını değiştirir.<br>
                </p>
            </div>
            <div class="row" id="MCV">
                <h1>MVC Yeniden Düzenleme</h1>
    
                <h2>MVC Nedir?</h2>
                <p>
                    MVC - Model View Controller - uygulama kodunu Model, View ve Controller olmak üzere birbirine bağlı üç öğeye ayrılmasını içeren bir yazılım mimari yapısıdır.   
                </p>
    
                <h3>Model</h3>
                <p>
                    Uygulamanın veri yapısını ve veri tabanı ile ilişkisini tanımlar. Schema "şablon" yapısı sayesinde veri özellikleri belirlenir.
                </p>
    
                <h3>View</h3>
                <p>
                    Uygulamanın son kullanıcılara görünen bölümünü temsil eder. Son kullanıcıya gösterilecek veri özelleştirilebilir. 
                </p>
    
                <h3>Controller</h3>
                <p>
                    Son kullanıcıdan gelen isteklerin uygun View'e yönlendirilmesi kontrol edilir. İstek, cevap işleyicisi olarak da tanımlanır. 
                </p>
                <p>
                    Kök dizine controllers adında bir klasör oluşturuldu. İçine photoControllers.js dosyası oluşturuldu. app.js içindeki yönlendirme dosyaları bu dosyaya fonksiyon içine atılır. ve export edilir. Fonksiyonun olduğu photoControllers.js app.js içine import edilir. <br>
                    photoController içinde: <br>
                    <code>
                        exports.getAllPhotos = async (req, res) => { <br>
                            const photos = await Photo.find({}).sort('-dateCreated'); <br>
                            res.render('index', { <br>
                              photos: photos,
                            });
                          };
                    </code> ile asenkron fonksiyon app.js içinden taşınılır. <br>
                    <code>
                        const photoController = require('./controllers/photoControllers');
                    </code> ile photoControllers.js import edilir.<br>
                    yönlendirme için taşınan dosyalar app.js içindeki ilgili yerine import edildiği model ile taşınır. örn:
                    <code>
                        app.get('/', <span style="text-decoration: underline;">photoController.getAllPhotos</span> );
                    </code> ile fonksiyon çağırılır.
                </p>
                <p>
                    Bu işlem database ile photo fonksiyonunu yönettiğimiz tüm fonksiyonlara uygulanır.
                </p>
                <p>
                    Taşınan fonksiyonların çalışması için gereken modeller de photoControllers.js içine import edilir. <br>
                    <code>
                        const Photo = require('../models/Photo');
                    </code>
                </p>
                <p>
                    Sadece sayfa çağıran fonksiyonlar ise controllers/pageControllers.js içine taşınır.
                </p>
                <p>
                    Kodu taşıdıktan sonra dosya konumu değiştiği için dosya bağlantılarının da güncellenmesi gerekir.
                </p>
            </div>
            <div class="row" id="pagination">
                <h1>Pagination (Sayfalama)</h1>
                <p>
                    Tüm fotoğrafların anasayfada karşımıza çıkmamaıs için pagination (sayfalama) kullanılan yöntemlerden biridir.
                </p>
    
                <h2><code>req.query</code></h2>
                <p>
                    req.query bizim tarayıcı üzerinden yaptığımız sorgunun node.js üzerinden algılanmasını sağlar. <br>
                    sorgu örneği: tarayıcıda:<br>
                    <code>
                        http://localhost:3000/?user=test&pass=1234
                    </code> <br>
                    konsolda okumak için: ilgili sayfanın app.get fonksiyonuna:<br>
                    <code>
                        console.log(req.query);
                    </code> <br>
                    konsoldaki çıktı: <br>
                    <code>
                        { user: 'test', pass: '1234' } 
                    </code> şeklinde key-value alınır. Buradan alınan değere göre işlem yapılabilir.
                </p>
    
                <h2>PCAT Sayfalama</h2>
                <p>
                    photoControler.js içinde index sayfamızı yöneten asenkron fonksiyon aşağıdaki gibi düzenlenir: <br>
                    <code>
                        exports.getAllPhotos = async (req, res) => { <br>
                        const page = req.query.page || 1;    
                    </code> ile sayfadan page olarak alınacak sorgu page değişkenine tanımlanır. varsayılan olarak 1 atanır (bunun için veya anlamında || kullanılır.) <br>
                    <code>
                        const photosPerPage = 2; 
                    </code> bir sayfada görünmesi istenilen fotoğraf sayısı değişkene atanır. 
                </p>
                <p>
                    <code>
                        const totalPhotos = await Photo.find().countDocuments();
                    </code> ile toplam veri sayısı değişkene atanır.
                </p>
                <p>
                    <code>
                        const photos = await Photo.find({}) <br>
                        .sort('-dateCreated')
                        .skip((page-1) *photosPerPage)
                    </code> ile daha önceki sayfalarda gösterilmesi gerekenler atlanır. <br>
                    <code>
                        .limit(photosPerPage);   
                    </code> ile sayfada gösterilmek istenen kadar veri çekilir. fazlası çekilmez.
                </p>
                <p>
                    <code>
                        res.render('index', { <br>
                            photos: photos, <br>
                            current: page,
                    </code> ile mevcut sayfa bilgisi gönderilir. <br>
                    <code>
                        pages: Math.ceil(totalPhotos/photosPerPage)
                    </code> ile toplam sayfa bilgisi gönderilir. <br>
                    <code>
                    }); 
                    </code> <br>
                    <code>
                    };
                    </code>
                </p>
                <p>
                    index.ejs içindeki Catalog Paging Buttons alanı aşağıdaki gibi düzenlenir: <br>
                    <code>
                        <% if (pages>0){ %> 
                    </code> sayfa sayısı 0dan büyükse butonları ekler. <br>
                    <code>
                        &lt;ul class="nav tm-paging-links">
                    </code>
                    <code>
                        <% for (i=1; i<=pages; i++){ %>
                    </code> ile sayfa numaralarını çağırır. Bu işlemi toplam sayfa sayısına kadar tekrarlar. <br>
                    <code>
                        <% if(i == current){ %> 
                    </code> ile sayfa numarası açık olan sayfa ile aynı olan butonu aşağıdaki gibi gösterir. <br>
                    <code>
                        &lt;li class="nav-item active">&lt;a href="/?page=<%= i %>" class="nav-link tm-paging-link"><%= i %>&lt;/a>&lt;/li>
                    </code> Link olarak req.query ile page verisini gönderir. <br>
                    <code>
                        <% } else { %>
                    </code> ile yukarıdaki kurala uymayan sayfa numaralarını aşağıdaki gibi gösterir.  <br>
                    <code>
                        &lt;li class="nav-item">&lt;a href="/?page=<%= i %>" class="nav-link tm-paging-link"><%= i %>&lt;/a>&lt;/li>
                    </code> Link olarak req.query ile page verisini gönderir. <br>
                    <code>
                        <% } %> <br>
                        <% } %> 
                    </code> <br>
                    <code>
                        &lt;/ul>
                    </code> <br>
                    <code>
                        <% } %>
                    </code>
                </p>
            </div>
            <div class="row" id="atlasCloud">
                <h1>RENDER - MongoDB Atlas Deployment</h1>
    
                <h2>Atlas Cloud</h2>
                <p>
                    Atlas Cloud, mongoDB geliştiriceleri tarafından geliştirilen bir veritabanı bulut hizmetidir, <a href="https://account.mongodb.com/account/login?nds=true">https://account.mongodb.com/account/login?nds=true</a> adresinden giriş yapıyoruz.
                </p>
                <p>
                    sayfaya üye ol > ilerle > new project > create project > build a database > free > ayarlar > create 
                </p>
                <p>
                    kurulan cluster için > connect > connect your application <br>
                    çıkan ekranda yer alan "Add your connection string into your application code" altındaki link app.js içindeki mongoose lokal bağlantı kodunu atlasa yönlendirmek için kullanılır. <br>
                    <code>
                        mongoose.connect('mongodb+srv://arslan_ng:narniag7A.@cluster0.z8aaudl.mongodb.net/pcat-db?retryWrites=true&w=majority');
                    </code>
                </p>
                <p>
                  kablosuz ağ WLRN3 ve WLRN 2 ise bağlanmaz. WINET e geç. 
                </p>
                
                <h2>RENDER</h2>
                <p>
                    <a href="https://render.com/">https://render.com/</a>
                </p>
                <p>
                    üye ol > crate > Web Service 
                </p>
                <p>
                    github ile bağlıyoruz.
                </p>
                <p>
                    RENDER ortamının istediği portu seçebilmesi için:
                    <code>
                        const port = process.env.PORT || 5000;
                    </code>
                </p>
                <p>
                    package.json içinde script alanı: <br>
                    <code>
                        "scripts": { <br>
                            "start": "node app.js"
                          },
                    </code> olarak güncellendi. Bu şekilde nodemon modülü aradan çıkartıldı.
                </p>
                <p>
                    gereksiz yer kaplamaması için video banner fotoğraf ile değiştirildi. video silindi. upload klasöründeki resimler de silindi.
                </p>
                <p>
                    istenilen proje github üzerinden render tarafından çekildi.
                </p>
            </div>
          </div>
          <hr>
          <div class="row smartedu" style="background-color: rgba(198, 197, 197, 0.203);">
            <div class="row" id="Ortam">
              <h1>SmartEdu Ortam Hazırlama</h1>
              <p>
                  Hazır dosyaları temp içine aldık.
              </p>
              <p>
                  konsola: <br>
                  <code>
                      npm init
                  </code> <br>
                  konsola: <br>
                  <code>
                      npm i express
                  </code>
              </p>
              <p>
                  app.js içine: <br>
                  express import: <br>
                  <code>
                      const express = require('express'); <br><br>
                      const app = express();
                  </code> <br><br>
                  port için: <br>
                  <code>
                      const port = 3000; <br>
                      app.listen(port, ()=>{ <br>
                          console.log(`App started on port ${port}`)
                      })
                  </code>
              </p>
              <p>
                  konsola: <br>
                  <code>
                      npm i --save-dev nodemon
                  </code> veya
                  <code>
                      npm i -D nodemon
                  </code> geliştirme aracı olarak nodemon yükler.
              </p>
              <p>
                  package.json da "scripts" alanında test silinir ve <br>
                  <code>
                      "start": "nodemon app.js"
                  </code> ile nodemon üzerinden app.js start komutuna işlenir.
              </p>
              <p>
                  daha önceki projeden .prettierrc dosyası bu projeye kopyalanır. Bu sayede her sağ tıklayıp format document dediğimizde .js kod düzenlemesi daha düzenli görünür.
              </p>
              <p>
                  git reposite oluşturuldu ve github ile bağlandı.
              </p>
            </div>
            <div class="row" id="httpStatus">
                <h1>HTTP Status Codes (HTTP Yanıt Durumu Kodları)</h1>
                <p>
                    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">developer.mozilla.org/en-US/docs/Web/HTTP/Status</a>
                </p>
                <p>
                    HTTP status code o an yapılan işlem hakkında bilgi verir.
                </p>
                <h2>Sık Kullanılan Durum Kodları</h2>
                <ul style="list-style-position: inside;">
                    <li>200 - OK</li>
                    <li>201 - Created</li>
                    <li>404 - Not found</li>
                    <li>500 - Internal Server Error</li>
                    <li>400 - Bad Request</li>
                    <li>401 - Unauthorized</li>
                    <li>403 - Forbidden</li>
                    <li>501 - Not Implemented</li>
                </ul>
                <p>
                    örnek html status gönderimi: <br>
                    <code>
                        app.get('/', (req, res) => { <br>
                            res.status(200).send('index sayfası'); <br>
                          });
                    </code>
                </p>
    
            </div>
            <div class="row" id="template">
                <h1>Template Engine</h1>
                <p>
                    Konsola: 
                    <code>
                        npm i ejs
                    </code> ile ejs yüklenir <br>
                </p>
                <p> app js Template Engine alanına: <br>
                    <code>
                        app.set("view engine", "ejs");
                    </code> <br>
                    Statik dosyaları almak için app js Middlewares alanına: <br>
                    <code>
                        app.use(express.static("public"));
                    </code>  
                </p>
                <p>
                    kök dizine public klasörü oluşturulur ve tempin içindeki .html harici içine eklenir.               
                </p>
                <p>
                    kök dizine views klasörü oluşturulur ve .html dosyalar içine alınır. uzantılar .ejs ye çevirilir.
                </p>
                <p>
                    views içine partials klasörü oluşturulur. Bu alanda tüm sayfalarda ortak olacak kısımlar tutulur. <br>
                    _header.ejs <br>
                    _navigation.ejs <br>
                    _footer ejs gibi. <br>
                    Bunların içine tüm templatelerde ortak olacaklar atanır. sonra buradan çekilir. Bunun için: <br>
                    <code>
                        <%- include('partials/_header'); -%>
                    </code> kalıbı kullanılır.
                </p>
                <p>
                    partials içindeki linkler düzenlenir.
                </p>
                <p>
                    Navbar üzerinden aktif olan sayfanın linkini farklı göstermek için active klası kullanılır. Bunu dinamik olarak yapmak için önce page_name bilgisi app.js içinden response içinde gönderilir. Sonra bu bilgi _navigation.ejs içinde yakalanır ve koşul true ise active olarak dönmesi sağlanır. <br>
                    <code>
                        app.get('/', (req, res) => { <br>
                            res.status(200).render('index', { <br>
                              page_name: "index"
                            });
                          });
                    </code> ile page_name: 'index' olarak alınır. <br>
                    <code>
                        &lt;li class="nav-item &lt;%= page_name === 'index' && 'active' %>">&lt;a class="nav-link" href="/">Home&lt;/a>&lt;/li> <br>
                        &lt;li class="nav-item &lt;%= page_name === 'about' && 'active' %>">&lt;a class="nav-link" href="/about">About Us&lt;/a>&lt;/li>
                    </code> ile sayfa adı sınanır ve true ise active çıktısı verir.
                </p>
            </div>
            <div class="row" id="routing">
                <h1>Routing</h1>
                <p>
                    ileri okuma için <a href="https://expressjs.com/en/guide/routing.html">tıklayınız.</a>
                </p>
                <p>
                    controllers/pageController.js oluşturuldu.
                </p>
                <p>
                    app.js router alanında router fonksiyonların içindeki req-res fonksiyonlar pageController.js içine taşınır ve buradan export edilir.
                </p>
                <p>
                    routes/pageRouter.js içine pageController require edilir. Bu kısımda route işlemi yapılacağından express modülü de çağırılır.
                </p>
                <p>
                    pageController.js: <br>
                    <code>
                        const express = require('express') <br>
                        const pageController = require('../controllers/pageController')
                    </code> ile import işlemleri yapılır. <br>
                    <code>
                        const router = express.Router() 
                    </code>ile Router() fonksiyonu değişkene atanır. <br>
                    <code>
                        router.route('/').get(pageController.getIndexPage) <br>
                        router.route('/about').get(pageController.getAboutPage)
                    </code> ile route işlemleri tanımlanır. <br>
                    <code>
                        module.exports = router 
                    </code> ile değişkene tanımlanan fonksiyon export edilir.
                </p>
                <p>
                  app.js içine router modülü çağırılır. router alanı aşağıdaki gibi düzenlenir: <br>
                  <code>
                    app.use('/', pageRoute);  
                  </code> 
                </p>
            </div>
            <div class="row" id="kursModeli">
                <h1>Kurs Modeli</h1>
    
                <h2>DB Bağlantı</h2>
                <p>
                    konsola: <br>
                    <code>
                        npm i mongoose
                    </code>
                </p>
                <p>
                    app.js içine mongoose require edilir. <br>
                    <code>
                        const mongoose = require('mongoose');
                    </code> <br>
                    Database connect için: <br>
                    <code>
                        mongoose.connect('mongodb://localhost/smartedu-db').then(() => console.log('DB Connected!'));
                    </code>
                </p>
    
                <h2>Modeller</h2>
                <p>
                    Dinamik olmasını istediğimiz veriler için model oluşturulur.
                </p>
                <p>
                    Model adları genelde büyük yazılır.
                </p>
                <p>
                    models/Course.js oluşturuldu ve içine mongoose import edildi.
                </p>
                <p>
                    <code>
                        const mongoose = require('mongoose'); <br>
                        const Schema = mongoose.Schema;
                    </code> <br>
                    <code>
                        const CourseSchema = new Schema({ <br>
                            name: { <br>
                              type: String, 
                    </code>veri tipi string. <br>
                    <code>
                        unique: true,
                    </code> eşsiz <br>
                    <code>
                        required: true,
                    </code> doldurulması zorunlu. <br>
                    <code>
                    }, <br>
                    description: { <br>
                      type: String, <br>
                      required: true, <br>
                      trim: true,
                    </code> Baştaki ve sondaki boşlukları görmezden gel. <br>
                    <code>
                        createdAt: { <br>
                            type: Date,  
                    </code> veri tipi tarih. <br>
                    <code>
                        default: Date.now(), 
                    </code> varsayılan değer olarak işlemin yapıldığı tarihi alır. <br>
                    <code>
                    },
                });
                    </code> ile şema oluşturulur.
                </p>
                <p>
                    <code>
                        const Course = mongoose.model('Course', CourseSchema);
                    </code> ile model oluşturuldu <br>
                    <code>
                        module.exports = Course;
                    </code> ile export edildi.
                </p>
                
                <h2>Modeli Kullanmak</h2>
                <p>
                    controllers/courseController.js dosyası oluşturuldu. İçine: <br>
                    <code>
                        exports.createCourse = async (req, res) => {
                    </code> ile asenkron createCourse fonksiyonu export edilir. <br>
                    
                    <code>
                        try{
                    </code> işlemde hata varsa yakalaması için tüm işlem try-catch yapısına taşınır. <br>
                    <code>
                        const course = await Course.create(req.body); 
                    </code> ile yeni kurs yazılır. <br>
                    <code>
                        res.status(201)
                    </code> ile status code 201-created gönderilir. <br>
                    <code>
                        .json({
                            status: 'succest',
                            course
                        })
                    </code> diğer veriler hazır olmadığından şimdilik bu veri gönderilir. <br>
                    <code>
                    } catch (error) { <br>
                        res.status(400) 
                    </code> ile status code 400-bad request gönderilir. <br>
                    <code>
                        .json({
                            status: 'fail',
                            error,
                          });
                        }
                      };
                    </code>
                </p>
                <p>
                    routes/courseRoute.js oluşturuldu. içine: <br>
                    <code>
                        const express = require('express') <br>
                        const courseController = require('../controllers/courseController') <br>
    
                        const router = express.Router() <br>
    
                        router.route('/').post(courseController.createCourse)
                    </code> ile post request createCourse fonksiyonunu çalıştırır.
                    <code>
                        module.exports = router
                    </code>
                </p>
                <p>
                    app.js içine courseRoute import edilir. routes alanına: <br>
                    <code>
                        app.use('/courses', courseRoute);
                    </code> eklendi.
                </p>
            </div>
            <div class="row" id="apiPostman">
                <h1>Postman ve API</h1>
    
                <h2>API</h2>
                <p>
                    Application Program Interface
                </p>
                <p>
                    API'ler, iki yazılım bileşeninin belirli tanımlar ve protokoller aracılığıyla birbiriyle iletişim kurmasına olanak tanıyan mekanizmalardır. Örneğin, meteoroloji müdürlüğünün yazılım sistemi, günlük hava durumu verilerini içerir. Telefonunuzdaki hava durumu uygulaması, API'ler aracılığıyla bu sistemle "konuşur" ve telefonunuzda size günlük hava durumu güncellemelerini gösterir. 
                </p>
    
                <h2>Postman</h2>
                <p>
                    Frontend hazır değilken backend tarafını test etmek için kullanılır. requesti simüle eder ve gelen response u gösterir.
                </p>
                <p>
                    <a href="https://www.postman.com/downloads/">postman.com/downloads/</a> -> download ve setup
                </p>
                <p>
                    uygulama içinden + ile yeni untitled request oluşturulur. <br>
                    ilgili request seçilir ve gönderilecek url girilir. <br>
                    ilgili veriler body alanına json olarak yazılır. <br>
                    send ile gönderilir.
                </p>
                <p>
                    Verinin alınması için gelen url req.body üzerinden middleware ile işlenmeli. Bunun için courseController içine middleware olarak: <br>
                    <code>
                        app.use(express.json()) // for parsing application/json
                        app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded
                    </code>
                </p>
                <p>
                    gelen response uygulamada görülür.
                </p>
            </div>
            <div class="row" id="kursListeleme">
                <h1>Kursları Listelemek</h1>
                <p>
                    courses.ejs template engine göre düzenlenir. courses linki _navigation.ejs içinde güncellenir.
                </p>
                <p>
                    courseRoute.js içine: <br>
                    <code>
                        router.route('/').get(courseController.getAllCourses); 
                    </code> eklenir. Bu sayede "/courses" için get request yapılırsa courseController.getAllCourses çağırılır.
                </p>
                <p>
                    courseController.js içine: <br>
                    <code>
                        exports.getAllCourses = async (req, res) => { <br>
                            try { <br>
                              const courses = await Course.find();
                    </code> ile veritabanından tüm kurslar alınır. <br>
                    <code>
                        res.status(200).render('courses', { <br>
                            courses, <br>
                            page_name: 'courses' 
                          }); 
                    </code> courses.ejs, courses bilgisi ve page_name bilgisi gönderilir. <br>
                    <code>
                    } catch (error) { <br>
                        res.status(400).json({ <br>
                          status: 'fail', <br>
                          error,
                        });
                      }
                    }; 
                    </code>
                </p>
                <p>
                    courses.ejs içindeki kusrların gösterildiği taslaklardan biri bırakıldı. Kalanlar silindi. Bırakılan taslak aşağıdaki for döngüsü içine alındı. <br>
                    <code>
                        <% for(let i=0; i<courses.length; i++ ){ %> <br>
                            ... <br>
                            taslak <br>
                            ... <br>
                        <% } %>
                    </code> <br>
                    taslağın name kısmı: <br>
                    <code>
                        <%= courses[i].name %>
                    </code> <br>
                    desctiption kısmı: <br>
                    <code>
                        <%= courses[i].description.substring(0, 100) + "..." %>
                    </code> olarak güncellenir. Bu sayede get request ile alınan courses bilgisi kullanılmış olur. .substring(0, 100) metodu ile courses sayfasında description kısmında görünecek karakter sayısı sınırlandırılır.
                </p>
                
            </div>
            <div class="row" id="tekliKurs">
                <h1>Tekil Kurs Sayfası ve Slugify</h1>
    
                <p>
                    course-single.ejs adı course.ejs yapılır ve template engine'e uygun düzenlenir.
                </p>
                <p>
                    courses.ejs içindeki link: <br>
                    <code>
                        /courses/<%= courses[i]._id %>
                    </code>
                </p>
                <p>
                    _navigation.ejs, _header.ejs ve _footer.ejs içindeki lokal linklerin başına / eklenir ki ulaşılabilinsin.
                </p>
                <p>
                    courseRoute.js içinde: <br>
                    <code>
                        router.route('/:id').get(courseController.getCourse);
                    </code> yönlendirmesi yapılır. /courses/_id olarak gelen get request courseController.getCourse fonksiyonuna yönlendirilir.
                </p>
                <p>
                    courseController.js içine:
                    <code>
                        exports.getCourse = async (req, res) => { <br>
                            try { <br>
                              const course = await Course.findById({_id: req.params.id});
                    </code> ile request olarak gelen id deki course bilgisi course değişkenine atanır. <br>
                    <code>
                        res.status(200).render('course', { <br>
                            course, <br>
                            page_name: 'courses'
                          });
                        
                    </code> ile course.ejs render edilir ve course değişkenindeki bilgi gönderilir. <br>
                    <code>
                    } catch (error) { <br>
                        res.status(400).json({ <br>
                          status: 'fail', <br>
                          error,
                        });
                      }
                    };
                    </code>
                </p>
                <p>
                    course.ejs içinde uygun alanlara <br>
                    <code>
                        <%= course.name %>
                    </code> ve <br>
                    <code>
                        <%= course.description %>
                    </code> eklenir. Bu sayede course bilgisi sayfada dinamik olarak kullanılır <br>
                    Bu sayfadaki fotoğrafların düzgün çalışması için de img hrefin değişkeninin başına / eklenir.
                </p>
    
                <h2>Slugify</h2>
                <p>
                    Tekil kurs sayfalarını _id parametersi ile çağırdığımızda bu ID url de 6095037e031db830c0a724ee benzer _id parametresinin görünmesine neden olur. Bunun yerinde daha anlamlı olan bir slug ifadesinin bulunmasını isteriz. Bunun için slugify paketinden faydalanacağız.
                </p>
                <p>
                    terminale: <br>
                    <code>
                        npm i slugify
                    </code>
                </p>
                <p>
                    models/Course.js içine: <br>
                    <code>
                        const slugify = require('slugify');
                    </code> ile slugfy import edilir. <br>
                    modelin içine: <br>
                    <code>
                        slug:{ <br>
                            type: String, <br>
                            unique: true 
                          }
                    </code> ilave edilir. <br>
                    Modelin altına: <br>
                    <code>
                        CourseSchema.pre('validate', function(next){
                            this.slug = slugify(this.name, {
                              
                    </code> ile isim slug a çevirilir. Bu işlem için arrow fonksiyon kullanılmaz çünkü arrowda this alınmaz. <br>
                    <code>
                        lower: true,
                    </code> ile hepsi küçük harfe dönüştürülür. <br>
                    <code>
                        strict: true
                    </code> ile stirng olmayan karakterler atılır. <br>
                    <code>
                    }); <br>
                    next();
                    </code> ile fonksiyon bir sonrakine devam ettirilir. <br>
                    <code>
                    })
                    </code>
                </p>
                <p>
                    Sayfayı slug üzerinden request etmek için courses.esj içindeki link: <br>
                    <code>
                        /courses/<%= courses[i].slug %>
                    </code> olarak düzenlenir. <br>
                    Bunu alıp yönlendirecek olan router courseRoute.js içinde: <br>
                    <code>
                        router.route('/:slug').get(courseController.getCourse);
                    </code> olarak düzenlenir. <br>
                    requesti alıp response yapabilmesi için courseController.js içindeki getCourse fonksiyonunun ilgili kısmı: <br>
                    <code>
                        exports.getCourse = async (req, res) => { <br>
                            try { <br>
                              const course = await Course.findOne({slug: req.params.slug}); <br>
                              ....
                    </code> olarak düzenlenir.
                </p>
    
            </div>
            <div class="row" id="kategori">
                <h1>Kategori Oluşturmak ve Listelemek</h1>
                <p>
                    Kategori için model oluşturup, bu modeli course modeli ile bağlayacağız.
                </p>
                <p>
                    models/Category.js oluşturuldu. İçine: (Course.js model alındı.) <br>
                    <code>
                        const mongoose = require('mongoose'); <br>
                        const slugify = require('slugify'); <br>
                        const Schema = mongoose.Schema; <br><br>
    
                        const CategorySchema = new Schema({ <br>
                        name: { <br>
                            type: String, <br>
                            unique: true, <br>
                            required: true, <br>
                        },
                        slug: {
                            type: String, <br>
                            unique: true, <br>
                        },
                        }); <br><br>
    
                        CategorySchema.pre('validate', function (next) { <br>
                        this.slug = slugify(this.name, { <br>
                            lower: true, <br>
                            strict: true, <br>
                        }); <br>
                        next(); 
                        }); <br><br>
    
                        const Category = mongoose.model('Category', CategorySchema); <br><br>
    
                        module.exports = Category;
                    </code> <br>
                    Course.js <code>CourseSchema</code> içine: <br>
                    <code>
                        category: { <br>
                            type:mongoose.Schema.Types.ObjectId, <br>
                            ref:'Category' <br>
                          }
                    </code> ilave edilerek course ile category modelleri ilişkilendirilir.
                </p>
                <p>
                  controllers/categoryController.js oluşturuldu. içine: <br>
                  <code>
                    const Category = require('../models/Category') <br><br>
    
                    exports.createCategory = async (req, res) => { <br>
                      try { <br>
                        const category = await Category.create(req.body); <br><br>
                    
                        res.status(201).json({ <br>
                          status: 'succest', <br>
                          category, <br>
                        }); <br>
                      } catch (error) { <br>
                        res.status(400).json({ <br>
                          status: 'fail', <br>
                          error, <br>
                        }); <br>
                      }
                    };
                  </code> ile create fonksiyonu oluşturuldu.
                </p>
                <p>
                    routes/courseRoute.js oluşturuldu. içine: <br>
                    <code>
                        const express = require('express') <br>
                        const categoryController = require('../controllers/categoryController') <br><br>
    
                        const router = express.Router() <br><br>
    
                        router.route('/').post(categoryController.createCategory); <br><br>
    
                        module.exports = router
                    </code> ile post request create fonksiyonuna yönlendirildi.
                </p>
                <p>
                    app.js içine: categoryRoute import edildi. router alanına:<br>
                    <code>
                        app.use('/categories', categoryRoute);
                    </code> ilave edilir.
                </p>
                <p>
                    postman ile category verisi oluşturuldu. Sonra bu kategorilerle ilişkili course oluşturuldu.
                </p>
                <p>
                    Kategorileri courses sayfasında listelemek için courseController.js içine Category modeli import edilir. getAllCourses içine: <br>
                    <code>
                        const categories = await Category.find();
                    </code> ile categories değişkenine database içindeki ilgili veri tanımlanır. render fonksiyonu içine eklenerek response edilir. Bu cevap aşağıdaki for döngüsü ile courses.ejs içinde yakalanır.
                </p>
                <p>
                    courses.ejs içinde ilgili alan: <br>
                    <code>
                        &lt;h3 class="widget-title">Categories&lt;/h3> <br>
                &lt;ul> <br>
                  &lt;% for(let i=0; i&lt;categories.length; i++){ %> <br>
                  &lt;li>&lt;a href="/courses?categories=&lt;%= categories[i].slug %>">&lt;%= categories[i].name %>&lt;/a>&lt;/li> <br>
                  &lt;% } %> <br>
                &lt;/ul>
                    </code> olarak düzenlendi. link olarak verilen sorgu courseController.js içinde yakalanır ve sadece o kategorideki kursların gönderilmesini sağlar. Bunun için:
                </p>
                <p>
                    courseController.js içinde getAllCourses fonksiyonuna aşağıdaki ekleme yapılır. <br>
                    <code>
                        const categorySlug = req.query.categories;
                    </code> ile gönderilen query yakalanır. <br>
                    <code>
                        const category = await Category.findOne({slug: categorySlug})
                    </code> ile databaseten ilgili Category bulunur. <br>
                    <code>
                        let filter = {} <br>
                        if(categorySlug){ <br>
                          filter = {category:category._id}
                        } 
                    </code> ile queryden veri gelme durumu sorgulanır. Gelmediyse filter değişkeni boş kalır. Değilse slug bilgisi ile databaseten çekilen verinin _id değeri category keyine value olarak atanır.<br>
                    <code>
                        const courses = await Course.find(filter);
                    </code> ifadesi güncellenir. if döngüsünden filter dolu çıkarsa buna göre göndereceği verileri filtreler.
                </p>
            </div>
            <div class="row" id="kayitSayfasiVeBcrypt">
                <h1>Kayıt Sayfası ve Bcrypt Paketi</h1>
    
                <h2>Kayıt Sayfası</h2>
                <p>
                    İlk önce register sayfasını oluşturacağız. Buradaki tek amacımız sayfayı görebilmek olduğu için işlemleri pageController.js ve pageRoute.js ile yapacağız.
                </p>
                <p>
                    pageController.js içine: <br>
                    <code>
                        exports.getRegisterPage = (req, res) => { <br>
                            res.status(200).render('register', { <br>
                              page_name: "register" <br>
                            });
                        }
                    </code>
                </p>
                <p>
                    pageRoute.js içine: <br>
                    <code>
                        router.route('/register').get(pageController.getRegisterPage)
                    </code>
                </p>
                <p>
                    register.html register.ejs ye dönüştürülür ve template engine'e göre düzenlenir. _navigation.ejs'deki link düzenlenir: <br>
                    <code>
                        &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'register' && 'orange' %>" href="/register">&lt;span>&lt;i class="fa fa-user-plus" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li>
                    </code>
                </p>
                <p>
                    models/User.js dosyası oluşturulur. İçine: <br>
                    <code>
                        const mongoose = require('mongoose'); <br>
                        const Schema = mongoose.Schema; <br><br>
    
                        const UserSchema = new Schema({ <br>
                        name: { <br>
                            type: String, <br>
                            required: true, <br>
                        }, <br>
                        email: { <br>
                            type: String, <br>
                            required: true, <br>
                            unique: true, <br>
                        }, <br>
                        password: { <br>
                            type: String, <br>
                            required: true, <br>
                        } <br>
                        }); <br><br>
    
    
                        const User = mongoose.model('User', UserSchema); <br>
    
                        module.exports = User;
    
                    </code>
                </p>
                <p>
                    controller/authControler.js dosyası oluşturulur. İçine: <br>
                    <code>
                        const User = require('../models/User') <br><br>
    
                        exports.createUser = async (req, res) => { <br>
                        try { <br>
                            const user = await User.create(req.body); <br>
    
                            res.status(201).json({ <br>
                            status: 'succest', <br>
                            user, <br>
                            }); <br>
                        } catch (error) { <br>
                            res.status(400).json({ <br>
                            status: 'fail', <br>
                            error, <br>
                            });
                        }
                        };
                    </code> 
                </p>
                <p>
                    routes/userRoute.js oluşturulur. İçine: <br>
                    <code>
                        const express = require('express') <br>
                        const authController = require('../controllers/authController') <br><br>
    
                        const router = express.Router() <br><br>
    
                        router.route('/singup').post(authController.createUser); <br><br>
    
    
                        module.exports = router
                    </code>
                </p>
                <p>
                    app.js içine Routes alanına: <br>
                    <code>
                        app.use('/users', userRoute);
                    </code> eklendi.
                </p>
                <p>
                    register.ejs form alanı aşağıdaki gibi düzenlendi. <br>
                    <code>
                        &lt;form method=<u>"POST" action="users/singup"</u>>
                    </code>
                </p>
    
                <h2>Bcrypt</h2>
                <p>
                    Database'e gönderilen password bilgisini şifrelenmesini sağlar.
                </p>
                <p>
                    terminale: <br>
                    <code>
                        npm i bcrypt
                    </code>
                </p>
                <p>
                    models/User.ejs içine bcrypt import edilir. new Schema fonksiyonunu altına aşadaki middleware eklenir. <br>
                    <code>
                        UserSchema.pre('save', function(next){ <br>
                            const user = this; <br>
                            bcrypt.hash(user.password, 10, (error, hash) => { <br>
                              user.password = hash; <br>
                              next(); <br>
                            })
                          })
                    </code>
                </p>
            </div>
            <div class="row" id="giris">
                <h1>Giriş Sayfası ve Giriş İşlemi</h1>
    
                <h2>Giriş Sayfası</h2>
                <p>
                    pageController.js içine: <br>
                    <code>
                        exports.getLoginPage = (req, res) => { <br>
                            res.status(200).render('login', { <br>
                              page_name: "login" <br>
                            });
                        }
                    </code> <br>
                    eklenir
                </p>
                <p>
                    login.html, login.ejs ye dönüştürülür ve template engine'e göre düzenlenir.
                </p>
                <p>
                    _navigation.ejs içinde ilgili kısım: <br>
                    <code>
                        &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'login' && 'orange' %> mr-2" href="/login">&lt;span>&lt;i class="fa fa-sign-in" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li>
                    </code> olarak düzenlenir.
                </p>
                <p>
                    pageRoute.js içine: <br>
                    <code>
                        router.route('/login').get(pageController.getLoginPage);
                    </code> eklenir.
                </p>
    
                <h2>Giriş İşlemi</h2>
                <p>
                    authController.js içine: <br>
                    <code>
                        const bcrypt = require('bcrypt');
                    </code> ile bcrypt import edilir. <br>
                    <code>
                        exports.loginUser = async (req, res) => { <br>
                            try { <br>
                              const {email, password} = req.body;
                    </code> ile formdan email ve password bilgisi alınır. <br>     
                    <code>
                              let user = await User.findOne({email: email})
                    </code> ile email bilgisi ile db üzerinde user olma durumu kontrol edilir. <br>
                    <code>
                                if(user){ <br>
                                  bcrypt.compare(password, user.password, (err, same) =>{
                    </code> user var ise password bilgisinin eşleşmesi kontrol edilir. <br>
                    <code>
                                    if(same){ <br>
                                      // USER SESSION br
                                      res.status(200).send("you are logged in")
                    </code>password bilgisi eşleşiyorsa "you are logged in" bilgisi sayfaya gönderilir. Daha sonra buraya başka işlem gelecek. <br>
                    <code>
                                    }
                                  })
                                }
                                <br>
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              });
                            }
                          };
                    </code>
                </p>
                <p>
                    authController.js için bilgi göndermesi için login.ejs içindeki form ve userRoute.js düzenlenir. <br>
                    login.ejs: <br>
                    <code>
                        &lt;form method="POST" action="users/login">
                    </code> olarak güncellenir. <br>
                    userRoute.js içine: <br>
                    <code>
                        router.route('/login').post(authController.loginUser);
                    </code> eklenir.
                </p>
            </div>
            <div class="row" id="session">
                <h1>Session Nedir?</h1>
                <p>
                    Session kavramı Türkçeye oturum olarak çevrilir ve kişiye özel içerik oluşturmak için kullanıcı bilgilerinin sunucu tarafında saklanmasını sağlayan araçlardır. Node.js tarafında express-session paketini kullanacağız. 
                </p>
                <p>
                    session datası sunucuda saklanır. sadece session id cookie içinde saklanır.
                </p>
                <p>
                    terminale: 
                    <code>
                        npm i express-session
                    </code>
                <p>
                    app.js içine import edilir. <br>
                    <code>
                        var session = require('express-session');
                    </code> <br>
                    app.js middleware alanına: <br>
                    <code>
                        app.use(session({ <br>
                            secret: 'keyboard_cat_rambo', <br>
                            resave: false, <br>
                            saveUninitialized: true, <br>
                            }))
                    </code> yazılır.
                </p>
                <p>
                    session bilgisini yakalamak için authController.js loginUser fonksiyonundaki //USER SESSION kısmına: <br>
                    <code>
                        req.session.userID = user._id
                    </code> eklenir. <br>
                    altındaki responsive komutu da: <br>
                    <code>
                        res.status(200).redirect('/');
                    </code> olarak index sayfasına yönlendirebilir. <br>
                    İşlemin başarılı olduğunu anlamak için pageController.js getIndexPage fonksiyonu içine <code>console.log(req.session.userID)</code> eklenebilir. 
                </p>
                <p>
                    Bazı bilgilerin loginden sonra bazılarının da loginden önce görünmesini isteriz. Bunun için:
                </p>
                <p>
                    app.js içine // Global Variable alanı oluşturup (middleware alanının üstüne) içine: <br>
                    <code>
                        global.userIN = null;
                    </code> yazılır. null değeri if içinde false verir. <br>
                    app.js route alanına: <br>
                    <code>
                        app.use('*', (req, res, next)=>{ <br>
                            userIN = req.session.userID; <br>
                            next();
                    </code> girilir. Bu sayede her durumda userIN, req.session.userID değeri varsa alır. yoksa yine null kalır. herhangi bir response olmadığından next() ile sonraki fonksiyona geçilir.
                </p>
                <p>
                    _navigation.ejs içinde login ve register butonlarının sadece userIN false iken çıkması için: <br>
                    <code>
                        &lt;% if(!userIN){ %> <br>
                            &lt;ul class="nav navbar-nav navbar-right"> <br>
                                &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'login' && 'orange' %> mr-2" href="/login">&lt;span>&lt;i class="fa fa-sign-in" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li> <br>
                                &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'register' && 'orange' %>" href="/register">&lt;span>&lt;i class="fa fa-user-plus" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li> <br>
                            &lt;/ul> <br>
                            &lt;% } %>
                    </code>
                </p>
                <p>
                    userIN true iken (kullanıcı login yaptığında) logout butonunu görünmesi için: <br>
                    <code>
                        &lt;% if(userIN){ %> <br>
                            &lt;ul class="nav navbar-nav navbar-right"> <br>
                                &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'login' && 'orange' %> mr-2" href="/login">&lt;span>&lt;i class="fa fa-sign-out" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li> <br>
                            &lt;/ul> <br>
                        &lt;% } %>
                    </code>
                </p>
                <p>
                    Aynı durum dashboard linki için kullanıcı varsa gösterilecek şekilde uyarlanır: <br>
                    <code>
                        &lt;% if(userIN){ %> <br>
                &lt;li class="nav-item">&lt;a class="nav-link" href="dashboard.html">Dashboard&lt;/a>&lt;/li> <br>
              &lt;% } %> 
                    </code>
                </p>
            </div>
            <div class="row" id="cikis">
                <h1>Çıkış İşlemi</h1>
                <p>
                    authController.js içine: <br>
                    <code>
                        exports.logoutUser = (req, res) => { <br>
                            req.session.destroy(() => { <br>
                              res.redirect('/'); <br>
                            });
                          };
                    </code> <br>
                    userRoute.js içine: <br>
                    <code>
                        router.route('/logout').get(authController.logoutUser) 
                    </code><br>
                    _navigation.ejs logout butonu linki: <br>
                    <code>
                        &lt;ul class="nav navbar-nav navbar-right">
                            &lt;li>&lt;a class="hover-btn-new log mr-2" <u>href="/users/logout"</u>>&lt;span>&lt;i class="fa fa-sign-out" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li>
                        &lt;/ul>
                    </code>
                </p>
    
                <h2>Connect Mongo</h2>
                <p>
                    Burada şöyle bir sorunumuz var, sunucuyu tekrar başlattığımızda ilgili session yani oturumu kaybediyoruz. Bunun engellemek için connect-mongo paketini indireceğiz. Bu sayede session bilgilerini mongoDB üzerinde saklayabilyoruz. Sonrasında ise bu session bilgisini kaydedeceğimiz veritabanı bağlantısını yazacağız.
                </p>
                <p>
                    terminale:
                    <code>
                        npm i connect-mongo
                    </code>
                </p>
                <p>
                    app.js içine import için:
                    <code>
                        const MongoStore = require('connect-mongo'); 
                    </code>
                    app.js middleware alanına: app.use(session({ içine
                    <code>
                        store: MongoStore.create({ mongoUrl: 'mongodb://localhost/smartedu-db' })
                    </code> parametre olarak eklenir.
                </p>
                <p>
                    Bu işlemden sonra sunucu bağlantısı kopup yeniden de bağlansa kullanıcı login ise login kalır.
                </p>
            </div>
            <div class="row" id="kullaniciSayfasi">
                <h1>Kişiye Özel İçerik</h1>
                <p>
                    dashboard.esj dosyası template engine'e göre düzenlenir.
                </p>
                <p>
                    işlem login işlemi ile yapılacağından işlemleri login işlemine uyumlu dosyalara yerleştirilecek.
                </p>
                <p>
                    authController.js içine: <br>
                    <code>
                        exports.getDashboardPage = (req, res) => { <br>
                            res.status(200).render('dashboard', { <br>
                              page_name: "dashboard" <br>
                            });
                          }
                    </code>
                </p>
                <p>
                    _navigation içinden dashboard linki: "/users/dashboard" olarak güncellenir ve class active bilgisi için düzenleme yapılır. <br>
                    <code>
                        &lt;li class="nav-item &lt;%= page_name === 'dashboard' && 'active' %>">&lt;a class="nav-link" href="/users/dashboard">Dashboard&lt;/a>&lt;/li>
                    </code>
                </p>
                <p>
                    userRoute.js içine: <br>
                    <code>
                        router.route('/dashboard').get(authController.getDashboardPage);
                    </code>
                </p>
                <p>
                    authController.js içindeki loginUser fonksiyonunun redirect adresi '/users/dashboard' olarak güncellendi.
                </p>
                <p>
                    dashboard sayfasına user bilgisini göndermek için authController.js içindeki getDashboardPage fonksiyonu aşağıdaki gibi güncellenir. <br>
                    <code>
                        exports.getDashboardPage = async(req, res) => { <br>
                            const user = await User.findOne({_id: req.session.userID}) <br>
                            res.status(200).render('dashboard', { <br>
                              page_name: "dashboard", <br>
                              user: user <br>
                            });
                          }
                    </code>
                </p>
                <p>
                    dashboard.ejs içine ilgili yere <br>
                    <code>
                        <%= user.name %>
                    </code> eklenerek bilgi sayfaya yerleştirilir.
                </p>
    
    
            </div>
            <div class="row" id="ozelMiddleware">
                <h1>Özel Middleware</h1>
                <p>
                    4login ve logout durumuna göre görünmesini istemediğimiz sayfaların linklerinin başka sayfaya redirect yapması için middleware yazacağız.
                </p>
    
                <h2>Logout durumunda kullanılmayacak linkler</h2>
                <p>
                    <strong>/users/dashboard</strong>
                </p>
                <p>
                    middleware/authMiddleware.js dosyası oluşturulur. İçine: <br>
                    <code>
                        const User = require('../models/User'); <br><br>
    
                        module.exports = (req, res, next) => {
                    </code> ile tüm içerik export edilir. <br>
                    <code>
                    User.findById(req.session.userID, (err, user) => {
                    </code> ile user sorgulanır. <br>
                    <code>
                        if (err || !user) return res.redirect('/login');
                    </code> user yoksa '/login' sayfasına yönledirilir. <br>
                    <code>
                            next();
                        });
                        };
                    </code> ile if geçersizse sonraki fonksiyona geçilir.
                  
                </p>
                <p>
                    userRoute.js içine authMiddleware import edilir. <br>
                    <code>
                        const authMiddleware = require('../middlewares/authMiddleware');
                    </code>
                </p>
                <p>
                    userRoute.js dashboard route fonksiyonu aşağıdaki gibi güncellenir. <br>
                    <code>
                        router.route('/dashboard').get(authMiddleware, authController.getDashboardPage);
                    </code> ilk fonksiyon "authMiddleware" next alırsa (if geçersizse) işlem sonrakine geçer. Yoksa authMiddleware içindeki res.redirect('/login'); çalışır.
                </p>
    
                <h2>Login durumunda kullanılmayacak linkler</h2>
                <p>
                    <strong>
                        /login <br>
                        /register
                    </strong>
                </p>
                <p>
                    middleware/redirectMiddleware.js dosyası oluşturulur. İçine: <br> 
                    <code>
                        module.exports = (req, res, next) => { <br>
                            if (req.session.userID) return res.redirect('/'); <br>
                            next();
                        };
                    </code>
                </p>
                <p>
                    pageRoute.js içine redirectMiddleware import edilir. <br>
                    <code>
                        const redirectMiddleware = require('../middlewares/redirectMiddleware');
                    </code>
                </p>
                <p>
                    pageRoute.js içinde güncelleme yapıldı. 
                    <code>
                        router.route('/register').get(redirectMiddleware ,pageController.getRegisterPage); <br>
                        router.route('/login').get(redirectMiddleware ,pageController.getLoginPage);
                    </code>
                </p>
            </div>
            <div class="row" id="kullaniciRolleri">
                <h1>Kullanıcı Rolleri</h1>
                <p>
                    Önce models/user.js içine role bilgisi eklenir. <br>
                    <code>
                        role: { <br>
                            type: String, <br>
                            enum: ["student", "teacher", "admin"], <br>
                            defult: "student", <br>
                          },
                    </code>
                </p> 
                <p>
                    Bilginin alınması için register.ejs form içine: <br>
                    <code>
                        &lt;div class="offset-1 col-lg-10 col-md-10 col-sm-10"> <br>
                            &lt;select class="form-control" name="role" id=""> <br>
                                &lt;option>student&lt;/option> <br>
                                &lt;option>teacher&lt;/option> <br>
                            &lt;/select> <br>
                        &lt;/div>
                    </code>
                </p>
                <p>
                    middlewares/roleMiddleware.js içine: br
                    <code>
                        module.exports = (roles) => {
                    </code> fonksiyonun kullanıldığı yerde argüman olarak bu parametre (roles) array şeklinde kullanılacak. <br>
                    <code>
                            return (req, res, next) => { <br>
                                const userRole = req.body.role; <br>
                                if(roles.includes(userRole)) { <br>
                                    next(); <br>
                                } else { <br>
                                    return res.status(401).send('YOU CANT DO THIS');
                                }
                            }
                        }
                    </code> 
                </p>
                <p>
                    courseRoute createCourse yönlendirmesine admin veya teacher olma şartı konulur: <br>
                    <code>
                        router.route('/').post(roleMiddleware(["teacher", "admin"]), courseController.createCourse);
                    </code>
                </p>
                <p>
                    register ekranında kayıt sonrası login sayfasına yönlendirmesi için, authController.js içinde createUser respose değeri aşağıdaki gibi güncellenir. <br>
                    <code>
                        exports.createUser = async (req, res) => { <br>
                            try { <br>
                              const user = await User.create(req.body); <br>
                          
                              <u>res.status(201).redirect('/login')</u> <br>
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              });
                            }
                          };
                    </code>
                </p>
                <p>
                    user.role bilgisine göre /dashboard içinde içeriği ayarlamak için if(user.rple === '') kalıbı kullanılabilir. <br>
                    <code>
                        &lt;% if (user.role === 'student'){ %> <br>
                            &lt;div class="all-title-box"> <br>
                                &lt;div class="container text-center"> <br>
                                    &lt;h1>&lt;%= user.name %>&lt;span class="m_1">STUDENT&lt;/span>&lt;/h1> <br>
                                &lt;/div> 
                            &lt;/div> <br>
                        &lt;% } %>	 <br><br>
                        &lt;% if (user.role === 'teacher'){ %> <br>
                            &lt;div class="all-title-box"> <br>
                                &lt;div class="container text-center"> <br>
                                    &lt;h1>&lt;%= user.name %>&lt;span class="m_1">Teacher&lt;/span>&lt;/h1> <br>
                                &lt;/div> 
                            &lt;/div> <br>
                        &lt;% } %>	
                    </code>
                </p>
            </div>
            <div class="row" id="courseCreate">
                <h1>Kurs Oluşturmak</h1>
                <p>
                    dashboard.ejs if (user.role === 'student') iken görünecek kısmı yukarıda, if (user.role === 'teacher') iken görünecek kısmı aşağıda olacak şekilde tekrar düzenlenir.
                </p>
                <p>
                    dashboard.ejs teacher kısmına buton eklenir: <br>
                    <code>
                        &lt;div class="col-lg-12 text-center "> <br>
                            &lt;button class="btn btn-lg btn-warning rounded-0 text-white" href="#" data-toggle="modal" data-target="#addCourse">&lt;span>CREATE NEW COURSE&lt;/span>&lt;/button> <br>
                        &lt;/div>
                    </code> <br>
                    data-target="#addCourse" sayfanın sonuna eklediğimiz modal'a işaret eder. modal tarafında id="addCourse" yer almalıdır.
                </p>
                <p>
                    Modal içinde daha önceden oluşturduğumuz kategorileri görebilmek için authController.ejs içine Categories import edilir. dashboard içine göndermek için getDashboardPage fonksiyonuna tüm categories çağırılır ve render kısmına eklenerek gönderilir. <br>
                    <code>
                        exports.getDashboardPage = async(req, res) => { <br>
                            const user = await User.findOne({_id: req.session.userID}) <br>
                            <u>const categories = await Category.find()</u> <br> 
                            res.status(200).render('dashboard', { <br>
                              page_name: "dashboard", <br>
                              user: user, <br>
                              <u>categories: categories</u>
                            });
                          }
                    </code> <br>
                    Bunu yakalamak için dashboard.ejs modal form kısmında for döngüsü kullanılır. <br>
                    <code>
                        &lt;select class="form-control" name="category"> <br>
                            <u>
                                &lt;% for (let i=0; i&lt; categories.length; i++) { %> <br>
                                &lt;option value="&lt;%= categories[i]._id %>">&lt;%= categories[i].name %>&lt;/option> <br>
                                &lt;% } %> <br>
                            </u>		
                            &lt;/select>
                    </code>
                </p>
                <p>
                    formu post ederken form tagı içinde: <br>
                    <code>
                        method="POST" action="/courses
                    </code> girilmeli
                </p>
                <p>
                    createCourse route aşamasında (courseRoute.ejs içinde) user.role sorgular. Bunu da form içinde göndermemiz gerekir. bunun için form alanının içine: <br>
                    <code>
                        &lt;div class="form-group"> <br>
                            &lt;div class="col-sm-12"> <br>
                                &lt;input type="hidden" name="role" class="form-control"  value="&lt;%= user.role %>"> <br>
                            &lt;/div> <br>
                        &lt;/div>
                    </code> <br>
                    ekleriz.
                </p>
                <p>Kurs yaratıldığında courses sayfasına yönlendirmesi için ilgili redirect createCourse fonksiyonunda düzenlenir: <br>
                <code>
                    exports.createCourse = async (req, res) => { <br>
                        try { <br>
                          const course = await Course.create(req.body); <br>
                          
                          res.status(201).<u>redirect('/courses');</u><br>
                        } catch (error) { <br>
                          res.status(400).json({ <br>
                            status: 'fail', <br>
                            error, <br>
                          });
                        }
                      };
                </code></p>
                <p>
                    Oluşturulan kursların /courses sayfasında son oluşturulanın en üstte görünmesi için courseController.js içinde getAllCourses fonksiyonudaki const courses = await Course.find(filter) ibaresine ".sort('-createdAt');" eklenir. <br> 
                    <code>
                        const courses = await Course.find(filter).sort('-createdAt');
                    </code>
                </p>
    
                <h2>Kullanılan Modal</h2>
                <p>
                    <code>
                        dashboard.ejs içinden görülebilir.
                    </code>
                </p>
            </div>
            <div class="row" id="kursOgretmen">
                <h1>Kurs - Öğretmen İlişkisi</h1>
                <p>
                    Course.js modeline <br>
                    <code>
                        user: { <br>
                            type:mongoose.Schema.Types.ObjectId, <br>
                            ref:'User' <br>
                          }
                    </code> eklenir.
                </p>
                <p>
                    courseController.ejs içinde createCourse içinde mevcut user yakalanır: <br>
                    <code>
                        const course = await Course.create({ <br>
                            name: req.body.name, <br>
                            description: req.body.description, <br>
                            category: req.body.category, <br>
                            user: req.session.userID <br>
                          });
                    </code>
                </p>
                <p>
                    user bilgisine uygun olan coursesi dashboarda eklemek için authController.ejs getDashboardPage fonksiyonuna courses aktif kullanıcıya göre filtrelenerek tanımlanır: <br>
                    <code>
                        const courses = await Course.find({user: req.session.userID})
                    </code> <br>
                    ve render fonksiyonu içinde gönderilir: <br>
                    <code>
                        res.status(200).render('dashboard', { <br>
                            page_name: "dashboard", <br>
                            user: user, <br>
                            categories: categories, <br>
                            <u>courses: courses</u> <br>
                          });
                    </code>
                </p>
                <p>
                    dashboard.ejs içinde courses bilgisi for döngüsü ile yakalanır ve her course için name ve description ilgili alanlara konulur. <br>
                    <code>
                        &lt;% for(let i=0; i&lt;courses.length; i++){ %> <br>
                        ....<br>
                        ....<br>
                        ... &lt;%= courses[i].name %>...<br>
                        ... &lt;%= courses[i].description %>...<br>
                        ....<br>
                        &lt;% } %>
                    </code>
                </p>
                <p>
                    Tekli kurs sayfasında course.user bilgisinden user.name alabilmek için courseController.ejs içinde getCourse fonksiyonunda aşağıdaki güncelleme yapılır: <br>
                    <code>
                        const course = await Course.findOne({ slug: req.params.slug })<u>.populate('user');</u>
                    </code> <br>
                    user name bilgisi için: <br>
                    <code>
                        <%= course.user.name %>
                    </code>
                </p>
            </div>
            <div class="row" id="kursOgrenci">
                <h1>Kurs - Öğrenci İlişkisi</h1>
                <p>
                    Öğrencinin kurslara kayıt olası, kendi dashboard sayfasında katıldığı kursları görmesi ve yönetmesi işlemleri
                </p>
                <p>
                    User.js içinde UserSchema alanına aşağıdaki course bilgisi eklenir: <br>
                    <code>
                        courses: [{ <br>
                            type: mongoose.Schema.Types.ObjectId, <br>
                            ref: 'Course' <br>
                          }]
                    </code> courses array olarak oluşturuldu. Course.js modeli ile bağlandı.
                </p>
    
                <h2>Enroll işlemi</h2>
                <p>
                    course.ejs içine aşağıdaki form eklendi: <br>
                    <code>
                        &lt;form method="POST" action="/courses/enroll"> <br>
                            &lt;input type="hidden" name="course_id" value="&lt;%= course._id %>"> <br>
                            &lt;button class="btn btn-large btn-warning text-white">&lt;span>ENROLL&lt;/span>&lt;/button> <br>
                        &lt;/form> <br>
                    </code>
                </p>
                <p>
                    courseController.js içinde aşağıdaki fonksiyon yazıldı: <br>
                    <code>
                        exports.enrollCourse = async (req, res) => { <br>
                            try { <br>
                              
                              const user = await User.findById(req.session.userID);</code> ile şu an aktif olan user bilgisi alındı. <br>
                    <code>
                              await user.courses.push({_id: req.body.course_id}); </code> ile tıklanılan sayfanın course_id bilgisi user.courses kısmına eklendi. <br>
                    <code>
                              await user.save();
                    </code> ile user için yapılan değişiklik kaydedildi. <br>
                    <code>
                        res.status(200).redirect('/users/dashboard');<br>
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              });
                            }
                          };
                    </code>
                </p>
                <p>
                    courseRoute.j içine aşağıdaki kod eklenerek course.ejs ile ourseController.enrollCourse fonksiyonu bağlandı.<br>
                    <code>
                        router.route('/enroll').post(courseController.enrollCourse);
                    </code>
                </p>
                <p>
                    user'a kayıtlı courses bilgisini almak için authController.js içindeki getDashboardPage fonksiyonunun ilgili kısmına .populate('courses'); eklenir. <br>
                    <code>
                        exports.getDashboardPage = async(req, res) => { <br>
                            const user = await User.findOne({_id: req.session.userID})<u>.populate('courses');</u> <br>
                            ...
                    </code> 
                </p>
                <p>
                    dashboard.ejs student kısmında aşağıdaki for döngüsü yazılır ve ilgili bilgiler ilgili kısımlara girilir. <br>
                    <code>
                        <% for(let i=0; i<user.courses.length; i++){ %> <br>
                            ... <br>
                            ...<%= user.courses[i].name %>... <br>
                            ...<%= user.courses[i].slug %>... <br>
                            ...<%= user.courses[i].description %>... <br>
                            ... <br>
    
                        <% } %>
                    </code>
                </p>
                <hr>
                <p>
                    gelişim sürecinde modellerimiz üzerinde de değişiklik yaptık. Database üzerine eski tarihli gönderdiğimiz verilerde bu bilgiler eksik kaldı. Bu nedenle categories alanı hariç database i temizledik. Yenilerini oluşturduk.
                </p>
                <hr>
    
                <h2>Release</h2>
                <p>
                    dashboard student kısmında description kısmının altına aşağıdaki buton eklenir: <br>
                    <code>
                        &lt;form method="POST" action=<u>"/courses/release"</u>> <br>
                            &lt;input type="hidden" name="course_id" value=<u>"&lt;%= user.courses[i]._id %>"</u>> <br>
                            &lt;button class="btn btn-large btn-danger text-white">&lt;span>RELEASE&lt;/span>&lt;/button> <br>
                        &lt;/form>
                    </code>
                </p>
                <p>
                    courseController.js içine releaseCourse fonksiyonu yazılır. <br>
                    <code>
                        exports.releaseCourse = async (req, res) => { <br>
                            try { <br>
                              
                              const user = await User.findById(req.session.userID); <br>
                              await user.courses<u>.pull</u>({_id: req.body.course_id}); <br>
                              await user.save(); <br>
                          
                              res.status(200).redirect('/users/dashboard'); <br>
                              
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              });
                            }
                          };                      
                    </code>
                </p>
                <p>
                    courseRoute içinde aşağıdaki yönlendirme ile buton ile fonksiyon bağlanır. <br>
                    <code>
                        router.route('/release').post(courseController.releaseCourse);
                    </code>
                </p>
    
                <h2>Alınan kursta enrol butonunun görünmemesi için:</h2>
                <p>
                    courseController.js getCourse içinde user bilgisi göndermek için: <br>
                    <code>
                        exports.getCourse = async (req, res) => { <br>
                            try { <br>
                              const user = await User.findById(req.session.userID); <br>
                              ... <br>
                    </code> yazılır ve user render içinde gönderilir.
                </p>
                <p>
                    course.ejs içindeki enroll butonu if bloğuna alınır: <br>
                    <code>
                        &lt;% if(user && !user.courses.includes(course._id)) { %> <br>
                            ...ENROLL... <br>
                        &lt;% } %> <br>
                    </code> user bilgisi hiç yoksa veya user.courses içinde olduğumuz course için _id içeriyorsa buton görünmez.
                </p>
            </div>
            <div class="row" id="search">
                <h1>Search Alanı</h1>
                <p>
                    courses.ejs search alanı aşağıdaki gibi düzenlenir: <br>
                    <code>
                        &lt;div class="widget-search"> <br>
                &lt;div class="site-search-area"> <br>
                  &lt;form <u>method="GET"</u> id="site-searchform" <u>action="/courses"></u> <br>
                    &lt;div> <br>
                      &lt;input class="input-text form-control" <u>name="search"</u> id="search-k" placeholder="Search..." type="text"> <br>
                      <u>&lt;button</u> id="searchsubmit" value="Search" <u>type="submit">&lt;/button></u> <br>
                    &lt;/div> <br>
                  &lt;/form> <br>
                &lt;/div> <br>
              &lt;/div>
                    </code>
                </p>
                <p>
                    Buradan gelen bilgi courseRoute.js üzerinden courseController.getAllCourses fonksiyonuna aktarılır. 
                </p>
                <p>
                    Bilginin filtrelemede kullanılması için fonksiyon aşağıdaki hale güncellenir.
                    <code>
                        exports.getAllCourses = async (req, res) => { <br>
                            try { <br>
                              const categorySlug = req.query.categories; <br>
                              const query = req.query.search; 
                    </code> ile search alanındaki bilgi alınır. <br>
                    <code>                      
                              const category = await Category.findOne({slug: categorySlug}) <br>
                          
                              let filter = {} <br>
                              if(categorySlug){ <br>
                                filter = {category:category._id} <br>
                              } <br>
                          
                              if(query) { 
                    </code> query varsa <br>
                    <code>
                                filter = {name:query}
                    </code> filter.name olarak atanır. <br>
                    <code>
                              } <br>
                          
                              if(!query && !categorySlug){
                                filter.name = "" <br>
                                filter.category = null <br>
                              } <br><br>
                          
                              const courses = await Course.find({ <br>
                                $or:[
                    </code> bu ifade mongodb için veya demek. <br>
                    <code>
                                  {name: {$regex: '.*' + filter.name + '.*', $options: 'i'}},
                    </code> ile name başı ve sonu farketmeksizin filter.name ifadesini içerenleri sorgular. <br>
                    <code>
                                  {category: filter.category} <br>
                                ] <br>
                              }).sort('-createdAt'); <br>
                              const categories = await Category.find(); <br>
                          
                              res.status(200).render('courses', { <br>
                                courses, <br>
                                categories, <br>
                                page_name: 'courses', <br>
                              }); <br>
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              });
                            }
                          };
                    </code>
    
                    <p>
                        courses.ejs içindeki search alanı aynı şekilde course.ejs için de kullanılır.
                    </p>
                    <p>
                        courses.ejs içindeki Categories alanı aynı şekilde course.ejs için de kullanılır. Çalışması için courseController.getCourse içinde <br>
                        <code>
                            const categories = await Category.find();
                        </code> eklenir ve
                        render içinde categories gönderilir.
                    </p>
                    <p>
                        courses sayfasında kursu oluşturan teacher kullanıcının adını görmek için courseController.getAllCourses fonksiyonundaki ilgili kısım aşağıdaki gibi güncellenir.<br>
                        <code>
                            const courses = await Course.find({ <br>
                                $or:[ <br>
                                  {name: {$regex: '.*' + filter.name + '.*', $options: 'i'}}, <br>
                                  {category: filter.category} <br>
                                ] <br>
                              }).sort('-createdAt')<u>.populate('user')</u>;
                        </code>
                    </p>
                    <p>
                        .populate('user') ile courses ile gönderilen user bilgisini almak için courses.ejs içindeki ilgili alana: <br>
                        <code>
                            <%= courses[i].user.name %> eklenir.
                        </code>
                    </p>
                </p>
            </div>
            <div class="row" id="contactAndMail">
                <h1>İletişim Sayfası ve Mail Göndermek</h1>
    
                <h2>İletişim Sayfası</h2>
                <p>
                    contact.html contact.ejs ye dönüştürülür.
                </p>
                <p>
                    contact.ejs template engine'e göre düzenlenir.
                </p>
                <p>
                    _navigation.ejs içinde ilgili linkler düzenlenir. <br>
                    <code>
                        &lt;li class="nav-item &lt;%= page_name === 'contact' && 'active' %>">&lt;a class="nav-link" href="/contact">Contact&lt;/a>&lt;/li>
                    </code>
                </p>
                <p>
                    pageRoute.js içinde ilgili yönlendirme yapıldı. <br>
                    <code>
                        router.route('/contact').get(pageController.getContactPage);
                    </code>
                </p>
                <p>
                    pageController.js içinde getContactPage fonksiyonu yazılır. <br>
                    <code>
                        exports.getContactPage = (req, res) => { <br>
                            res.status(200).render('contact', { <br>
                              page_name: "contact" <br>
                            });
                        }
                    </code>
                </p>
                <p>
                    contact.ejs içindeki form isteğe göre düzenlenir. Bize name, email ve message yeterli. Form ayarlarını da aşağıdaki gibi düzenleriz: <br>
                    <code>
                        &lt;form id="contactform" action="/contact" method="POST"> <br>
                            ..... <br>
                            ..... <br>
                        &lt;/form>
                    </code>
                </p>
                <p>
                    formdan gelen bilgiyi almak için (şimdilik konsola yazdıracağız) pageController.js içinde sendEmail fonksiyonu yazılır. <br>
                    <code>
                        exports.sendEmail = (req, res) => { <br>
    
                            console.log(req.body); <br>
                            }
                    </code>
                </p>
                <p>
                    formdan gelen bilgi routeController.js içinden ilgili fonksiyona yönlendirilir. <br>
                    <code>
                        router.route('/contact').post(pageController.sendEmail);
                    </code>
                </p>
    
                <h2>Mail Göndermek</h2>
                <p>
                    Bunun için ücretli servisler var. Biz bu uygulamada gmailin ücretsiz hizmetinden faydalanacağız. Bunun için kendi mail adresimizi kullanacağız.
                </p>
                <p>
                    Mail göndermek için önce nodemailer adında bir node modülü kullanacağız.
                </p>
                <p>
                    terminale: <br>
                    <code>
                        npm i nodemailer
                    </code>
                </p>
                <p>
                    modül pageController.js çine import edilir. <br>
                    <code>
                        const nodemailer = require("nodemailer");
                    </code>
                </p>
                <p>
                    pageController.sendEmail fonksiyonu aşağıdaki gibi düzenlenir. <br>
                    <code>
                        exports.sendEmail = async(req, res) => { <br>
        
                            const outputMessage = ` <br>
                            &lt;h1>Mail Details&lt;/h1> <br>
                            &lt;ul> <br>
                              &lt;li>Name: ${req.body.name}&lt;/li> <br>
                              &lt;li>Email: ${req.body.email}&lt;/li> <br>
                            &lt;/ul> <br>
                            &lt;h1>Message&lt;/h1> <br>
                            &lt;p>${req.body.message}&lt;/p> <br>
                            
                            `; <br>
                    </code> bu kısım mailimizin gövdesi olacak. <br>
                    <code>
                            let transporter = nodemailer.createTransport({ <br>
                              host: "smtp.gmail.com",
                    </code> gmaile yönlendiriyoruz. <br>
                    <code>
                              port: 465,
                    </code> portu 465 e ayarlıyoruz. <br>
                    <code>
                              secure: true,
                    </code> true for 465, false for other ports <br>
                    <code>
                              auth: { <br>
                                user: "drmuratgokduman@gmail.com",
                    </code> gmail accont: maili gönderecek olan adres <br>
                    <code>
                                pass: "eqocuuyuqcrxxyhc"
                    </code> gmail password yerine google account içinde güvenlik kısmında uygulama şifrelerine girilir ve uygulama şifresi oluşturulur. uygulama: posta cihaz: windows bilgisayar <br>
                    <code>
                              }, <br>
                            }); <br><br>
                          
                            let info = await transporter.sendMail({ <br>
                              from: '"Smart Edu Contact Form" &lt;drmuratgokduman@gmail.com>', 
                    </code> gönderen adres <br>
                    <code>
                              to: "drmuratgokduman@gmail.com",
                    </code> alan adres <br>
                    <code>
                              subject: "Smart Edu Contact Form New Message ✔",
                    </code> konu <br>
                    <code>
                              html: outputMessage,
                    </code>mesajın gövdesi: yukarıda oluşturmuştuk <br>
                    <code>
                            }); <br>
                          
                            console.log("Message sent: %s", info.messageId); <br>
                                                  
                            console.log("Preview URL: %s", nodemailer.getTestMessageUrl(info)); <br>
                                                  
                            res.status(200).redirect('contact'); <br>
                          }
                    </code>
                </p>
                <p>
                    nodemailer <a href="https://nodemailer.com/about/">anasayfasında</a> konuyla ilgili başka mail opsiyonları da var (cc, bcc, dosya eki vs)
                </p>
    
    
                
            </div>
            <div class="row" id="bildirim">
                <h1>Flash Bildirimleri</h1>
                <p>
                    Projemizde herhangi bir şekilde bir değişiklik yaptığımızda, yeni bir kurs oluşturduğumuzda veya mail gönderimi gibi işlemler sonucunda kullanıcıya geri bildirimde bulunmak için kullanılır.
                </p>
                <p>
                    Bu işlem için connect-flash modülü kullanılır.
                </p>
                <p>
                    terminale: <br>
                    <code>
                        npm i connect-flash
                    </code>
                </p>
                <p>
                    app.js içine import edilir. <br>
                    <code>
                        const flash = require('connect-flash');
                    </code>
                </p>
                <p>
                    app.js middleware alanına: <br>
                    <code>
                        app.use(flash());
                    </code>
                </p>
                <p>
                    flash dan gelen mesajı lokalde bir değişkene kaydetmek için middleware alanına: <br>
                    <code>
                        app.use((req, res, next)=>{ <br>
                            res.locale.flashMessages = req.flash(); <br>
                            next(); <br>
                          })
                    </code>
                </p>
    
                <h2>Mail gönderimi sonrası bildirim göndermek:</h2>
                <p>
                    pageController.sendMail fonksiyonunun içine en sondaki redirect komutundan önce: <br>
                    <code>
                        req.flash("success", "We received your message succesfuly");
                    </code> eklenir.
                </p>
                <p>
                    Başarısız işlemlerde hata mesajı yazdırabilmek için pageController.sendMail fonksiyonunun içeriği try catch bloğuna alınır. catch kısmına: <br>
                    <code>
                        req.flash("error", "Something happened!"); <br>
                        res.status(200).redirect('contact');
                    </code> eklenir.
                </p>
                <p>
                    Mesajı contact.ejs içinde görmek için istenilen yere: <br>
                    <code>
                        &lt;% if(flashMessages){ %> <br>
                            &lt;% if(flashMessages.success){ %> <br>
                                &lt;div class="alert alert-success"> <br>
                                    &lt;%= flashMessages.success %> <br>
                                &lt;/div> <br>
    
                            &lt;% } else if(flashMessages.error){ %> <br>
                                &lt;div class="alert alert-danger"> <br>
                                    &lt;%= flashMessages.error %> <br>
                                &lt;/div> <br>
                            &lt;% } %> <br>
                        &lt;% } %>
                    </code>
                </p>
                <p class="alert alert-warning">
                    Her şey normalken hata alıyorsan ağı kontrol et. şirket ağı bazı fonksiyonları kısıtlıyor.
                </p>
    
                <h2>Kurs oluşturduktan sonra bildirim almak:</h2>
                <p>
                    courseController.courseCreate fonksiyonunda try bloğunun en altındaki redirect fonksiyonundan önce: <br>
                    <code>
                        req.flash('success', `${course.name} Has Been Created Succesfuly`);
                    </code> eklenir. <br>
                    catch bloğu da aşağıdaki gibi güncellenir. <br>
                    <code>
                        req.flash('error', `Something Happened!`); <br>
                        res.status(400).redirect('/courses');
                    </code>
                </p>
                <p>
                    flash ile gelen bilgiyi yakalamak için courses.ejs içine mail gönderiminde eklediğimiz kodu kullanabiliriz. Bildirimi görmek istediğimiz yere ekleriz.
                </p>
                
            </div>
            <div class="row" id="dogrulama">
                <h1>Kayıt ve Kullanıcı Doğrulama</h1>
                <p>
                    Doldurulması zorunlu alanlar için html input kodlarına öz nitelik olarak required eklenebilir.
                </p>
                <p>
                    Biz bu çalışmada express-validator modülü ile form kontrolü yapacağız.
                </p>
                <p>
                    terminale: <br>
                    <code>
                        npm i express-validator
                    </code>
                </p>
    
                <h2>Sing Up sayfasında form denetimi:</h2>
                <p>
                    userRoute.js içine import edilir: <br>
                    <code>
                        const { body } = require('express-validator');
                    </code> bize bu kısımda sadece body fonksiyonu gerekecek.
                </p>
                <p>
                    userRoute.js içindeki singup post request routeu aşağıdaki gibi düzenlenir. <br>
                    <code>
                        router.route('/singup').post( <br>
                    [ <br>
                        body('name').not().isEmpty().withMessage('Please Enter Your Name'), 
                    </code> bu kısımda formdan gelen name parametresi boş ise "Please Enter Your Name" mesajı gönderilir. <br>
                    ], <br>
                    
                    authController.createUser);
                    </code>
                </p>
                <p>
                    Gönderilen hata mesajı authControler.createUser catch tarafında yakalanır. Bunun için önce express-validator import edilir. <br>
                    <code>
                        const { validationResult } = require('express-validator');
                    </code> <br>
                    sonra catch bloğunda hata mesajı yakalanır. <br>
                    <code>
                        const errors = validationResult(req); <br>
                        console.log(errors);
                    </code> konsolda bir array içinde bir obje yazdırılır. bize gereken hata mesajı için: <br>
                    <code>
                        console.log(errors.array()[0].msg);
                    </code>  
                </p>
                <p>
                    Aldığımız hata mesajını bir önceki konudaki flash metodu ile ilgili template'e göndereceğiz <br> 
                    bunun için catch bloğunun en altına: <br>
                    <code>
                        req.flash('error', errors.array()[0].msg); <br>
                        res.status(400).redirect('/register')   
                    </code> eklenir.
                </p>
                <p>
                    Gönderilen mesaj register.ejs içinde istenilen yere daha önceki kodun aynısı olarak girilir: <br>
                    <code>
                        &lt;% if(flashMessages){ %> <br>
                            &lt;% if(flashMessages.success){ %> <br>
                                &lt;div class="alert alert-success"> <br>
                                    &lt;%= flashMessages.success %> <br>
                                &lt;/div> <br>
    
                            &lt;% } else if(flashMessages.error){ %> <br>
                                &lt;div class="alert alert-danger"> <br>
                                    &lt;%= flashMessages.error %> <br>
                                &lt;/div> <br>
                            &lt;% } %> <br>
                        &lt;% } %> <br>
                    </code>
                </p>
                <p>
                    userRoute.js içine: <br>
                    <code>
                        const User = require('../models/User');
                    </code>
                </p>
                <p>
                    userRoute.js içindeki singup post request routeu diğer inputlardan gelen veriyi de değerlendirmesi için aşağıdaki gibi güncellenir. <br>
                    <code>
                        router.route('/singup').post( <br>
                        [ <br>
                            body('name').not().isEmpty().withMessage('Please Enter Your Name'), <br>
                            body('email').isEmail().withMessage('Please Enter Valid Email')
                    </code> bu kısım mail adresi değil ise mesaj gönder. <br>
                    <code>
                            .custom((userEmail)=> {
                    </code> bu kısımdaki sınamayı kendimiz yazdık. Mail adresinin databasete zaten olması durumunda hata mesajı gönderir. Sınamanın gerçekleşebilmesi için User modeli import edilir <br>
                    <code>
                                return User.findOne({email: userEmail}).then(user => { <br>
                                    return Promise.reject('Email is already exist') <br>
                                }) <br>
                            }), <br>
                            body('password').not().isEmpty().withMessage('Please Enter Your Password'),
                    </code> password kısmı boş ise hata mesajı verir.
                    <code>
                        ], <br> 
                        
                        authController.createUser); <br>
                    </code> 
                </p>
                <p>
                    Gelen birden fazla mesajın hepsinin yazılabilmesi için authController.createUser catch blogu içine for döngüsü yazılır. <br>
                    <code>
                    } catch (error) { <br>
                        const errors = validationResult(req); <br>
                    
                        for (let i=0; i&lt;errors.array().length; i++){ <br>
                          req.flash('error', errors.array()[i].msg); <br> 
                        } <br>
                        
                        res.status(400).redirect('/register') <br>
                      } 
                    </code>
                </p>
    
                <h2>Login sayfasında form denetimi:</h2>
                <p>
                    Bu kısımda emaile sahip user olma durumu ve password kontrol authController.loginUser fonksiyonunda zaten olduğu için userRoute içinde tekrar kontrol etmeye gerek yoktur.
                </p>
                <p>
                    if(user) bloğunun else bloğuna: <br>
                    <code>
                        req.flash('error', 'User Is Not Exist'); <br>
                        res.status(200).redirect('/login'); <br>
                    </code> yazılarak user yoksa alınacak mesajı gönderir.
                </p>
                <p>
                    if(user) içindeki if(same) bloğunun else bloğu içine: <br>
                    <code>
                        req.flash('error', 'Your Password Is Not Correct!!'); <br>
                        res.status(200).redirect('/login'); <br>
                    </code> yazılarak password doğru değilse alınacak mesajı gönderir.
                </p>
                <p>
                    login.esj içinde istenilen yerde bu mesajlar aşağıdaki kod ile yakalanır. <br>
                    <code>
                        &lt;% if(flashMessages){ %> <br>
                            &lt;% if(flashMessages.success){ %> <br>
                                &lt;div class="alert alert-success"> <br>
                                    &lt;%= flashMessages.success %> <br>
                                &lt;/div> <br>
    
                            &lt;% } else if(flashMessages.error){ %> <br>
                                &lt;div class="alert alert-danger"> <br>
                                    &lt;%= flashMessages.error %> <br>
                                &lt;/div> <br>
                            &lt;% } %> <br>
                        &lt;% } %> <br>
                    </code>
                </p>
                <p>
                    validation için detaylı okuma için <a href="https://github.com/validatorjs/validator.js">github.com/validatorjs</a> ve <a href="https://express-validator.github.io/docs/">express-validator.github.io/docs</a>
                </p>
            </div>
            <div class="row" id="hata">
                <h1>Bir hata ile karşılaştık</h1>
                <h2 class="text-danger">Kullanıcı bilgisi değiştiğinde password değişiyor.</h2>
                <p class="alert-danger">
                    student içine course enroll edildiğinde database üzerindeki password verisi değişiyor.
                </p>
                <p>
                    Bu durumu çözmek için google üzerinde arama yapıyoruz: <br>
                    <q>how to prevent refreshing password mongoose</q>
                </p>
                <p>
                    Bulunan <a href="https://stackoverflow.com/questions/43706606/how-to-prevent-mongoose-from-rehashing-the-user-passwords-after-modifying-a-user">stackoverflow</a> linki.
                </p>
                <p>
                    Linkteki cevabın referans verdiği <a href="https://mongoosejs.com/docs/api.html#document_Document-isModified">doküman</a>
                </p>
                <p>
                    stackoverflow da cevap olarak verilen kod null ifadesi silindikten ve userSchema <q>UserSchema</q> olarak kodumuzla uyumlu hale getirildiğinde işimizi görüyor. <br>
                    <code>
                        UserSchema.pre('save', function(next) { <br>
                            const user = this; <br>
                            if (!user.isModified('password')) return next(); <br>
                        
                            bcrypt.genSalt(10, function(err, salt) { <br>
                                if (err) return next(err); <br>
                                bcrypt.hash(user.password, salt, function(err, hash) { <br>
                                    if (err) return next(err); <br>
                                    user.password = hash; <br>
                                    next(); <br>
                                }); <br>
                            }); <br>
                        }); <br>
                    </code> 
                </p>
    
                <h3>Benim çözümüm</h3>
                <p class="alert-success p-2">
                    Kendi kodumuzu incelediğimizde her save işleminden önce password bilgisinin tekrar hash edildiğini görüyoruz. Bunu engellemek için koda bir if koşulu eklememiz yeterli olacaktır. <br>
                    <code>
                        UserSchema.pre('save', function (next) { <br>
                            const user = this; <br>
                            <u>if(!user.isModified('password')) return next();</u> <br>
                          
                            bcrypt.hash(user.password, 10, (error, hash) => { <br>
                              user.password = hash; <br>
                              next(); <br>
                            }); <br>
                          }); 
                    </code> 
                </p>
            </div>
            <div class="row" id="deleteCourse">
                <h1>Kurs Silmek</h1>
                <p>
                    delete ve update butonlarını eklemek için dashboard.ejs içinde teacher kısmındaki kurs kartlarına aşağıdaki kod eklenir: <br>
                    <code>
                        &lt;div class="clearfix"> <br>
                            &lt;ul style="list-style-type: none;"> <br>
                                &lt;li style="float: left;">&lt;button class="btn btn-primary rounded-0 text-white">&lt;span>UPDATE&lt;/span>&lt;/button>&lt;/li> <br>
                                &lt;li style="float: right;">&lt;button class="btn btn-danger rounded-0 text-white">&lt;span>DELETE&lt;/span>&lt;/button>&lt;/li> <br>
                            &lt;/ul> <br>
                        &lt;/div> 
                    </code>
                </p>
                <p>
                    delete ve update işlemleri için method-override paketi indirilir. Terminale: <br>
                    <code>
                        npm i method-override
                    </code>
                </p>
                <p>
                    app.js içine method-override import edilir. <br>
                    <code>
                        const methodOverride = require('method-override')
                    </code> <br>
                    ilgili middleware ilgili alana yazılır. <br>
                    <code>
                        app.use( <br>
                            methodOverride('_method', { <br>
                                methods: ['POST', 'GET'], <br>
                            }) <br>
                            ); 
                    </code>
                </p>
                <p>
                    dashboard.ejs delete butonu aşağıdaki gibi modifiye edilir: <br>
                    <code>
                        &lt;li style="float: right;">&lt;a <br>
                            href="/courses/&lt;%= courses[i].slug %>?_method=DELETE" <br>
                            onclick="return confirm('ARE YOU SURE?')" <br>
                            class="btn btn-danger rounded-0 text-white">&lt;span>DELETE&lt;/span>&lt;/a>&lt;/li>
                    </code>
                </p>
                <p>
                    courseController.js içine <br>
                    <code>
                        exports.deleteCourse = async (req, res) => { <br>
                            try { <br>
                              
                              const course = await Course.findOneAndRemove({slug:req.params.slug}) <br>
                              req.flash('error', `${course.name} Has Been Remote Succesfuly`); br
                              res.status(200).redirect('/users/dashboard'); <br>
                              
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              }); <br>
                            }
                          };
                    </code>
                </p>
                <p>
                    fonksiyon ile komutu bağlamak için courseRoute.js içinde <br>
                    <code>
                        router.route('/:slug').delete(courseController.deleteCourse);
                    </code>
                </p>
                <p>
                    Gönderilen flash mesajı dashboard.ejs içinde istenilen yere eklenir.
                </p>
            </div>
            <div class="row" id="updateCourse">
                <h1>Kurs Güncellemek</h1>
                <p>
                    Bir önceki çalışmada method-override paketini kurmuştuk. Bunun üzerinden devam edeceğiz.
                </p>
                <p>
                    update butonuna tıkladığımızda bir modal açılacak ve içinde tıkladığımız kursun bilgileri yazacak.
                </p>
                <p>
                    CREATE NEW COURSE içn kullandığımız ve sayfanın en altına yazdığımız modalı kopyalayıp kurs listelemek için kullandığımız for döngüsünün en altına yapıştırıyoruz. Bu sayede modal ilgili kursun bilgilerini alabiliyor.
                </p>
                <p>
                    dashboard.ejs içinde UPDATE butonu aşağıdaki gibi güncellenir: <br>
                    <code>
                        &lt;li style="float: left;">&lt;button class="btn btn-primary rounded-0 text-white" <br>
                            data-toggle="modal" data-target="#updateCourse&lt;%= courses[i]._id %>"
                    </code> bu kısım modal için gerekli. data-target ile modal id aynı olmalı. <br>
                    <code>
                            >&lt;span>UPDATE&lt;/span>&lt;/button>&lt;/li>
                    </code>
                </p>
                <p>
                    modal içindeki değişiklikler: <br>
                    <code>
                        &lt;div class="modal fade" <u>id="updateCourse&lt;%= courses[i]._id %>"</u> tabindex="-1" role="dialog" aria-labelledby="myModalLabel"> <br>
                        ... <br>
                        &lt;form method="POST" <u>action="/courses/&lt;%= courses[i].slug %>?_method=PUT"</u> class="form-horizontal"> <br>
                        ... <br>
                        &lt;input type="text" name="name" <u>value="&lt;%= courses[i].name %>"</u> class="form-control"  placeholder="Course Name"><br>
                        ... <br>
                        &lt;textarea rows="8" name="description" class="form-control"
                        placeholder="Course Description" required><u>&lt;%= courses[i].description %></u>&lt;/textarea> <br>
                        ...
                    </code>
                </p>
                <p>
                    courseController.js içine: <br>
                    <code>
                        exports.updateCourse = async (req, res) => { <br>
                            try { <br>
                              
                              const course = await Course.findOne({slug:req.params.slug}) <br>
                              course.name = req.body.name; <br>
                              course.description = req.body.description; <br>
                              course.category = req.body.category; <br>
                              course.save(); <br>
                          
                              req.flash('success', `${course.name} Has Been Update Succesfuly`); <br>
                              res.status(200).redirect('/users/dashboard'); <br>
                              
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              }); <br>
                            } <br>
                          };
                    </code>
                </p>
                <p>
                    routeController.js içine: <br>
                    <code>
                        router.route('/:slug').put(courseController.updateCourse);
                    </code> eklenir.
                </p>
            </div>
            <div class="row" id="admin">
                <h1>Admin Alanı ve Kullanıcı Silmek</h1>
                <p>
                    Bu çalışmada ayrı admin alanı oluşturmak yerine dashboard alanını kullanacağız.
                </p>
                <p>
                    Admin kullanıcısını student olarak yaratıp database üzerinden manuel admin yaptık.
                </p>
                <p>
                    dashboard.ejs student alanını kopyalayıp teacher alanının altına yapıştırdık. ve <code>user.role === 'admin'</code> olarak güncelledik.
                </p>
                <p>
                    for döngüsünü sildik ve yerine bu tamplate için kullanılan bootstrap yapısına uygun bir tablo örneği yapıştırdık.
                </p>
                <p>
                    Tüm user bilgisini dashboard.ejs de kullanabilmek için authController.getDashboardPage fonksiyonuna: <br>
                    <code>
                        const users = await User.find()
                    </code> 
                    ile tüm kurslar çağırılır ve render alanında gönderilen verilere 
                    <code>
                        users
                    </code> eklenir.
                </p>
                <p>
                    users bilgisi tablo içinde yakalanır: <br>
                    <code>
                        &lt;table class="table"> <br>
                            &lt;thead> <br>
                              &lt;tr> <br>
                                &lt;th scope="col">ID#&lt;/th> <br>
                                &lt;th scope="col">Email&lt;/th> <br>
                                &lt;th scope="col">Role&lt;/th> <br>
                                &lt;th scope="col">Delete&lt;/th> <br>
                              &lt;/tr> <br>
                            &lt;/thead> <br>
                            &lt;tbody> <br>
        
                            &lt;% for(let i=0; i&lt;users.length; i++){ %> <br>
                              &lt;tr> <br>
                                &lt;th scope="row">&lt;%= users[i]._id %>&lt;/th> <br>
                                &lt;td>&lt;%= users[i].email %>&lt;/td> <br>
                                &lt;td>&lt;%= users[i].role %>&lt;/td> <br>
                                &lt;td>DELETE&lt;/td>
                    </code> DELETE butonu daha sonra aktif hale getirilecek<br>
                    <code>
                              &lt;/tr> <br>
                            &lt;% } %> <br>
                            &lt;/tbody> <br>
                          &lt;/table>
                    </code>
                </p>
                <p>
                    DELETE butonu için: <br>
                    <code>
                        &lt;td>&lt;a <br>
                            href="/users/&lt;%= users[i]._id %>?_method=DELETE" <br>
                            onclick="return confirm('ARE YOU SURE?')" <br>
                            class="btn btn-danger rounded-0 text-white">&lt;span>DELETE&lt;/span>&lt;/a>&lt;/td>
                    </code>
                </p>
                <p>
                    authController.js içine: <br>
                    <code>
                        exports.deleteUser = async (req, res) => { <br>
                            try { <br>
                              await User.findByIdAndRemove(req.params.id); <br>
                              res.status(200).redirect('/users/dashboard'); <br>
                              
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              }); <br>
                            } <br>
                          };
                    </code>
                </p>
                <p>
                    userRoute.js içine: <br>
                    <code>
                        router.route('/:id').delete(authController.deleteUser);
                    </code>
                </p>
                <p>
                    role: teacher olan bir kullanıcıyı kaldırdığımızda, onun oluşturduğu kurslar kalmaya devam eder ve hata alırız. Bu nedenle teacher kaldırıldığında ona bağlı kurslar da kaldırılsın isteriz. Bu nedenle authController.deleteUser fonksiyonunu aşağıdaki gibi modifiye ederiz. <br>
                    <code>
                        exports.deleteUser = async (req, res) => { <br>
                            try { <br>
                              await User.findByIdAndRemove(req.params.id); <br>
                              <u>await Course.deleteMany({ user: req.params.id });</u> <br>
                          
                              res.status(200).redirect('/users/dashboard'); <br>
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              }); <br>
                            } <br>
                          }; 
                    </code>
                </p>
            </div>
            <div class="row" id="category">
                <h1>Kategori Eklemek ve Silmek</h1>
                <p>
                    dashboard.ejs admin alanındaki tablonun altına kendi kopyasını oluşturup modifiye edip üzerinde çalışacağız. <br>
                    <code>
                        &lt;div class="row mt-5"> <br>
                            &lt;h2>Categories&lt;/h2> <br>
                            &lt;table class="table"> <br>
                                &lt;thead> <br>
                                  &lt;tr> <br>
                                    &lt;th scope="col">ID#&lt;/th> <br>
                                    &lt;th scope="col">Categories&lt;/th> <br>
                                    &lt;th scope="col">Add&lt;/th> <br>
                                    &lt;th scope="col">Delete&lt;/th> <br>
                                  &lt;/tr> <br>
                                &lt;/thead> <br>
                                &lt;tbody> <br>
            
                                &lt;% for(let i=0; i&lt;categories.length; i++){ %> <br>
                                  &lt;tr> <br>
                                    &lt;th scope="row">&lt;%= categories[i]._id %>&lt;/th> <br>
                                    &lt;td>&lt;%= categories[i].name %>&lt;/td> <br>
                                    &lt;td>ADD&lt;/td>
                    </code> add butonu daha sonra düzenlenecek <br>
                    <code>
                                    &lt;td>&lt;a  <br>
                                        href="/categories/&lt;%= categories[i]._id %>?_method=DELETE" <br>
                                        onclick="return confirm('ARE YOU SURE?')" <br>
                                        class="btn btn-danger rounded-0 text-white">&lt;span>DELETE&lt;/span>&lt;/a>&lt;/td> <br>
                                  &lt;/tr> <br>
                                &lt;% } %> <br>
                                &lt;/tbody> <br>
                              &lt;/table> <br>
            
                        &lt;/div>&lt;!-- end row --> <br>
                    </code>
                </p>
    
                <h2>Kategori silmek</h2>
                <p>
                    categoryController içine: <br>
                    <code>
                        exports.deleteCategory = async (req, res) => { <br>
                            try { <br>
                              await Category.findByIdAndRemove(req.params.id); <br>
                          
                              res.status(200).redirect('/users/dashboard'); <br>
                            } catch (error) { <br>
                              res.status(400).json({ <br>
                                status: 'fail', <br>
                                error, <br>
                              }); <br>
                            } <br>
                          };
                    </code>
                </p>
                <p>
                    fonksiyon ile isteği bağdaştırmak için categoryRoute.js içine: <br>
                    <code>
                        router.route('/:id').delete(categoryController.deleteCategory);
                    </code>
                </p>
    
                <h2>Kategori eklemek</h2>
                <p>
                    add butonu: <br>
                    <code>
                        &lt;button class="btn btn-warning rounded-0 text-white" href="#" data-toggle="modal" data-target="#addCategory">&lt;span>ADD&lt;/span>&lt;/button>
                    </code>
                </p>
                <p>
                    categoryController.createCourse fonksiyonunu daha önce yazmıştık. Sadece <code>res.status(201).redirect('/users/dashboard');</code> yönlendirmesi eklendi. 
                </p>
                <p>
                    ilgili route daha önce yazılmıştı.
                </p>
            </div>
            <div class="row" id="homePage">
                <h1>Anasayfa düzeni</h1>
                <p>
                    pageController.getIndexPage fonksiyonu içinde anasayfada kullanmak için bazı bilgiler göndereceğiz. <br>
                    <code>
                        exports.getIndexPage = async (req, res) => { <br>
      
                            const courses = await Course.find().sort('-createdAt').limit(2);
                    </code> kursları oluşturulma sırasına göre tersten sıralıyoruz ve iki tanesini alıyoruz. <br>
                    <code>
                            const totalCourses = await Course.find().countDocuments(); 
                    </code> toplam kurs sayısı <br>
                    <code>
                        const totalStudents = await User.countDocuments({role: 'student'});
                    </code> toplam öğrenci sayısı <br>
                    <code>
                        const totalTeachers = await User.countDocuments({role: 'teacher'});
                    </code> toplam öğretmen sayısı <br>
                    <code>
                          
                            res.status(200).render('index', { <br>
                              page_name: 'index', <br>
                              courses, <br>
                              totalCourses, <br>
                              totalStudents, <br>
                              totalTeachers, <br>
                            }); <br>
                          };
                    </code>
                </p>
                <p>
                    Gönderilen veriler anasayfada yerleştirilerek kullanılır.
                </p>
            </div>
            <div class="row" id="deployment">
                <h1>Deployment</h1>
                <p>
                    daha önceki projenin aynısı.
                </p>
                <p>
                    Yeni database e bağlanırlen tüm veriler sıfırlanacağı için, index sayfasında courses verilerini if(courses[0]) benzeri koşullara alıyoruz. 
                </p>
                <p>
                    connect için kullandığımız mongodb bağlantısını middleware içindeki kısmı update ederken kullanmayı unutma. <br>
                    <code> bağlantı için: <br>
                        mongoose <br>
                        .connect('<u>mongodb+srv://arslan_ng:narniag7A.@cluster0.cqw1stg.mongodb.net/?retryWrites=true&w=majority</u>') <br>
                        .then(() => console.log('DB Connected!'));
                    </code> <br>
                    session middleware için: <br>
                    <code>
                        app.use( <br>
                        session({ <br>
                            secret: 'keyboard_cat_rambo', <br>
                            resave: false, <br>
                            saveUninitialized: true, <br>
                            store: MongoStore.create({ mongoUrl: '<u>mongodb+srv://arslan_ng:narniag7A.@cluster0.cqw1stg.mongodb.net/?retryWrites=true&w=majority</u>' }), <br>
                        }) <br>
                        ); 
                    </code>
                </p>
            </div>
          </div>
        </div>
      </div>

    </div>
    <!-- İçerik End -->
    <!-- footer start -->
    <!-- footer end -->
    <!-- JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>