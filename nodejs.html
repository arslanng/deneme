<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Node.JS</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
        }
    </style>
</head>
<body>
    <!-- Navbar Start -->
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">Node.JS</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2 class="text-center">Konu Listesi </h2>
            <ul style="max-height: 400px; overflow: auto;">
                <li><a href="#nedir">Node.js Nedir?</a></li>
                <li><a href="#asalSayi">Asal Sayılar Çalışması</a></li>
                <li><a href="#repl">REPL</a></li>
                <li><a href="#asenkronJs">Node.js'in Asenkron Yapısı</a></li>
                <li><a href="#callback">Callback Nedir?</a></li>
                <li><a href="#promise">Promise Nedir?</a></li>
                <li><a href="#asyncAwait">Async Await Yapısı</a></li>
                <li><a href="#module">Modül Kavramı</a></li>
                <li><a href="#fsModule">FS Modülü Kullanımı</a></li>
                <li><a href="#npm">NPM ve Package.json Kavramları</a></li>
                <li><a href="#requestResponse">Request - Response Döngüsü</a></li>
                <li><a href="#webSunucusu">Bir Web Sunucusu Oluşturmak</a></li>
                <li><a href="#express">Express.js Giriş</a></li>
                <h3>Pcat</h3>
                <li><a href="#start">PCAT Çalışma Ortamını Hazırlamak</a></li>
                <li><a href="#static">Statik Dosyalar - Middleware Giriş</a></li>
                <li><a href="#templateEngine">Template Engine Kavramı</a></li>
                <li><a href="#mongoDB">MongoDB Giriş</a></li>
                <li><a href="#MongoDBcrud">MongoDB - CRUD İşlemleri</a></li>
                <li><a href="#mongoose">Mongoose - CRUD İşlemleri</a></li>
                <li><a href="#requestBody">Request Body Nesnesi</a></li>
                <li><a href="#modelVeDinamikIcerik">Model ve Dinamik İçerik</a></li>
                <li><a href="#tekilSayfa">Tekil Fotoğraf Sayfaları</a></li>
                <li><a href="#gorselUpload">Görsel Yüklemek</a></li>
                <li><a href="#gorselUpdate">Fotoğraf Bilgisi Güncellemek</a></li>
                <li><a href="#gorselDelete">Fotoğraf Silmek</a></li>
                <li><a href="#MCV">MVC Yeniden Düzenleme</a></li>
                <li><a href="#pagination">Pagination (Sayfalama)</a></li>
                <li><a href="#atlasCloud">RENDER - MongoDB Atlas Deployment</a></li>

                <h3>SmartEdu</h3>
                <li><a href="#Ortam">SmartEdu Ortam Hazırlama</a></li>
                <li><a href="#httpStatus">HTTP Status Codes (HTTP Yanıt Durumu Kodları)</a></li>
                <li><a href="#template">Template Engine</a></li>
                <li><a href="#routing">Routing</a></li>
                <li><a href="#kursModeli">Kurs Modeli</a></li>
                <li><a href="#apiPostman">Postman ve API</a></li>
                <li><a href="#kursListeleme">Kursları Listelemek</a></li>
                <li><a href="#tekliKurs">Tekil Kurs Sayfası ve Slugify</a></li>
                <li><a href="#kategori">Kategori Oluşturmak ve Listelemek</a></li>
                <li><a href="#kayitSayfasiVeBcrypt">Kayıt Sayfası ve Bcrypt Paketi</a></li>
                <li><a href="#giris">Giriş Sayfası ve Giriş İşlemi</a></li>
                <li><a href="#session">Session Nedir?</a></li>
                <li><a href="#cikis">Çıkış İşlemi</a></li>
                <li><a href="#kullaniciSayfasi">Kişiye Özel İçerik</a></li>
                <li><a href="#ozelMiddleware">Özel Middleware</a></li>
                <li><a href="#kullaniciRolleri">Kullanıcı Rolleri</a></li>
                <li><a href="#courseCreate">Kurs Oluşturmak</a></li>
                <li><a href="#kursOgretmen">Kurs - Öğretmen İlişkisi</a></li>
                <li><a href="#kursOgrenci">Kurs - Öğrenci İlişkisi</a></li>
                <li><a href="#search">Search Alanı</a></li>
                <li><a href="#contactAndMail">İletişim Sayfası ve Mail Göndermek</a></li>
                <li><a href="#bildirim">Flash Bildirimleri</a></li>
                <li><a href="#dogrulama">Kayıt ve Kullanıcı Doğrulama</a></li>
                <li><a href="#hata">Bir hata ile karşılaştık</a></li>
                <li><a href="#deleteCourse">Kurs Silmek</a></li>
                <li><a href="#updateCourse">Kurs Güncellemek</a></li>
                <li><a href="#admin">Admin Alanı ve Kullanıcı Silmek</a></li>
                <li><a href="#category">Kategori Eklemek ve Silmek</a></li>
                <li><a href="#homePage">Anasayfa düzeni</a></li>
                <li><a href="#deployment">Deployment</a></li>
            </ul>

        </div>
        <div class="col-sm-9">
          <div class="row" id="nedir">
            <h1>Node.js Nedir?</h1>
            <p>
              Node.js, Chrome V8 JavaScript Engine'i temel alan bir JavaScript çalışma ortamıdır. Bu çalışma ortamı sayesinde bizler Javascript kodlarını kullanmak için tarayıcı kısıtlamalarından kurtulmuş oluruz. 
            </p>
    
            <h2>Nasıl Çalışır</h2>
    
            <h3>Event-Driven:</h3>
            <p>
              Node.js olay odaklı (event-driven) çalışır. Tek thread kullanmasından, yani aynı anda sadece bir işlem yapabilmesi nedeniyle node.js kendisinden istenilen işleri bir olay döngüsünün içerisinde değerlendirir.
            </p>
    
            <h3>Non-Blocking:</h3>
            <p>
              Node.js işlem sırasına koyduğu bir olayın tamamlanmasını beklemeden diğer olayı işleme alabilir, bunun sonucu olarak Node.js iş akışını engellemez.
            </p>
    
            <h3>Asynchronous:</h3>
            <p>
              Node.js asenkron (asynchronous) çalışır. Asenkron çalışma, kod akışının yukarıdan aşağıya ilerlemediği, işlemlerin birbirini beklemediği çalışma türüdür. Bu sayede işlem sırası olaya göre belirlenebilir.
            </p>
    
          </div>
          <div class="row" id="asalSayi">
            <h1>Asal Sayılar Çalışması</h1>
            <p>
              <pre class="prettyprint ms-0">
function showPrimeNumbers(lownumber, highnumber){ 
    for(let i = lownumber; i<=highnumber; i++){ 
        let isPrime = true; 
        for (let j = 2; j <= i; j++){ 
        if (i%j===0 && j !==i){ 
            isPrime = false 
        } 
        }  
        if(isPrime){ 
        console.log(i); 
        } 
    }
} 

showPrimeNumbers(2, 9)
              </pre> bize 2 ve 9 arasındaki asal sayıları verir. Bunu terminalde görmek için <pre class="prettyprint ms-0">node uygulama_adi</pre> yazılır.
            </p>
    
            <h2>Terminalden veri almak</h2>
            <p>
              process nesnesi nodeJS e ait global nesnelerden biridir. Bize o anki işlemle ilgili bilgiler verir. <br>
              <pre class="prettyprint ms-0">console.log(process)</pre> ifadesi js klasörüne ilave edilerek bu bilgilere ulaşılabilir. Çok fazla bilgi verir. Bir kısmı bize gerekir.
            </p>
            <p>
              <strong>process.argv</strong> özelliği bize node.exe ve çalışan js dosyasının parametrelerini verir. <br>
              <pre class="prettyprint ms-0">console.log(process.argv)</pre> koda ilave olunca bu iki veriyi konsola 2 maddeli <strong>array</strong> olarak yazdırır.
            </p>
            <p>
              içinde <pre class="prettyprint ms-0">console.log(process.argv)</pre> ifadesi bulunan kodu çalıştırırken terminalde boşluk bırakıp ifade girilirse boşluktan sonraki her maddeyi arraye ekler. <br>
              <pre class="prettyprint ms-0">node uygulama_adi 1 12</pre>
            </p>
            <p>
              uygulamanın içindeki kod bir array metodu olan slice ile ilk iki parametresi alınmayacak şekilde yazılırsa çıktı olarak terminalde kodun sonuna yazılan değerleri verir. <br>
              <pre class="prettyprint ms-0">console.log(process.argv.slice(2));</pre>
            </p>
            <p>
              <pre class="prettyprint ms-0">process.argv.slice(2)</pre> değeri js üzerinden bir değişkene tanımlanır ise bu sayede terminalden veri alınabilir.
              
            </p>
            <h2>Terminalden Alınan Veriyi Programda Kullanma</h2>
            <p>
              asal sayı bulma kodunun başına <br>
              <pre class="prettyprint ms-0">const arguments = process.argv.slice(2);</pre> ile alınacak değişkenler eklenir.
            </p>
            <p>
              Son kısma da çıktı almak için <br>
              <pre class="prettyprint ms-0">showPrimeNumbers(arguments[0], arguments[1]);</pre> uygulanır
            </p>
          </div>
          <div class="row" id="repl">
            <h1>REPL</h1>
            <p>
              Node.js Javascript çalışma ortamının terminal ekranı. 
            </p>
            <p>
              REPL ortamını başlatmak için node komutunu terminal ekranına yazmak yeterli olacaktır.
                <pre class="prettyprint ms-0">alert</pre> benzeri bazı kodlar tarayıcıda çalışırken REPL içinde çalışmayabilir. Tam tersi de olabilir.
            </p>
            <h2>REPL Komutları - Açıklamaları</h2>
            <p>
              <strong>help</strong> - Tüm komutları listeler. <br>
              <strong>break</strong> - Çok satırlı ifadeden çıkar. <br>
              <strong>ctrl + c</strong> - Çalışan komutu durdurur.<br>
              <strong>ctrl + d</strong> - REPL ortamını sonlandırır.<br>
              <strong>save dosya_adi</strong> - REPL ortamındaki kodları dosyaya kaydeder.<br>
              <strong>load dosya_adi</strong> - Dosyadaki kodları REPL ortamına alır.
            </p>
          </div>
          <div class="row" id="asenkronJs">
            <h1>Node.js'in Asenkron Yapısı</h1>
            <p>
              Asenkron programlama uzun süren bir işlemi beklemeden diğer işlemlere devam edebilmektir, işlemlerin sırasıyla devam etme zorunluluğu yoktur. Önce bir dosya okuyalım, aaa ama bu dosya okumak uzun sürüyor, eee ne yapalım o zaman? Bu işlemin bitmesini beklemeden diğer işleme geçebiliriz. Bir işlem yapılırken diğer işlemler bloklanmaz.
            </p>
            <p>
              Node.js için temel amaç mümkün olan en kısa sürede beklemeden fazla sayıda işlem yapmaktır.
            </p>
            <p>
              Aynı anda başladığı işleri hangi sırayla sunacağını da <strong>olay döngüsü (event-loop)</strong> belirler.
            </p>
          </div>
          <div class="row" id="callback">
            <h1>Callback Nedir?</h1>
            <p>
              klasik js kod sırasına göre sıralı ilerler (senkron çalışma) ve aynı anda tek bir işlem yapar (single thread)
            </p>
            <p>
              Node.JS nin ise asenkron bir doğası vardır.
            </p>
            <p>
              Callback fonksiyonu başka bir fonksiyon içerisinde argüman olarak kullanılabilen fonksiyon anlamına gelmektedir.
            </p>
            <p>
                <pre class="prettyprint ms-0">
const func1 = () => { 
    console.log('func 1 tamamlandı') 
    func2(); 
};
const func2 = () => { 
    console.log('func 2 tamamlandı') 
    func3();
}; 
const func3 = () => { 
    console.log('func 3 tamamlandı')
};

func1();
              </pre> bu kod çalıştığında önce func1 aktive olur. Sonra onun içine argüman olarak eklenen func2 aktive olur. Sonra onun içine argüman olarak eklenen func3 aktive olur.
            </p>
            <p>
              Örnek 
              <pre class="prettyprint ms-0">
const books = [
    {name: 'Kitap 1', author: 'Yazar 1'},
    {name: 'Kitap 2', author: 'Yazar 2'},
    {name: 'Kitap 3', author: 'Yazar 3'},
];

const listBooks = () => {
    books.map(book => {
        console.log(book.name);
    })
};



const addBook = (newBook, callback) => {
    books.push(newBook);
    callback();
};

addBook({name: 'Kitap 4', author: 'Yazar 4'}, listBooks);
              </pre>
            </p>
    
          </div>
          <div class="row" id="promise">
            <h1>Promise Nedir?</h1>
            <p>
              Bir işlemin sonucunu temsil eden bir JS nesnesidir.
            </p>
            <p>
              Promise bir işlemin sonucunu temsil eden bir Javascript nesnesidir. Promise nesnesi Resolve ve Reject adında iki tane parametre alır ve olumlu durumlarda Resolve ile belirtilen işlemlerin, olumsuz durumlarda da Reject ile belirtilen işlemlerin yapılacağına dair güvence verir. Promise yapısı olumlu sonuçları .then(), olumsuz sonuçları da .catch() ile karşılar.
            </p>
            <p>
              <pre class="prettyprint ms-0">
const promise1 = new Promise((resolve, reject) => { 
    resolve('Veriler Alındı');
    reject('Bağlantı Hatası');
});
              </pre> ile promise kurulur.
            </p>
            <p>
              <pre class="prettyprint ms-0">
promise1 
    .then(value => { 
        console.log(value); 
    });
              </pre> ile resorve durumu yakalar.
            <p>
              <pre class="prettyprint ms-0">
promise1 
    .catch(error => { 
        console.log(error); 
    });
              </pre> ile reject durumu yakalar.
            </p>
            <p>
              <pre class="prettyprint ms-0">
promise1
    .then(value => { 
        console.log(value); 
    }).catch(error => { 
        console.log(error); 
    });
              </pre> ile her iki durumu da yakalar.
            </p>
            <p>
              Örnek:
              <pre class="prettyprint ms-0">
const books = [
    {name: 'Kitap 1', author: 'Yazar 1'},
    {name: 'Kitap 2', author: 'Yazar 2'},
    {name: 'Kitap 3', author: 'Yazar 3'},
];

const listBooks = () => {
    books.map(book => {
        console.log(book.name);
    })
};



const addBook = (newBook) => {
    const promise1 = new Promise((resolve, reject) => {
        books.push(newBook);
        resolve(books);
        reject('bir hata oluştu'); 
    })
    return promise1;
};

addBook({name: 'Kitap 10', author: 'Yazar 10'})
    .then(() => {
        console.log('yeni liste');
        listBooks();
    }).catch((error)=>{
        console.log(error);
    });
              </pre>
            </p>
          </div>
          <div class="row" id="asyncAwait">
            <h1>Async Await Yapısı</h1>
            <p>
              Async - Await yapısı ES8 ile birlikte gelmiştir ve Promise yapısının daha anlaşılır bir söz dizimi ile yazılmasıdır.
            </p>
            <p>
              Bir fonksiyon async anahtar kelimesi ile birlikte tanımlanırsa, fonksiyonun olumlu sonuçlanması sonucunda bir Promise döner. Bir async fonksiyon await anahtar kelimesi ile birlikte kullanılırsa ilgili Promise olumlu bir şekilde dönene kadar async fonksiyonunun çalışması bekletilir.
            </p>
            <p>
              asenkron fonksiyon (<code>async function</code>) içinde bekle (<code>await</code>) komutu ile daha önce <code>promise</code> kalıbında yazılan verinin <code>await</code> ten sonraki kısmı true ise <code>resolve</code> çıktısı, false ise <code>reject</code> tipik reject hatası alınır. Bu hatayı almamak için tüm yapı <code>try-catch</code> bloğuna alınır.
            </p>
            <p>
              özellikle sıralı işlemler için kullanılır.
            </p>
            
            <h2>Örnek</h2>
            <p>
              <pre class="prettyprint ms-0">
function getData(data) { 
    return new Promise((resolve, reject) => {
        console.log('Veriler alınmaya çalışılıyor..');
        if (data) {
            resolve('Veriler alındı');
        } else {
            reject('Veriler alınamadı')
        }
    })
}

function cleanData(receivedData) {
    return new Promise((resolve, reject) => {
        console.log('Veriler düzenleniyor..');
        if (receivedData) {
            resolve('Veriler düzenlendi')
        } else {
            reject('Veriler düzenlenemedi')
        }
    })
}
              </pre> ifadelerinde önce birinci fonksiyon, sonra 2. fonksiyon çalışmalıdır.
            </p>
            <p>
              Bu ifadelerin sırayla ve doğrulanarak ilerlemesi için <strong>promise</strong> yapsında: <br>
              <pre class="prettyprint ms-0">
getData(true) 
    .then(result => {
        console.log(result);
        return cleanData(true)
    }).then(result =>{
        console.log(result)
    }).catch(error => {
        console.log(error)
    });
              </pre> yapısı kullanılır.
            </p>
            <p>
              <strong>async-await</strong> yapısı için ise: <br>
              <pre class="prettyprint ms-0">
async function processData(){ 
    try{
        const receivedData = await getData(false); // devam etmek için bunu bekle.
        console.log(receivedData);
        const cleanedData = await cleanData(true); // devam etmek için bunu bekle. 
        console.log(cleanedData);
    } catch(error) {
        console.log(error)
    }
}
      
    processData();
</pre> kullanılır.
            </p>
    
    
            
          </div>
          <div class="row" id="module">
            <h1>Modül Kavramı</h1>
    
            <h2>Modül Nedir?</h2>
            <p>
              Node.js uygulaması farklı görevleri olan farklı Javascript dosyalarından oluşur ve Node.js içerdiği tüm Javascript dosyalarına bir modül olarak davranır. Modül genelde belirli özel bir işlevi olan Javascript dosyasıdır. Bu şekilde Node.js uygulamaya ait olan dosyaları farklı bölümlere ayırarak kodun daha modülarize olmasını ve aynı zamanda bu kod kontrolünün ve hata yakalamanın daha kolay olmasını sağlar.
            </p>
            
            <h2>Asal Sayılar Örneği</h2>
            <p>
              Burada daha önce üzerine konuştuğumuz asal sayılar örneğimizi daha modüler hale getirelim ve sonrasında diğer dosyaların bu modülümüze ulaşmasını sağlayalım.
            </p>
            <p>
              primeNumber.js => primeNumberModule.js adıyla yeniden kopyalandı ve dizenlendi
            </p>
            <p>primeNumberModule.js içinde: <br>
              <pre class="prettyprint ms-0">
function showPrimeNumbers(lownumber, highnumber){
    for(let i = lownumber; i<=highnumber; i++){
        let isPrime = true;
        for (let j = 2; j <= i; j++){
        if (i%j===0 && j !==i){
            isPrime = false
        }
        } 
        if(isPrime){
        console.log(i);
        }
    }
}

module.exports = {showPrimeNumbers}; 
              </pre>Bu işlem ile fonksiyonu diğer dosyaların kullanımına açıyoruz. {} içine aralarına virgül koyarak birden fazla fonksiyon export edilebilir.
            </p>
            <p>
              Başka bir js dosyası içinde: <br>
              <pre class="prettyprint ms-0">const primeNumbers = require('./primeNumbersModule');</pre> değişkene modül atanır. <br>
              <pre class="prettyprint ms-0">primeNumbers.showPrimeNumbers(10,22);</pre> değişken üzerinden fonksiyon çağırılır.
            </p>
            <p>
              Birden fazla fonksiyon export ettiğimizde, örneğin: <br>
              <pre class="prettyprint ms-0">
module.exports = {
    showPrimeNumbers,
    showFivePrimes
} 
              </pre><br>
              Çağırıken bir değişkene atayıp tek tek çağırabiliriz:
              <pre class="prettyprint ms-0">
const primeNumbers = require('./primeNumbers');
primeNumbers.showPrimeNumbers(10, 22);
primeNumbers.showFivePrimes();
              </pre><br>
              ya da object destructuring yöntemiyle parçalayıp kullanabiliriz. <br>
              <pre class="prettyprint ms-0">
const { showPrimeNumbers, showFivePrimes } = require('./primeNumbers');
showPrimeNumbers(10, 22); 
showFivePrimes();
              </pre>
            </p>
    
            <h2>ES6 Import Söz Dizimi</h2>
            <p>
              Burada ES6 Import söz dizimini kullanarak da aynı işlemi yerine getirebiliriz. Fonksiyonu export ederken tek bir fonksiyon için default anahtar kelimesini kullanırız.
            </p>
            <p>
              <pre class="prettyprint ms-0">
export default showPrimeNumbers;
              </pre>
            </p>
            <p>
              import ederken ise bu kez dosya uzantısını kullanmak durumundayız.
            </p>
            <p>
              <pre class="prettyprint ms-0">
import showPrimeNumbers  from './primeNumbers.js';
              </pre>
            </p>
          </div>
          <div class="row" id="fsModule">
            <h1>FS Modülü Kullanımı</h1>
            <p>
              FS (File System) modülü Node.js'in dosya ve klasör işlemleri yaparken kullandığı bir çekirdek modülüdür. Buradaki çekirdek modülü kavramıyla Node.js yazılımıyla birlikte gelmesidir, tekrar oluşturulmasına gerek yoktur ve kullanıma hazırdır. FS modülünü kullanmak için: <br>
              <pre class="prettyprint ms-0">
import { readFile } from 'node:fs';
              </pre>
            </p>
            <p>
              yeni node sürümü <code>const fs = require('fs');</code> kodunu kabul etmiyor. ES6 ya göre yazılması için ise <strong>package.json</strong> içine <code>"type":"module",</code> eklenmesi gerekiyor.
            </p>
    
            <h2><code>"type": "module" </code>Hakkında</h2>
            <p>
              <strong>package.json</strong> içine <code>"type":"module",</code> eklenmesi <strong>require</strong> kullanımını engeller. Sadece ES6 ya göre olan yazımı kabul eder.
              <a href="https://isotropic.co/how-to-fix-referenceerror-require-is-not-defined-in-javascript/">Açıklama için tıklayınız</a>
            </p>
            <h2>Dosya Okumak</h2>
            <p>
              <pre class="prettyprint ms-0">
readFile('../password.txt','utf8', (err, data) => { 
    if (err) console.log(err); 
    console.log(data); 
    console.log('dosya okundu') 
}); 
              </pre> ile password.txt içindeki veri konsola yazdırılır.
            </p>
    
            <h2>Dosya Oluşturmak</h2>
            <p>
              <pre class="prettyprint ms-0">
import { writeFile } from 'node:fs';
              </pre> ile writeFile import edildi. <br>
              <pre class="prettyprint ms-0">
writeFile('../example.txt', 'kodluyoruzzz', 'utf8', (err)=>{ 
    if (err) console.log(err); 
    console.log('dosya başarılı bir şekilde oluşturuldu')
}); 
              </pre> ile example.txt oluşturuldu ve içine kodluyoruzzz yazıldı.
            </p>
            
            <h2>Dosyaya Veri Eklemek</h2>
            <p>
              <pre class="prettyprint ms-0">
import { appendFile } from 'node:fs';
              </pre> ile appendFile import edildi. <br>
              <pre class="prettyprint ms-0">
appendFile('../example.txt', '\nkodluyoruz 2222', 'utf8', (err)=>{ 
    if (err) console.log(err); 
    console.log('yeni veri eklendi')
}); 
              </pre> ile yeni veri eklendi. verinin başındaki \n verinin son satırın altına yeni bir satıra yazılmasını sağlar.
            </p>
    
            <h2>Dosya Silmek</h2>
            <p>
              <pre class="prettyprint ms-0">
import { unlink } from 'node:fs';
              </pre> ile unlink import edildi. <br>
              <pre class="prettyprint ms-0">
unlink('../example.json', (err)=>{ 
    if(err) console.log('silemedim:('); 
    else console.log('DOSYA SİLİNDİ'); 
});
              </pre> ile example.json silindi.
            </p>
    
            <h2>Klasör Oluşturmak</h2>
            <p>
              <pre class="prettyprint ms-0">
import { mkdir } from 'node:fs';
              </pre> ile mkdir import edildi. <br>
              <pre class="prettyprint ms-0">
mkdir('../uploads/json', { recursive: true }, (err)=>{ 
    if(err) console.log(err); 
    else console.log('Klasörler Oluşturuldu');
})
              </pre> ile uploads/json dosyaları iç içe oluşturuldu. İç içe oluşturabilmek için <code>{ recursive: true },</code> eklendi. Tek bir klasör oluşturulacaksa buna gerel yok.
            </p>
    
            <h2>Klasör Silmek</h2>
            <p>
              <pre class="prettyprint ms-0">
import { rmdir } from 'node:fs';
              </pre> ile rmdir import edildi. <br>
              <pre class="prettyprint ms-0"> 
rmdir('../uploads', { recursive: true }, (err)=>{ 
    if(err) console.log(err); 
    else console.log('Klasörler silindi');
});
              </pre> ile uploads ve altındaki tüm klasörler silindi. Hem kökü hem de altındakileri silmek için <code>{ recursive: true },</code> eklendi. Tek bir klasör silinecek ise buna gerel yok.
            </p>
    
            <h2>Tüm File System Modülünü Tek Seferde İmport Etmek</h2>
            <p>
              <pre class="prettyprint ms-0">
import * as fs from 'node:fs';
              </pre> ile tüm fs import edilir. Ancak import edilen kodları kullanmak için başına <code>fs.</code> eklenir.
            </p>
            <p>
              Örnek: <br>
              <pre class="prettyprint ms-0">
fs.appendFile('../example.txt', '\nkodluyoruz 2222', 'utf8', (err)=>{ 
    if (err) console.log(err); 
    console.log('yeni veri eklendi')
});
              </pre>
            </p>
          </div>
          <div class="row" id="npm">
            <h1>NPM ve Package.json Kavramları</h1>
            <p>
              NPM: node package manager. Hem kayıtlı paketlerin olduğu web sayfasını hem de paket indirmeyi sağlayan kod satırı uygulamasını içerir.
            </p>
            <p>
              paket: bir veya daha fazla modülden oluşan ve içerdiği modüller konusunda bilgi veren package.json dosyasına sahip bir klasör sistemi.
            </p>
            <p>
              İşimize yarayan paketler npm den hazır indirilebilir.
            </p>
    
            <h2>Package.json</h2>
            <p>
              Tüm bu kodları yönetmemiz için bizim bu bilgileri taşıyan bir dosyaya ihtiyacımız var, işte bu dosyanın adı package.json. Bu dosyayı oluşturmak için: <br>
              <code>
                npm init
              </code> yazıp gelen soruları cevaplayabiliriz. <br>
              <code>
                npm init -y
              </code> tüm sorular varsayılan olarak doldurulur.
            </p>
            <p>
              Artık npm den paket indirebiliriz.
            </p>
    
            <h2>Paket Yüklemek</h2>
            <p>
              <code>npm i paketAdi</code> veya <code>npm install paketAdi</code>
            </p>
            <p>
              Bu işlemden sonra package.json dosyasında <br>
              <code>
                "dependencies": { <br>
                  "paketAdi": "^4.17.1" <br>
                } 
              </code> benzeri bir ifade yer alır.
            </p>
    
            <h2>Paket Silmek</h2>
            <p>
              <code>
                npm uninstall paketAdi
              </code>
            </p>
    
            <p>
              Dosya olarak silinen veya gite aktarılmadan bırakılan bağlı paketleri yüklemek için: <br>
              <code>
                npm install
              </code> <br>Bu nedenle paket dosyalarını git'e aktarmaya gerek yoktur.
            </p>
    
            <h2>NPM İçine Kısayol Ekleme</h2>
            <p>
              <code>
                package.json
              </code> dosyası içine
              <code>
                "script"
              </code> kısmına istediğimiz kısayolu
              <code>
                "kisayolAdi": "dosyaYolu"
              </code> şeklinde yazabiliriz. <br>
              Kullanmak için komut satırına: <br>
              <code>
                npm kisayolAdi
              </code> yazılır.
            </p>
          </div>
          <div class="row" id="requestResponse">
            <h1>Request - Response Döngüsü</h1>
            <p>
              Node.js ile yazılan bir web uygulaması temelde bir request - response (istek - cevap) döngüsüdür. Bizler internet tarayıcımıza www.google.com yazmakla, aslında uzaktaki sunucuya bir request gönderiyoruz. Uzaktaki sunucu ise bize gördüğümüz Google sayfasını göstererek bir response dönüyor.
              <br><br>
              Sayfa > incele > ağ yaptığımızda: Request HEADERS içerisinde yaptığımız istek, Response HEADERS içerisinde ise aldığımız cevap ile ilgili bilgiler taşınır. Bunlardan bazıları istek metodu, remote address, cantent-type, path vs..
            </p>
    
            <h2>IP Address</h2>
            <p>
              Sunucunun sahip olduğu IP (Internet Protocol) adresi sunucuya ulaşmamızı sağlar. Aslında biz www.google.com yazmakla arka plandaki DNS sunucusu yardımıyla rakamlardan oluşan IP adresine ulaşır ve chunk ismi verilen parçalar halinde karşı sunucudaki web sayfası kendi bilgisayarımızda gösterilmeye başlar.
            </p>
            
            <h2>TCP - IP Protokolü</h2>
            <p>
              TCP/IP (Transmission Control Protocol/Internet Protocol), istemci - sunucu arasında veri iletme, alma birimleri arasında organizasyonu sağlayan, böylece bir yerden diğerine veri iletişimini olanaklı kılan ve farklı protokollerden oluşan yapıya verilen genel addır.
            </p>
    
            <h2>HTTP</h2>
            <p>
              Sunucu ile istemci arasında iletişim için kullanılan protokoldür.
            </p>
            <p>
              <strong>https</strong> http protokolünün ek güvenlik önlemlerine sahip versiyonudur.
            </p>
    
            <h2>Status Code</h2>
            <p>
              İstemci ile sunucu arasındaki iletişimin başarılı kurulma durumunu gösterir. <br>
              Örn: 404: sayfa bulunamadı.
            </p>
          </div>
          <div class="row" id="webSunucusu">
            <h1>Bir Web Sunucusu Oluşturmak</h1>
            <p>
              Node.js ile bir web sunucusu oluşturmanın çeşitli yolları vardır ve biz burada başlangıç olarak Node.js çekirdek modülü olan "http" modülünü kullanacağız. server.js dosyası oluşturup önce bu modülü çağıralım.
            </p>
            <p>
              <pre class="prettyprint ms-0">
                import * as http from 'node:http';
              </pre>
            </p>
    
            <h2><code>createServer</code></h2>
            <p>
              http modülü ile bir web sunucusu oluşturmak için createServer metodunu kullanacağız. createServer metodu, callback fonksiyon parametreleri olarak request ve response nesnelerini (request - response döngüsünün elemanları) alır. Doğal olarak biz bir web sunucusu oluşturuyorsak bu sunucumuz üzerinde isteklerde bulunmak ve bunlara gerekli cevapları almak isteriz.
            </p>
            <p>
              <pre class="prettyprint ms-0">
const server = http.createServer((req, res)=>{
const url = req.url; // ile istek yapılan url alınır 
    if(url === '/'){
        res.writeHead(200, {'Content-Type': 'text/html'});// ile status pre ve tipi belirtilir 
                    res.write('İndex Sayfası'); //ile cevap iletilir. Cevap tipi html olarak bildirildiği için cevap html elementi olarak da yazılabilir. 
    } else if (url === '/about'){ 
        res.writeHead(200, {'Content-Type': 'text/html'}); 
        res.write('Hakkımda Sayfası'); 
    } else if (url === '/contact'){ 
        res.writeHead(200, {'Content-Type': 'text/html'}); 
        res.write('İletişim Sayfası'); 
    } else { 
        res.writeHead(404, {'Content-Type': 'text/html'}); 
        res.write('404 Sayfa Bulunamadı'); 
    }
    res.end(); // ile cevap sonlandırılır 
});
                </pre>
            </p>
    
            <h2>Port Belirlemek</h2>
            <p>
              Biz kendi bilgisayarızımı sunucuya çevirdik ve aşağıdaki kod ile portu belirttik
            </p>
            <p>
              <pre class="prettyprint ms-0">
const port = 3000; 
server.listen(port, ()=>{ 
    console.log(`Sunucu Port ${port} de başlatıldı.`);
});
              </pre>
            </p>
            <p>
              konsola <code>node webSunucusu</code> yazdığımız anda <strong>localhost:3000</strong> adresi için sunucumuz hazır.
            </p>
          </div>
          <div class="row" id="express">
            <h1>Express.js Giriş</h1>
            <p>
              Express.js, Node.js üzerine yazılmış bir web çatısıdır. Express bize node.js ile yazması biraz karmaşık olan işlemleri daha basit bir şekilde oluşturmamızı sağlar. 
            </p>
            <p>
              express'i kurmak için konsola önce <br>
              <pre class="prettyprint ms-0">npm init</pre> (:daha önce yapılmadıysa) <br>
              sonra <br>
              <pre class="prettyprint ms-0">npm i express</pre> (express'in kurulumu) yazılır. 
            </p>
    
            <p>
              <pre class="prettyprint ms-0">
import express from 'express'; // ile import edilir.
const app = express(); // JS de fonksiyonlar da değişkenlere atanabiliyor.

app.get('/', (req, res) => { 
    res.status(200).send('Hello World')
}); // ile ana sayfaya status code 200 olarak gönderilir ve Hello World aktarılır. 
app.get('/about', (req, res) => { 
    res.status(200).send('About Sayfası')
}); 
app.get('/contact', (req, res) => { 
    res.status(200).send('Contact Sayfası')
});

app.get('*', (req, res) => {
    res.status(404).send('404 Sayfa Bulunamadı')
}); // ile ana sayfaya status code 404 olarak gönderilir ve 404 Sayfa Bulunamadı aktarılır.

const port = 3000; 
app.listen(port, ()=>{ 
    console.log(`Sunucu port ${port} da çalışmaya başladı`);
}); // ile port açılır.
              </pre> 
            </p>
          </div>
          <div class="row pcatproject" style="background-color: rgba(128, 128, 128, 0.203);">
            <div class="row" id="start">
              <h1>PCAT Çalışma Ortamını Hazırlamak</h1>
  
              <h2>git ve github</h2>
              <p>Bunları biliyoruz</p>
  
              <h2>VSC içinde hazırlık</h2>
              <p>prettier - code formatter eklenti olarak indirilir.</p>
              <p>
                  ctrl + shift + p -> Prettier: Create Configuration File ile proje
                  dosyasında .prettierrc dosyası oluşturulur.
              </p>
              <p>
                  prettier'in çalışması için gereken dosya npm ile kurulur. <br />
                  <code> npm init </code> <br />
                  <code> npm install prettier -D --save-exact </code> --save-exact bizde
                  yüklü olan prettier ile aynı versiyonu indirmeyi sağlar.
              </p>
  
              <h2>.prettierrc Ayarları</h2>
              <p>
                  <code>"semi":true</code> her satırın sonuna noktalı virgül ekler.
                  <br />
                  <code>"singleQuote": true</code> tek tırnak içine almak için. <br />
                  <code>"trailingComma": "es5"</code>
              </p>
              <p>
                  Bu kurulum kodu yazdıktan sonra tümünü seçip sağ tıklayıp "format
                  document" yapınca kodun istediğimiz gibi görünmesini sağlar.
              </p>
  
              <h2>.gitignore</h2>
              <p>
                  hazır .gitignore dosyası oluşturmak için:
                  <a href="https://www.toptal.com/developers/gitignore">toptal.com/developers/gitignore</a>
              </p>
  
              <h2>Template Dosyası İndirmek</h2>
              <p>
                  Orjinali için:
                  <a href="https://templatemo.com/tm-552-video-catalog">https://templatemo.com/tm-552-video-catalog</a>
                  <br />
                  Biz hocanın düzenlediği versiyon ile çalışacağız.
              </p>
  
              <h2>Express Modülü</h2>
              <p>
                  <pre class="prettyprint ms-0">npm i express --save </pre>
              </p>
              <p>
                  express <strong>dependencies</strong>. yani bu kodun çalışması için
                  elzem. <br />
                  prettier ise <strong>devDependencies</strong>. yani kodun çalışması
                  için gerekli değil. Kodu yazarken bize yardımcı.
              </p>
              <p>
                  <pre class="prettyprint ms-0">
const express = require('express'); 
const app = express(); // ile express import edildi.

app.get('/', (req, res)=>{ 
res.send('Merhaba') }) // ile kök dizine gönderildi.

const port = 3000 
app.listen(port, ()=>{ console.log(`Sunucu ${port} portunda başlatıldı`) }) // 3000 portu açıldı.
                  </pre>
                  
              </p>
  
              <h2>NODEMON</h2>
              <p>
                  her işlemden sonra sunucuyu kapatıp açmayı otomatik hale getirmeye
                  yarar.
              </p>
              <p>
                  <pre class="prettyprint ms-0">npm install --save-dev nodemon </pre>
              </p>
              <p>--save-dev: nodemon devDependenciestir.</p>
              <p>
                  çalışması için package.json -> script içine: <br />
                  <pre class="prettyprint ms-0"> "start": "nodemon app.js" </pre> eklenir.
              </p>
              <p>
                  terminale:
                  <pre class="prettyprint ms-0"> npm start </pre> yazarak aktifleştirilir. app.js her
                  kaydedildiğinde port baştan başlatılır.
              </p>
            </div>
            <div class="row" id="static">
                <h1>Statik Dosyalar - Middleware Giriş</h1>
    
                <h2>Middleware</h2>
                <p>req-res döngüsündeki herşeye Middleware denir.</p>
                <p>
                    Middlewarelar yularıdan aşağı sıra ile çalışır. req-res döngüsü
                    bitmeden bir sonrakine ilerleyemez. İlerlemeyi sağlama için
                    <code>next()</code> methodu kullanılır.
                </p>
                <p>get request yapısı da middlewaredir.</p>
    
                <h3>Örnek Middleware</h3>
                <p>
                    <pre class="prettyprint ms-0">
const myLogger = (req, res, next)=>{ 
    console.log("Middleware log 1"); 
    next() 
}
                    </pre>
                    ile fonksiyonumuz tanımlanır. isteğe cevap olmadığından döngü next()
                    ile bozulur.
                </p>
                <p><pre class="prettyprint ms-0"> app.use(myLogger); </pre> ile fonksiyon kullanıma alınır.</p>
    
                <h2>Statik Dosyaları Kullanmak</h2>
                <p>
                    <pre class="prettyprint ms-0">app.use(express.static('public')) </pre> ile ekspress için statik dosyalarla çalışabileceği Middleware import edildi.
                </p>
                <p>
                    kodu kullanmak için public isimli dosya oluşturuldu ve statik dosyalar
                    içine yüklendi.
                </p>
    
                <h2>Response Olarak Dosya Göndermek</h2>
                <p>
                    <pre class="prettyprint ms-0">
app.get('/', (req, res) => { 
    res.sendFile(path.resolve(__dirname, 'temp/index.html')); 
});
                    </pre>
                </p>
                <p>
                    <code> path.resolve() </code> yöntemi, bir yol dizisini veya yol
                    segmentlerini mutlak bir yola çözümler. <br />
                    <code> __dirname </code> yürütülmekte olan kaynak dosyayı içeren
                    dizinin mutlak yoludur.
                </p>
                <p>
                    Kodun işe yaraması için core modül olarak: <br />
                    <pre class="prettyprint ms-0">const path = require('path'); </pre> import edilir.
                </p>
            </div>
            <div class="row" id="templateEngine">
                <h1>Template Engine Kavramı</h1>
                <p>
                    Template engine bize değişen içeriği html kodu içerisinde dosya
                    uzantısı değiştirilerek kullanmamızı sağlar. Template engineler
                    sayesinde bir static dosyaları ve değieşen dinamik içeriği birlikte
                    kullanabiliriz. Farklı template engineler kullanılabiliriz, biz bu
                    çalışmamızda EJS template engine yapısını kullanacağız.
                </p>
                <h2><strong>ejs </strong> Embedded JavaScript templates</h2>
                <p>
                    Terminale: <br />
                    <pre class="prettyprint ms-0"> npm install ejs </pre>
                </p>
                <p>
                    JS koduna: <br />
                    <pre class="prettyprint ms-0"> const ejs = require('ejs'); </pre>
                </p>
                <p>
                    <pre class="prettyprint ms-0"> app.set("view engine", "ejs"); </pre> ile express'e template
                    engine olarak esj kullanacağımızı belirtiriz. Bu durumda esj views
                    klasörünün içine bakar. Bu nedenle bu isimde bir dosya oluşturup html
                    dosyaları içine konuldu. Dosya uzantıları ejs olarak değiştirildi.
                </p>
                <p>
                    JS içindeki <br />
                    <pre class="prettyprint ms-0"> 
app.get('/', (req, res) => { 
    <span style="text-decoration: line-through; background-color: gray;">res.sendFile(path.resolve(__dirname, 'temp/index.html'));</span> // yerine 
    res.render('index'); // yazılır. 
}); 
                    </pre> diğer sayfalar da bu şablona göre eklenir.
                </p>
    
                <h2>Partials Klasörü</h2>
                <p>
                    Html olarak yazdığımız dosyalardaki ortak kodları birleştirmek için
                    kullanılır.
                </p>
                <p>views klasörünün içinde partials klasörü oluşturulur.</p>
                <p>
                    Daha önce .html olarak yazılmış ve .ejs ye dönüştürülmüş sayfalardaki
                    ortak kodlar için .ejs uzantılı dosyalar partials içinde oluşturulur.
                    <strong>Örnek:</strong> _header.ejs <br />
                    Bu dosyanın içine ortak olan header kodu yapıştırılır.
                </p>
                <p>
                    Yapıştırılan kod diğer sayfalardan silinir ve yerine: <br />
                    <code> <%- include('partials/_header') -%> </code> yazılır.
                </p>
                <p>Bu kalıp diğer kodlara da uyarlanır.</p>
                <p>
                    Bu sayede sayfaların ortak noktaları tek elden yönetilebilir. Örneğin
                    js kodunda link olarak verilen "/about" navbar içindeki "about.html"
                    yerine yazıldığında tüm sayfalarda geçerli olur.
                </p>
            </div>
            <div class="row" id="mongoDB">
                <h1>MongoDB Giriş</h1>
    
                <h2>SQL vs NoSQL</h2>
                <p>SQL tablolarla çalışır. NoSQL döküman tabanlıdır.</p>
                <p>JS json tabanlı NoSQL ile daha rahat çalışır.</p>
                <p>
                    SQL de tutulacak bilgiler tüm sütunlarda sabittir. NoSQL de böyle bir
                    şart bulunmaz.
                </p>
    
                <h2>MongoDB</h2>
                <p>setup ve path eklenmesi videoda var.</p>
            </div>
            <div class="row" id="MongoDBcrud">
                <h1>MongoDB - CRUD İşlemleri</h1>
    
                <h2>MongoDB Shell</h2>
                <p>
                    Dökümantasyon için
                    <a href="https://www.mongodb.com/docs/v4.4/">tıklayınız.</a>
                </p>
                <p><pre class="prettyprint ms-0">show dbs</pre> mevcut veri tabanlarını gösterir.</p>
                <p>
                    <pre class="prettyprint ms-0">use</pre> ile veri tabanları arasında geçiş yapılabilir ve yeni
                    veri tabanı oluşturulabilir. <br />
                    örnek yeni veri tabanı: <pre class="prettyprint ms-0">use pcat-test-db</pre> oluşturulur. İçi
                    boşken db listesinde görünmez.
                </p>
                <p>
                    <pre class="prettyprint ms-0">
db.photos.insertOne( 
... {title: "photo 1", description: "Photo desc lorem ipsum dolor!",
qty: 20} 
... )
                    </pre>
                    ile ilk örnek verimizi girdik. ve karşılığında: 
                    <pre class="prettyprint ms-0">
{ "acknowledged" : true, 
"insertedId" : ObjectId("63a564428fa9a29730595280") }
                    </pre>
                    çıktısını aldık.
                </p>
                <p>
                    <pre class="prettyprint ms-0">db.photos.find() </pre> ile db içindeki photosta yer alan
                    veriye ulaştık. Çıktı olarak: <br />
                    <pre class="prettyprint ms-0">
{ "_id" : ObjectId("63a564428fa9a29730595280"), "title" : "photo 1",
"description" : "Photo desc lorem ipsum dolor!", "qty" : 20 }
                    </pre>
                    aldık. Biz belirmediğimiz halde <strong>"_id" : </strong>olarak
                    mongoDB her eklenen ögeye eşsiz ID ekler. Bu ID primary key görevi
                    görür.
                </p>
                <p>
                    <pre class="prettyprint ms-0">show collections </pre> ile içinde olduğumuz dbin
                    collectionslarını gösterir.
                </p>
                <p>
                    Birden fazla veri ekleme örneği: <br />
                    <pre class="prettyprint ms-0">
db.photos.insertMany( [ 
... {title: "photo 2", description: "Photo 2 desc", qty: 50}, 
... {title: "photo 3", description: "Photo 3 desc", qty: 100}, ])
                    </pre>
                </p>
                <p>
                    <pre class="prettyprint ms-0">db.photos.find({title: "photo 1"}) </pre> title değeri photo 1
                    olan veriyi verir.
                </p>
                <p>
                    <pre class="prettyprint ms-0">db.photos.find({title: "photo 1", qty: 100}) </pre> title
                    değeri photo 1 olan <strong>ve</strong> qty değeri 100 olan veriyi
                    verir. Böyle bir veri yoksa boş döner.
                </p>
                <p>
                    <pre class="prettyprint ms-0">
db.photos.find( 
{qty: {$lt: 200}} 
).limit(2)
                    </pre>
                    qty değeri 200 den az olan 2 veri getirir.
                </p>
                <p>
                    <pre class="prettyprint ms-0">
db.photos.updateOne( 
... {title: "photo 1"}, 
... { $set: {qty: 222}} )
                    </pre>
                    title değeri photo 1 olan ilk verinin qty değeri 222 olarak
                    güncellendi.
                </p>
                <p>
                    <pre class="prettyprint ms-0">
db.photos.deleteOne( 
... { qty: {$lt: 500}} )
                    </pre>
                </p>
                    qty değeri 500 den küçük olan değerlerden birini siler.
                <p>
                    <strong>Asla Kullanma</strong> geri dönüşü yok. Onay sormadan siler.
                    <br /><br />
                    Önce doğru db yi sildiğinden emin ol. <br />
                    <pre class="prettyprint ms-0"> use pcat-test-db </pre> <br />sonra sil: <br />
                    <pre class="prettyprint ms-0"> db.dropDatabase() </pre>
                </p>
            </div>
            <div class="row" id="mongoose">
                <h1>Mongoose CRUD İşlemleri</h1>
                <p>Mongoose bir ODC (Object Document Mapper) aracıdır.</p>
                <p>
                    terminalde:
                    <pre class="prettyprint ms-0">npm i mongoose </pre>
                </p>
                <p>test.js oluşturuldu.</p>
                <p>
                    test.js içine: <br />
                    <pre class="prettyprint ms-0">
const mongoose = require('mongoose'); 
const Schema = mongoose.Schema;
                    </pre>
                    ile mongoose çağırıldı. ve Schema metodu değişkene atandı.
                </p>
                <p>
                    database e bağlanmak için: <br />
                    <pre class="prettyprint ms-0">mongoose.connect('mongodb://localhost/pcat-test-db'); </pre>
                    pcat-test-db varsa bağlanır. Yoksa önce yaratır sonra bağlanır.
                </p>
                <p>
                    şema oluşturmak: <br />
                    <pre class="prettyprint ms-0">
const PhotoSchema = new Schema({ 
title: String, 
description: String, });
                    </pre>
                </p>
                <p>
                    koleksiyon oluşturmak: <br />
                    <pre class="prettyprint ms-0">const Photo = mongoose.model('Photo', PhotoSchema); </pre>
                    mongoose 'Photo' verisini alıp photos collectiona dönüştürüyor.
                </p>
                <p>
                    Koleksiyona veri eklemek: <br />
                    <pre class="prettyprint ms-0">
Photo.create({ 
title: 'Photo Title 1', 
description: 'Photo 1 desc. lorem ipsum', });
                    </pre>
                </p>
                <p>
                    Verileri okumak: <br />
                    <pre class="prettyprint ms-0">
Photo.find({}, (err, data) => { 
console.log(data); });
                    </pre>
                    ile veriler okunur ve konsola yazdırılır.
                </p>
                <p>
                    Verileri güncellemek: <br />
                    <pre class="prettyprint ms-0"> 
const id = '63a57f07705931fa74b54a35'; // ile silinecek
verinin id numarası değişkene atanır.

Photo.findByIdAndUpdate(  
    id, 
    { title: 'Photo Title 1 updated', 
    description: 'Photo desc 1 updated'}, 
    { new: true }, // ile konsola yazılan datanın yeni olması sağlanır.
    (err, data) => {  
        console.log(data); 
    } 
);
                    </pre> 
                </p>
                <p>
                    Verileri silmek <br>
                    <pre class="prettyprint ms-0">
const id = '63a5861957e7afe19e3caa81'; 
Photo.findByIdAndDelete(id, (err, data) => { 
    console.log('foto silindi');
}); 
                    </pre>
                </p>
            </div>
            <div class="row" id="requestBody">
                <h1>Request Body Nesnesi</h1>
                <p>
                    add.ejs içindeki form istediğimize uygun hale getirildi.
                </p>
                <p>
                    Form elementine method="POST" ve action="/photos" eklendi.
                </p>
                <p>
                    action="/photos" ile yapılan yönlendirmeyi add.js içinde //Routes altında bu kod ile yakalıyoruz: <br> 
                    <pre class="prettyprint ms-0">
app.post('/photos', (req, res) => { 
    console.log(req.body); 
    res.redirect('/') // yönlendirmesi ile req, res döngüsü sonlandırılır. 
});
                    </pre> ile gelen veri konsola yazdırılmaya çalışıldı ancak <code>undefined</code> alındı. Verinin okunması için 2 adet middleware kullanılır. <br>
                </p>
                <p>
                    verinin doğru okunması için middleware: <br>
                    <pre class="prettyprint ms-0">
app.use(express.urlencoded({extended:true})); // url deki datayı okumamızı sağlar. 
app.use(express.json()); // url deki datayı jsona çevirir.
                    </pre>                 
                </p>
                <p>
                    Bu noktada formdan gelen bilgiyi yakaladık.
                </p>
            </div>
            <div class="row" id="modelVeDinamikIcerik">
                <h1>Model ve Dinamik İçerik</h1>
                <p>
                    kök dizine models klasörü ve içine Photo.js dosyası oluşturuldu.
                </p>
                <p>
                    Photo.js içinde <br>
                    <pre class="prettyprint ms-0">
const mongoose = require('mongoose'); 
const Schema = mongoose.Schema; // ile mongoose ve mongoose.Schema import edildi 

const PhotoSchema = new Schema({ 
    title: String, 
    description: String, 
    image: String, 
    dateCreated: { 
        type: Date, 
        default: Date.now, 
    },
}); // ile şema oluşturuldu ve default date olarak o anki tarih atandı. 

const Photo = mongoose.model('Photo', PhotoSchema); // ile Photo şemasını photos koleksiyonu oluşturmak için kullandık.  

module.exports = Photo // ile export ettik.
                    </pre> 
                </p>
                <p>
                    app.js içine: <br>
                    <pre class="prettyprint ms-0">
const Photo = require('./models/Photo'); // ile import edilir. 
const mongoose = require('mongoose'); // ile mongoose import edilir. 

mongoose.set('strictQuery', true); 
mongoose.connect('mongodb://localhost/pcat-test-db'); // ile database bağlantısı sağlanır. 

app.post('/photos', async (req, res) => { 
    await Photo.create(req.body) 
    res.redirect('/')
}); // daha önce oluşturduğumuz ve formdan veri almamızı sağlayan kod bu şekilde düzenlenir. Bu sayede formdan gelen veri database e kaydedilir.
                    
app.get('/', async (req, res) => {
    const photos = await Photo.find({}).sort('-dateCreated') // ile photos değişkenine databaseten gelen veri atanır. sort içine yazılan parametreye göre veriler sıralanır.
    res.render('index', {
        photos: photos // ile database üzerinden gelen veri kök sayfaya gönderilir.                 
    });
});
                    </pre>
                </p>
                <p>
                    veriyi ilgili template engine içine gömmek için index.ejs içindeki kartların biri hariç hepsini sildik. Kalanı da kendi verimiz için kalıp olarak kullanacağız. 
                </p>
                <p>
                    .ejs içinde js kodu kullanmak için <code><%</code> ile <code>%></code> içine yazılır.
                </p>
                <p>
                    photos içindeki tüm verileri almak için .ejs içinde for döngüsü kurulur. <br>
                    <code>
                        
                    </code>  <br>
                    <pre class="prettyprint ms-0"> 
&lt;% for (let i = 0; i &lt; photos.length; i++ ){ %> &lt;!-- ile for döngüsü başlatılır. --&gt;
    &lt;div class="col-lg-4 col-md-6 col-sm-12 tm-catalog-item"&gt; 
        &lt;div class="position-relative tm-thumbnail-container"&gt; 
            &lt;img src="img/tn-01.jpg" alt="Image" class="img-fluid tm-catalog-item-img"&gt;    
            &lt;a href="video-page.html" class="position-absolute tm-img-overlay"&gt; 
                &lt;i class="fas fa-play tm-overlay-icon"&gt;&lt;/i&gt; 
            &lt;/a&gt; 
        &lt;/div&gt;    
        &lt;div class="p-4 tm-bg-gray tm-catalog-item-description"&gt; 
            &lt;h3 class="tm-text-primary mb-3 tm-catalog-item-title"&gt; &lt;%= photos[i].title %&gt;&lt;/h3&gt; &lt;!-- ile photos[i].title yerleştirildi. --&gt;  
            &lt;p class="tm-catalog-item-text"&gt;&lt;%= photos[i].description %&gt;&lt;/p&gt; &lt;!-- ile photos[i].description yerleştirildi. --&gt;  
        &lt;/div&gt; 
    lt;/div&gt; 
&lt;% } %&gt; &lt;!-- ile for döngüsü sonlandırılır. --&gt;
                    </pre> 
                    
                </p>
    
            </div>
            <div class="row" id="tekilSayfa">
                <h1>Tekil Fotoğraf Sayfaları</h1>
                <p>
                    MongoDB bizim için her kayıt için ıd oluşturuyor. Biz de onu kullanacağız.
                </p>
                <p>
                    index.ejs içinde daha önce düzenlediğimiz kodda altı çizili değişikliği yapıyoruz.<br>
                    <pre class="prettyprint ms-0">
<% for (let i = 0; i < photos.length; i++ ){ %> 
                    
    &lt;div class="col-lg-4 col-md-6 col-sm-12 tm-catalog-item"&gt; 
        &lt;div class="position-relative tm-thumbnail-container"&gt; 
            &lt;img src="img/tn-01.jpg" alt="Image" class="img-fluid tm-catalog-item-img"&gt;    
            &lt;a href="photos/&lt;%= photos[i]._id %&gt;" class="position-absolute tm-img-overlay"&gt; &lt;!-- bu kısımda _id linke eklendi --&gt;
                &lt;i class="fas fa-play tm-overlay-icon"&gt;&lt;/i&gt; 
            &lt;/a&gt; 
        &lt;/div&gt;    
        &lt;div class="p-4 tm-bg-gray tm-catalog-item-description"&gt; 
            &lt;h3 class="tm-text-primary mb-3 tm-catalog-item-title"&gt; &lt;%= photos[i].title %&gt;&lt;/h3&gt; 
            &lt;p class="tm-catalog-item-text"&gt;&lt;%= photos[i].description %&gt;&lt;/p&gt;
        &lt;/div&gt; <br>
    &lt;/div&gt; <br>
                        
<% } %>
                    </pre> <br>
                    Bu sayede verinin id sini yakalıyoruz.
                </p>
                <p>
                  app.js içine <br>
                  <pre class="prettyprint ms-0"> 
app.get('/photos/:id', async (req, res) => { // ile yakaladığımız id üzerinden req alıyoruz. 
    const photo = await Photo.findById(req.params.id) // ile ilgili ıd ye ait veriyi photo değişkenine atadık. 
    res.render('photo', { 
        photo
    })
}); // ile değişkeni photo.ejs ye gönderdik.
                    </pre> 
                </p>
                <p>
                    photo.ejs içinde <br>
                    başlık kısmını <code><%= photo.title %></code> ile ve tanım kısmını <code><%= photo.description %></code> ile değiştiriyoruz.
                </p>
                <p>
                    sayfadaki css yapısındaki bozulmayı düzeltmek için dosya yolunu relative yapacağız. Bunun için partials dosyasında link olarak yazmadığımız tüm linklerin başına / koyuyoruz.
                </p>
    
            </div>
            <div class="row" id="gorselUpload">
                <h1>Görsel Yüklemek</h1>
                <p>
                    Bunun için express-fileupload modülünü kullanacağız. <br>
                    terminale: <br>
                    <pre class="prettyprint ms-0">npm i express-fileupload</pre> <br>
                    app.js core module içine: <br>
                    <pre class="prettyprint ms-0">const fileUpload = require('express-fileupload');</pre> <br>
                    app.js middleware içine: <br>
                    <pre class="prettyprint ms-0">app.use(fileUpload());</pre> <br>
                    add.ejs input içine: <br>
                    <pre class="prettyprint ms-0">name="image" type="file" </pre> <br>
                    add.ejs form içine: <br>
                    <pre class="prettyprint ms-0">encType="multipart/form-data"</pre> forma görsel yüklemeyi sağlar.
                </p>
                <p>
                    <code>
                        app.post('/photos', async (req, res) => {...}
                    </code> kodunun içine: <br>
                    <code>
                        console.log(req.files.image);
                    </code> <br>
                    yazılarak aşağıdaki çıktı konsola yazdırılır. <br>
                    <pre class="prettyprint ms-0">
{
    name: 'car_unsplash.jpg', 
    data: &lt;Buffer ff d8 ff e0 00 10 4a 46 49 46 00 01 01 01 00 48 00 48 00 00 ff e1 00 22 45 78 69 66 00 00 4d 4d 00 2a 00 00 00 08 00 01 01 12 00 03 00 00 00 01 00 01 ... 637876 more bytes&gt;, 
    size: 637926, 
    encoding: '7bit', 
    tempFilePath: '', 
    truncated: false, 
    mimetype: 'image/jpeg', 
    md5: 'bb9f681142d25dee6e6f251188018846', 
    mv: [Function: mv] 
}
                    </pre>
                </p>
                <p>
                    Yukarıda bilgileri alabildiğimizi gördükten sonra app.post(...) aşağıdaki gibi düzenlenir. <br>
                    <pre class="prettyprint ms-0">
app.post('/photos', async (req, res) => {
    const uploadDIR = 'public/uploads'; // ile upload edilecek dosya belirtilir.
    
    if(!fs.existsSync(uploadDIR)){ // eğer dosya yok ise: 
        fs.mkdirSync(uploadDIR) // oluştur. 
    } // Bu işlem tamamlanmadan devam edilmemesi için fonksiyon senkron (Sync) yazılır.  
    
    let uploadedImage = req.files.image; // ile yüklenen dosyanın bilgileri uploadedImage değişkenine atanır.
    let uploadPath = __dirname + '/public/uploads/' + uploadedImage.name; // ile yüklenen dosyanın yüklenme yolu değişkene atanır. Dosya oluşturmak için fs modülü import edilir ve kullanılır.
    uploadedImage.mv(uploadPath, async () => { // ile yüklenen dosyanın ekleneceği yer belirtilrir. 
        await Photo.create({ 
            ...req.body, 
            image: '/uploads/' + uploadedImage.name,
        }); // ile database üzerine veri eklenir. 
    
        res.redirect('/');
    });
});
                    </pre> ile ana sayfaya yönlenirilir ve kod sonlandırılır.
                    
                    Görselin indexte ve tekli foto sayfasında görünmesi için template içine görsel tanımlanır. 
                    <pre class="prettyprint ms-0">img src="<%= photo.image %>"</pre>
    
                </p>
                <p>
                    index sayfasında son eklenenin en üstte görünmesi için <code>.sort()</code> kullanılır. <br>
                    <pre class="prettyprint ms-0">
app.get('/', async (req, res) => { 
    const photos = await Photo.find({}).sort('-dateCreated'); // ile dateCreated verisine göre tersten (azalan) sıralanır. Başında "-" olmasaydı artan sıralanırdı. 
......})
                    </pre>
                </p>    
            </div>
            <div class="row" id="gorselUpdate">
              <h1>Fotoğraf Bilgisi Güncellemek</h1> 
              <p>
                views içine edit.ejs oluşturulur.
              </p>
              <p>
                add.ejs içeriği kopyalanıp edit.ejs içine yapıştırılıp düzenlenir.
              </p>
              <p>
                photo.ejs içinde edit butonu link olarak düzenlenir: <br>
                <code>
                    &lt;<span style="text-decoration: underline;">a href="/photos/edit/&lt;%= photo._id %&gt;"</span> class="btn btn-primary p-0 mb-4 tm-btn-animate tm-btn-download tm-icon-download"&gt;&lt;span>Update Details&lt;/span&gt;<span style="text-decoration: underline;">&lt;/a&gt;</span>
                </code>
              </p>
              <p>
                app.js routes içine: <br>
                <pre class="prettyprint ms-0">
app.get('/photos/edit/:id', async (req, res) => { 
    const photo = await Photo.findOne({ _id: req.params.id }); 
    res.render('edit', { 
        photo, 
    }); 
});
                </pre>
              </p>
              <p>
                edit.ejs içinde title ve description alanları düzenlenir: <br>
                <pre class="prettyprint ms-0">
&lt;div class="form-group"&gt; 
    &lt;input type="text" name="title" value="&lt;%= photo.title %&gt;" class="form-control rounded-0" placeholder="Photo Title"&gt; 
&lt;/div&gt; 
&lt;div class="form-group"&gt; 
    &lt;textarea rows="8" name="description" class="form-control rounded-0" placeholder="Photo Description" required&gt;&lt;%= photo.description %&gt;&lt;/textarea&gt; 
&lt;/div&gt; 
                </pre>   
              </p>
              <p>
                Bu noktada put request (değiştir) işlemine ihtiyacımız var ancak pek çok tarayıcı sadece get ve post request üzerinden çalışır. Bu nedenle put requesti post request ile yapacağız. Bunun için <strong>method-override</strong> modülünü kullanacağız.<br>
                konsola: <br>
                <pre class="prettyprint ms-0">npm i method-override</pre> <br>
                app.js içine core modul:<br>
                <pre class="prettyprint ms-0">const methodOverride = require('method-override');</pre> <br>
                app.js içine middleware:<br>
                <pre class="prettyprint ms-0">app.use(methodOverride('_method'));</pre>
              </p>
              <p>
                edit.ejs form etiketinde action: <br>
                <pre class="prettyprint ms-0">action="/photos/<%= photo._id %>?_method=PUT"</pre> olarak güncellendi. Bu sayede <code>method="POST"</code> olmasına rağmen yöntem PULL olarak request edildi.
              </p>
              <p>
                edit.ejs formdan gelen put requesti karşılama için add.js router içine: <br>
                <pre class="prettyprint ms-0">
app.put('/photos/:id', async (req, res) => {
    const photo = await Photo.findOne({ _id: req.params.id }); 
    photo.title = req.body.title; 
    photo.description = req.body.description; // ile değişiklikleri ekledik. 
    photo.save(); // ile değişiklikleri database e kaydettik. 
    res.redirect(`/photos/${req.params.id}`) // ile fotoğrafın sayfasında döndük. 
});  
                </pre>
              </p>
            </div>
            <div class="row" id="gorselDelete">
                <h1>Fotoğraf Silmek</h1>
                <p>
                    Delete butonunu kullanabilmek için buton link haline getirilir ve aşağıdaki düzenleme yapılır. <br>
                    <pre class="prettyprint ms-0">
&lt;a
    href="/photos/&lt;%= photo._id %&gt;?_method=DELETE" // ile linkten delete request alınır.
    class="btn btn-danger p-0 tm-btn-animate tm-btn-download tm-icon-download"
    onclick="return confirm('ARE YOU SURE?')" // ile delete işlemi için popup comfirm kutusu açılır.
    &gt;
    &lt;span&gt;Delete Photo&lt;/span&gt;
&lt;/a&gt;
                    </pre>  
                </p>
                <p>
                    DELETE metodunun çalışması için middleware alanında kullanılacak metotların belirtilmesi gerekir. İlgili kod aşağıdakine modifiye edilir. <br>
                    <pre class="prettyprint ms-0">
app.use( 
    methodOverride('_method', { 
        methods: ['POST', 'GET'], // ile gerekli metotlar eklenir. 
    })
);
                    </pre>
                </p>
                <p>
                    Delete requestin alınması, ve çalışması için app.js router alanına: <br>
                    <pre class="prettyprint ms-0">
app.delete('/photos/:id', async (req, res) => { // ile delete request karşılanır. 

    const photo = await Photo.findOne({ _id: req.params.id }); // ile silinecek data tanımlanır. 
    let deletedImage = __dirname + '/public' + photo.image; // ile silinecek dosyanın yolu tanımlanır. 
    fs.unlinkSync(deletedImage); // ile dosya silinir. 
    await Photo.findByIdAndRemove(req.params.id); // ile database'ten data silinir. 

    res.redirect('/');
});
                    </pre>
                </p>
                <p>
                    Bu noktada dosya eklemeden data girmeye çalışırsak hata alırız ve server donar. Bunu engellemek için <code>input type="file"</code> alanına <code>required</code> eklenir.
                </p>
                <p>
                    Aynı isimde iki dosya yüklediğimizde upload klasöründe tek dosya oluşuyor. Bunu engelleme için dosya adının başına id veya tarih (<code>Date.now()</code> vs) eklenip uniqe hale getirilebilir. Bunun için tarihi değişkene atamak mantıklı. Aksi takdirde tarihteki saniyelik sapma dosya adını değiştirir.<br>
                </p>
            </div>
            <div class="row" id="MCV">
                <h1>MVC Yeniden Düzenleme</h1>
    
                <h2>MVC Nedir?</h2>
                <p>
                    MVC - Model View Controller - uygulama kodunu Model, View ve Controller olmak üzere birbirine bağlı üç öğeye ayrılmasını içeren bir yazılım mimari yapısıdır.   
                </p>
    
                <h3>Model</h3>
                <p>
                    Uygulamanın veri yapısını ve veri tabanı ile ilişkisini tanımlar. Schema "şablon" yapısı sayesinde veri özellikleri belirlenir.
                </p>
    
                <h3>View</h3>
                <p>
                    Uygulamanın son kullanıcılara görünen bölümünü temsil eder. Son kullanıcıya gösterilecek veri özelleştirilebilir. 
                </p>
    
                <h3>Controller</h3>
                <p>
                    Son kullanıcıdan gelen isteklerin uygun View'e yönlendirilmesi kontrol edilir. İstek, cevap işleyicisi olarak da tanımlanır. 
                </p>
                <p>
                    Kök dizine controllers adında bir klasör oluşturuldu. İçine photoControllers.js dosyası oluşturuldu. app.js içindeki yönlendirme dosyaları bu dosyaya fonksiyon içine atılır. ve export edilir. Fonksiyonun olduğu photoControllers.js app.js içine import edilir. <br>
                    photoController içinde: <br>
                    <pre class="prettyprint ms-0">
exports.getAllPhotos = async (req, res) => { 
    const photos = await Photo.find({}).sort('-dateCreated'); 
    res.render('index', { 
        photos: photos,
    });
    };
                    </pre> ile asenkron fonksiyon app.js içinden taşınılır. <br>
                    <pre class="prettyprint ms-0">const photoController = require('./controllers/photoControllers');</pre> ile photoControllers.js import edilir.<br>
                    yönlendirme için taşınan dosyalar app.js içindeki ilgili yerine import edildiği model ile taşınır. örn:
                    <pre class="prettyprint ms-0">app.get('/', <span style="text-decoration: underline;">photoController.getAllPhotos</span> );</pre> ile fonksiyon çağırılır.
                </p>
                <p>
                    Bu işlem database ile photo fonksiyonunu yönettiğimiz tüm fonksiyonlara uygulanır.
                </p>
                <p>
                    Taşınan fonksiyonların çalışması için gereken modeller de photoControllers.js içine import edilir. <br>
                    <pre class="prettyprint ms-0">const Photo = require('../models/Photo');</pre>
                </p>
                <p>
                    Sadece sayfa çağıran fonksiyonlar ise controllers/pageControllers.js içine taşınır.
                </p>
                <p>
                    Kodu taşıdıktan sonra dosya konumu değiştiği için dosya bağlantılarının da güncellenmesi gerekir.
                </p>
            </div>
            <div class="row" id="pagination">
                <h1>Pagination (Sayfalama)</h1>
                <p>
                    Tüm fotoğrafların anasayfada karşımıza çıkmaması için pagination (sayfalama) kullanılan yöntemlerden biridir.
                </p>
    
                <h2><code>req.query</code></h2>
                <p>
                    req.query bizim tarayıcı üzerinden yaptığımız sorgunun node.js üzerinden algılanmasını sağlar. <br>
                    sorgu örneği: tarayıcıda:<br>
                    <code>
                        http://localhost:3000/?user=test&pass=1234
                    </code> <br>
                    konsolda okumak için: ilgili sayfanın app.get fonksiyonuna:<br>
                    <pre class="prettyprint ms-0">console.log(req.query);</pre> <br>
                    konsoldaki çıktı: <br>
                    <pre class="prettyprint ms-0">{ user: 'test', pass: '1234' } </pre> şeklinde key-value alınır. Buradan alınan değere göre işlem yapılabilir.
                </p>
    
                <h2>PCAT Sayfalama</h2>
                <p>
                    photoControler.js içinde index sayfamızı yöneten asenkron fonksiyon aşağıdaki gibi düzenlenir: <br>
                    <pre class="prettyprint ms-0">
exports.getAllPhotos = async (req, res) => { 
    const page = req.query.page || 1; // ile sayfadan page olarak alınacak sorgu page değişkenine tanımlanır. varsayılan olarak 1 atanır (bunun için veya anlamında || kullanılır.) 

    const photosPerPage = 2; // bir sayfada görünmesi istenilen fotoğraf sayısı değişkene atanır. 
    const totalPhotos = await Photo.find().countDocuments(); // ile toplam veri sayısı değişkene atanır.
                                   
    const photos = await Photo.find({}) 
        .sort('-dateCreated')
        .skip((page-1) * photosPerPage) // ile daha önceki sayfalarda gösterilmesi gerekenler atlanır. 
        .limit(photosPerPage); // ile sayfada gösterilmek istenen kadar veri çekilir. fazlası çekilmez.
                    
                        
    res.render('index', { 
        photos: photos, 
        current: page, // ile mevcut sayfa bilgisi gönderilir. 
        pages: Math.ceil(totalPhotos/photosPerPage) // ile toplam sayfa bilgisi gönderilir. 
    }); 
};
                    </pre>
                </p>
                <p>
                    index.ejs içindeki Catalog Paging Buttons alanı aşağıdaki gibi düzenlenir: <br>
                    <pre class="prettyprint ms-0">
&lt;% if (pages>0){ %> &lt;!-- sayfa sayısı 0dan büyükse butonları ekler.  -->
    &lt;ul class="nav tm-paging-links">
        &lt;% for (i=1; i&lt;=pages; i++){ %>&lt;!-- ile sayfa numaralarını çağırır. Bu işlemi toplam sayfa sayısına kadar tekrarlar.  -->
            &lt;% if(i == current){ %> &lt;!-- ile sayfa numarası açık olan sayfa ile aynı olan butonu aşağıdaki gibi gösterir.  -->
                &lt;li class="nav-item active">&lt;a href="/?page=&lt;%= i %>" class="nav-link tm-paging-link">&lt;%= i %>&lt;/a>&lt;/li>&lt;!-- Link olarak req.query ile page verisini gönderir.  -->
            &lt;% } else { %>&lt;!-- ile yukarıdaki kurala uymayan sayfa numaralarını aşağıdaki gibi gösterir.   -->
                &lt;li class="nav-item">&lt;a href="/?page=&lt;%= i %>" class="nav-link tm-paging-link">&lt;%= i %>&lt;/a>&lt;/li>&lt;!-- Link olarak req.query ile page verisini gönderir.  -->
            &lt;% } %> 
        &lt;% } %> 
    &lt;/ul>
&lt;% } %>
                    </pre>
                </p>
            </div>
            <div class="row" id="atlasCloud">
                <h1>RENDER - MongoDB Atlas Deployment</h1>
    
                <h2>Atlas Cloud</h2>
                <p>
                    Atlas Cloud, mongoDB geliştiriceleri tarafından geliştirilen bir veritabanı bulut hizmetidir, <a href="https://account.mongodb.com/account/login?nds=true">https://account.mongodb.com/account/login?nds=true</a> adresinden giriş yapıyoruz.
                </p>
                <p>
                    sayfaya üye ol > ilerle > new project > create project > build a database > free > ayarlar > create 
                </p>
                <p>
                    kurulan cluster için > connect > connect your application <br>
                    çıkan ekranda yer alan "Add your connection string into your application code" altındaki link app.js içindeki mongoose lokal bağlantı kodunu atlasa yönlendirmek için kullanılır. <br>
                    <code>
                        mongoose.connect('mongodb+srv://arslan_ng:narniag7A.@cluster0.z8aaudl.mongodb.net/pcat-db?retryWrites=true&w=majority');
                    </code>
                </p>
                <p>
                  kablosuz ağ WLRN3 ve WLRN 2 ise bağlanmaz. WINET e geç. 
                </p>
                
                <h2>RENDER</h2>
                <p>
                    <a href="https://render.com/">https://render.com/</a>
                </p>
                <p>
                    üye ol > crate > Web Service 
                </p>
                <p>
                    github ile bağlıyoruz.
                </p>
                <p>
                    RENDER ortamının istediği portu seçebilmesi için:
                    <code>
                        const port = process.env.PORT || 5000;
                    </code>
                </p>
                <p>
                    package.json içinde script alanı: <br>
                    <code>
                        "scripts": { <br>
                            "start": "node app.js" <br>
                          },
                    </code> olarak güncellendi. Bu şekilde nodemon modülü aradan çıkartıldı.
                </p>
                <p>
                    gereksiz yer kaplamaması için video banner fotoğraf ile değiştirildi. video silindi. upload klasöründeki resimler de silindi.
                </p>
                <p>
                    istenilen proje github üzerinden render tarafından çekildi.
                </p>
            </div>
          </div>
          <hr>
          <div class="row smartedu" style="background-color: rgba(198, 197, 197, 0.203);">
            <div class="row" id="Ortam">
              <h1>SmartEdu Ortam Hazırlama</h1>
              <p>
                  Hazır dosyaları temp içine aldık.
              </p>
              <p>
                  konsola: <br>
                  <pre class="prettyprint ms-0">npm init</pre> <br>
                  konsola: <br>
                  <pre class="prettyprint ms-0">npm i express</pre>
              </p>
              <p>
                  app.js içine: <br>
                  express import: <br>
                  <pre class="prettyprint ms-0">
const express = require('express'); 
const app = express();
                  </pre> <br><br>
                  port için: <br>
                  <pre class="prettyprint ms-0">
const port = 3000; 
app.listen(port, ()=>{ 
    console.log(`App started on port ${port}`)
})
                  </pre>
              </p>
              <p>
                  konsola: <br>
                  <pre class="prettyprint ms-0">npm i --save-dev nodemon</pre> veya
                  <pre class="prettyprint ms-0">npm i -D nodemon</pre> geliştirme aracı olarak nodemon yükler.
              </p>
              <p>
                  package.json da "scripts" alanında test silinir ve <br>
                  <code>
                      "start": "nodemon app.js"
                  </code> ile nodemon üzerinden app.js start komutuna işlenir.
              </p>
              <p>
                  daha önceki projeden .prettierrc dosyası bu projeye kopyalanır. Bu sayede her sağ tıklayıp format document dediğimizde .js kod düzenlemesi daha düzenli görünür.
              </p>
              <p>
                  git reposite oluşturuldu ve github ile bağlandı.
              </p>
            </div>
            <div class="row" id="httpStatus">
                <h1>HTTP Status Codes (HTTP Yanıt Durumu Kodları)</h1>
                <p>
                    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">developer.mozilla.org/en-US/docs/Web/HTTP/Status</a>
                </p>
                <p>
                    HTTP status code o an yapılan işlem hakkında bilgi verir.
                </p>
                <h2>Sık Kullanılan Durum Kodları</h2>
                <ul style="list-style-position: inside;">
                    <li>200 - OK</li>
                    <li>201 - Created</li>
                    <li>404 - Not found</li>
                    <li>500 - Internal Server Error</li>
                    <li>400 - Bad Request</li>
                    <li>401 - Unauthorized</li>
                    <li>403 - Forbidden</li>
                    <li>501 - Not Implemented</li>
                </ul>
                <p>
                    örnek html status gönderimi: <br>
                    <pre class="prettyprint ms-0">
app.get('/', (req, res) => { 
    res.status(200).send('index sayfası'); 
});
                    </pre>
                </p>
    
            </div>
            <div class="row" id="template">
                <h1>Template Engine</h1>
                <p>
                    Konsola: 
                    <pre class="prettyprint ms-0">npm i ejs</pre> ile ejs yüklenir <br>
                </p>
                <p> app js Template Engine alanına: <br>
                    <pre class="prettyprint ms-0">app.set("view engine", "ejs");</pre> <br>
                    Statik dosyaları almak için app js Middlewares alanına: <br>
                    <pre class="prettyprint ms-0">app.use(express.static("public"));</pre>  
                </p>
                <p>
                    kök dizine public klasörü oluşturulur ve tempin içindeki .html harici içine eklenir.               
                </p>
                <p>
                    kök dizine views klasörü oluşturulur ve .html dosyalar içine alınır. uzantılar .ejs ye çevirilir.
                </p>
                <p>
                    views içine partials klasörü oluşturulur. Bu alanda tüm sayfalarda ortak olacak kısımlar tutulur. <br>
                    _header.ejs <br>
                    _navigation.ejs <br>
                    _footer ejs gibi. <br>
                    Bunların içine tüm templatelerde ortak olacaklar atanır. sonra buradan çekilir. Bunun için: <br>
                    <pre class="prettyprint ms-0"><%- include('partials/_header'); -%></pre> kalıbı kullanılır.
                </p>
                <p>
                    partials içindeki linkler düzenlenir.
                </p>
                <p>
                    Navbar üzerinden aktif olan sayfanın linkini farklı göstermek için active klası kullanılır. Bunu dinamik olarak yapmak için önce page_name bilgisi app.js içinden response içinde gönderilir. Sonra bu bilgi _navigation.ejs içinde yakalanır ve koşul true ise active olarak dönmesi sağlanır. <br>
                    <pre class="prettyprint ms-0">
app.get('/', (req, res) => { 
    res.status(200).render('index', { 
        page_name: "index"
    });
});
                    </pre> ile page_name: 'index' olarak alınır. 
                    <pre class="prettyprint ms-0">
&lt;li class="nav-item &lt;%= page_name === 'index' && 'active' %>">&lt;a class="nav-link" href="/">Home&lt;/a>&lt;/li> 
&lt;li class="nav-item &lt;%= page_name === 'about' && 'active' %>">&lt;a class="nav-link" href="/about">About Us&lt;/a>&lt;/li>
                    </pre> ile sayfa adı sınanır ve true ise active çıktısı verir.
                </p>
            </div>
            <div class="row" id="routing">
                <h1>Routing</h1>
                <p>
                    ileri okuma için <a href="https://expressjs.com/en/guide/routing.html">tıklayınız.</a>
                </p>
                <p>
                    controllers/pageController.js oluşturuldu.
                </p>
                <p>
                    app.js router alanında router fonksiyonların içindeki req-res fonksiyonlar pageController.js içine taşınır ve buradan export edilir.
                </p>
                <p>
                    routes/pageRouter.js içine pageController require edilir. Bu kısımda route işlemi yapılacağından express modülü de çağırılır.
                </p>
                <p>
                    pageController.js: <br>
                    <pre class="prettyprint ms-0">
const express = require('express') 
const pageController = require('../controllers/pageController') // ile import işlemleri yapılır. 

const router = express.Router() // ile Router() fonksiyonu değişkene atanır. 

router.route('/').get(pageController.getIndexPage) 
router.route('/about').get(pageController.getAboutPage) // ile route işlemleri tanımlanır. 

module.exports = router 
                    </pre> ile değişkene tanımlanan fonksiyon export edilir.
                </p>
                <p>
                  app.js içine router modülü çağırılır. router alanı aşağıdaki gibi düzenlenir: <br>
                  <pre class="prettyprint ms-0">app.use('/', pageRoute);</pre> 
                </p>
            </div>
            <div class="row" id="kursModeli">
                <h1>Kurs Modeli</h1>
    
                <h2>DB Bağlantı</h2>
                <p>
                    konsola: <br>
                    <pre class="prettyprint ms-0">npm i mongoose</pre>
                </p>
                <p>
                    app.js içine mongoose require edilir. <br>
                    <pre class="prettyprint ms-0">const mongoose = require('mongoose');</pre> 
                    Database connect için: <br>
                    <pre class="prettyprint ms-0">mongoose.connect('mongodb://localhost/smartedu-db').then(() => console.log('DB Connected!'));</pre>
                </p>
    
                <h2>Modeller</h2>
                <p>
                    Dinamik olmasını istediğimiz veriler için model oluşturulur.
                </p>
                <p>
                    Model adları genelde büyük yazılır.
                </p>
                <p>
                    models/Course.js oluşturuldu ve içine mongoose import edildi.
                </p>
                <p>
                    <pre class="prettyprint ms-0">
const mongoose = require('mongoose'); 
const Schema = mongoose.Schema;
        
    
const CourseSchema = new Schema({ 
    name: { 
        type: String, // veri tipi string. 
        unique: true, // eşsiz 
        required: true, // doldurulması zorunlu. 
    }, 
    description: { 
        type: String, 
        required: true, 
        trim: true, // Baştaki ve sondaki boşlukları görmezden gel. 
    }
    createdAt: { 
        type: Date, // veri tipi tarih. 
        default: Date.now(), // varsayılan değer olarak işlemin yapıldığı tarihi alır. 
    },
});
                    </pre> ile şema oluşturulur.
                </p>
                <p>
                    <pre class="prettyprint ms-0">
const Course = mongoose.model('Course', CourseSchema); // ile model oluşturuldu 
module.exports = Course; // ile export edildi.
                    </pre> 
                </p>
                
                <h2>Modeli Kullanmak</h2>
                <p>
                    controllers/courseController.js dosyası oluşturuldu. İçine: <br>
                    <pre class="prettyprint ms-0">
exports.createCourse = async (req, res) => { // ile asenkron createCourse fonksiyonu export edilir. 
    try{ // işlemde hata varsa yakalaması için tüm işlem try-catch yapısına taşınır. 
        const course = await Course.create(req.body); // ile yeni kurs yazılır. 
        res.status(201) // ile status code 201-created gönderilir. 
            .json({
                status: 'succest',
                course
            }) // diğer veriler hazır olmadığından şimdilik bu veri gönderilir. 
    } catch (error) { 
        res.status(400) // ile status code 400-bad request gönderilir. 
        .json({
            status: 'fail',
            error,
        });
    }
};
                    </pre>
                </p>
                <p>
                    routes/courseRoute.js oluşturuldu. içine: <br>
                    <pre class="prettyprint ms-0">
const express = require('express') 
const courseController = require('../controllers/courseController') 

const router = express.Router() 

router.route('/').post(courseController.createCourse) // ile post request createCourse fonksiyonunu çalıştırır.

module.exports = router
                    </pre>
                </p>
                <p>
                    app.js içine courseRoute import edilir. routes alanına: <br>
                    <pre class="prettyprint ms-0">app.use('/courses', courseRoute);</pre> eklendi.
                </p>
            </div>
            <div class="row" id="apiPostman">
                <h1>Postman ve API</h1>
    
                <h2>API</h2>
                <p>
                    Application Program Interface
                </p>
                <p>
                    API'ler, iki yazılım bileşeninin belirli tanımlar ve protokoller aracılığıyla birbiriyle iletişim kurmasına olanak tanıyan mekanizmalardır. Örneğin, meteoroloji müdürlüğünün yazılım sistemi, günlük hava durumu verilerini içerir. Telefonunuzdaki hava durumu uygulaması, API'ler aracılığıyla bu sistemle "konuşur" ve telefonunuzda size günlük hava durumu güncellemelerini gösterir. 
                </p>
    
                <h2>Postman</h2>
                <p>
                    Frontend hazır değilken backend tarafını test etmek için kullanılır. requesti simüle eder ve gelen response u gösterir.
                </p>
                <p>
                    <a href="https://www.postman.com/downloads/">postman.com/downloads/</a> -> download ve setup
                </p>
                <p>
                    uygulama içinden + ile yeni untitled request oluşturulur. <br>
                    ilgili request seçilir ve gönderilecek url girilir. <br>
                    ilgili veriler body alanına json olarak yazılır. <br>
                    send ile gönderilir.
                </p>
                <p>
                    Verinin alınması için gelen url req.body üzerinden middleware ile işlenmeli. Bunun için courseController içine middleware olarak: <br>
                    <pre class="prettyprint ms-0">
app.use(express.json()) // for parsing application/json
app.use(express.urlencoded({ extended: true })) // for parsing application/x-www-form-urlencoded
                    </pre>
                </p>
                <p>
                    gelen response uygulamada görülür.
                </p>
            </div>
            <div class="row" id="kursListeleme">
                <h1>Kursları Listelemek</h1>
                <p>
                    courses.ejs template engine göre düzenlenir. courses linki _navigation.ejs içinde güncellenir.
                </p>
                <p>
                    courseRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/').get(courseController.getAllCourses); </pre> eklenir. Bu sayede "/courses" için get request yapılırsa courseController.getAllCourses çağırılır.
                </p>
                <p>
                    courseController.js içine: <br>
                    <pre class="prettyprint ms-0">
exports.getAllCourses = async (req, res) => { 
    try { 
        const courses = await Course.find(); // ile veritabanından tüm kurslar alınır. 

    res.status(200).render('courses', { 
        courses, 
        page_name: 'courses' 
    }); // courses.ejs, courses bilgisi ve page_name bilgisi gönderilir. 

    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error,
        });
    }
}; 
                    </pre>
                </p>
                <p>
                    courses.ejs içindeki kusrların gösterildiği taslaklardan biri bırakıldı. Kalanlar silindi. Bırakılan taslak aşağıdaki for döngüsü içine alındı. <br>
                    <pre class="prettyprint ms-0">
<% for(let i=0; i<courses.length; i++ ){ %> 
    ... 
    taslak 
    ... 
<% } %>
                    </pre>          
                    taslağın name kısmı: 
                    <pre class="prettyprint ms-0"><%= courses[i].name %></pre>
                     
                    desctiption kısmı: 
                    <pre class="prettyprint ms-0"><%= courses[i].description.substring(0, 100) + "..." %></pre> olarak güncellenir. Bu sayede get request ile alınan courses bilgisi kullanılmış olur. .substring(0, 100) metodu ile courses sayfasında description kısmında görünecek karakter sayısı sınırlandırılır.
                </p>
                
            </div>
            <div class="row" id="tekliKurs">
                <h1>Tekil Kurs Sayfası ve Slugify</h1>
    
                <p>
                    course-single.ejs adı course.ejs yapılır ve template engine'e uygun düzenlenir.
                </p>
                <p>
                    courses.ejs içindeki link: <br>
                    <pre class="prettyprint ms-0">/courses/<%= courses[i]._id %></pre>
                </p>
                <p>
                    _navigation.ejs, _header.ejs ve _footer.ejs içindeki lokal linklerin başına / eklenir ki ulaşılabilinsin.
                </p>
                <p>
                    courseRoute.js içinde: <br>
                    <pre class="prettyprint ms-0">router.route('/:id').get(courseController.getCourse);</pre> yönlendirmesi yapılır. /courses/_id olarak gelen get request courseController.getCourse fonksiyonuna yönlendirilir.
                </p>
                <p>
                    courseController.js içine:
                    <pre class="prettyprint ms-0">
exports.getCourse = async (req, res) => { 
    try { 
        const course = await Course.findById({_id: req.params.id}); // ile request olarak gelen id deki course bilgisi course değişkenine atanır. 

        res.status(200).render('course', { 
            course, 
            page_name: 'courses'
        }); // ile course.ejs render edilir ve course değişkenindeki bilgi gönderilir. 

    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error,
        });
    }   
};
                    </pre>
                </p>
                <p>
                    course.ejs içinde uygun alanlara <br>
                    <pre class="prettyprint ms-0"><%= course.name %></pre> ve <br>
                    <pre class="prettyprint ms-0"><%= course.description %></pre> eklenir. Bu sayede course bilgisi sayfada dinamik olarak kullanılır <br>
                    Bu sayfadaki fotoğrafların düzgün çalışması için de img hrefin değişkeninin başına / eklenir.
                </p>
    
                <h2>Slugify</h2>
                <p>
                    Tekil kurs sayfalarını _id parametersi ile çağırdığımızda bu ID url de 6095037e031db830c0a724ee benzer _id parametresinin görünmesine neden olur. Bunun yerinde daha anlamlı olan bir slug ifadesinin bulunmasını isteriz. Bunun için slugify paketinden faydalanacağız.
                </p>
                <p>
                    terminale: <br>
                    <pre class="prettyprint ms-0">npm i slugify</pre>
                </p>
                <p>
                    models/Course.js içine: <br>
                    <pre class="prettyprint ms-0">const slugify = require('slugify');</pre> ile slugfy import edilir. <br>
                    modelin içine: <br>
                    <pre class="prettyprint ms-0">
slug:{ 
    type: String, 
    unique: true 
}
                    </pre> ilave edilir. <br>
                    Modelin altına: <br>
                    <pre class="prettyprint ms-0">
CourseSchema.pre('validate', function(next){
    this.slug = slugify(this.name, {
         // ile isim slug a çevirilir. Bu işlem için arrow fonksiyon kullanılmaz çünkü arrowda this alınmaz. 
        lower: true, // ile hepsi küçük harfe dönüştürülür. 
        strict: true // ile stirng olmayan karakterler atılır. 
    }); 
    next(); // ile fonksiyon bir sonrakine devam ettirilir. 
})
                    </pre>
                </p>
                <p>
                    Sayfayı slug üzerinden request etmek için courses.esj içindeki link: <br>
                    <pre class="prettyprint ms-0">/courses/<%= courses[i].slug %></pre> olarak düzenlenir. <br>
                    Bunu alıp yönlendirecek olan router courseRoute.js içinde: <br>
                    <pre class="prettyprint ms-0">router.route('/:slug').get(courseController.getCourse);</pre> olarak düzenlenir. <br>
                    requesti alıp response yapabilmesi için courseController.js içindeki getCourse fonksiyonunun ilgili kısmı: <br>
                    <pre class="prettyprint ms-0">
exports.getCourse = async (req, res) => { 
    try { 
        const course = await Course.findOne({slug: req.params.slug}); 
        ....
    }
    ...
}
                    </pre> olarak düzenlenir.
                </p>
    
            </div>
            <div class="row" id="kategori">
                <h1>Kategori Oluşturmak ve Listelemek</h1>
                <p>
                    Kategori için model oluşturup, bu modeli course modeli ile bağlayacağız.
                </p>
                <p>
                    models/Category.js oluşturuldu. İçine: (Course.js model alındı.) <br>
                    <pre class="prettyprint ms-0">
const mongoose = require('mongoose'); 
const slugify = require('slugify'); 
const Schema = mongoose.Schema; 

const CategorySchema = new Schema({ 
    name: { 
        type: String, 
        unique: true, 
        required: true, 
    },
    slug: {
        type: String, 
        unique: true, 
    },
}); 

CategorySchema.pre('validate', function (next) { 
    this.slug = slugify(this.name, { 
        lower: true, 
        strict: true, 
    }); 
    next(); 
}); 

const Category = mongoose.model('Category', CategorySchema); 

module.exports = Category;
                    </pre> <br>
                   <p>Course.js <code>CourseSchema</code> içine: </p>
                    <pre class="prettyprint ms-0">
category: { 
    type:mongoose.Schema.Types.ObjectId, 
    ref:'Category' 
}
                    </pre> ilave edilerek course ile category modelleri ilişkilendirilir.
                </p>
                <p>
                  controllers/categoryController.js oluşturuldu. içine: <br>
                  <pre class="prettyprint ms-0">
const Category = require('../models/Category') 

exports.createCategory = async (req, res) => { 
    try { 
        const category = await Category.create(req.body); 

        res.status(201).json({ 
            status: 'succest', 
            category, 
        }); 
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        }); 
    }
};
                  </pre> ile create fonksiyonu oluşturuldu.
                </p>
                <p>
                    routes/courseRoute.js oluşturuldu. içine: <br>
                    <pre class="prettyprint ms-0">
const express = require('express') 
const categoryController = require('../controllers/categoryController') 

const router = express.Router() 

router.route('/').post(categoryController.createCategory); 

module.exports = router
                    </pre> ile post request create fonksiyonuna yönlendirildi.
                </p>
                <p>
                    app.js içine: categoryRoute import edildi. router alanına:<br>
                    <pre class="prettyprint ms-0">app.use('/categories', categoryRoute);</pre> ilave edilir.
                </p>
                <p>
                    postman ile category verisi oluşturuldu. Sonra bu kategorilerle ilişkili course oluşturuldu.
                </p>
                <p>
                    Kategorileri courses sayfasında listelemek için courseController.js içine Category modeli import edilir. getAllCourses içine: <br>
                    <pre class="prettyprint ms-0">const categories = await Category.find();</pre> ile categories değişkenine database içindeki ilgili veri tanımlanır. render fonksiyonu içine eklenerek response edilir. Bu cevap aşağıdaki for döngüsü ile courses.ejs içinde yakalanır.
                </p>
                <p>
                    courses.ejs içinde ilgili alan: <br>
                    <pre class="prettyprint ms-0">
&lt;h3 class="widget-title">Categories&lt;/h3> 
&lt;ul> 
    &lt;% for(let i=0; i&lt;categories.length; i++){ %> 
    &lt;li>&lt;a href="/courses?categories=&lt;%= categories[i].slug %>">&lt;%= categories[i].name %>&lt;/a>&lt;/li> 
    &lt;% } %> 
&lt;/ul>
                    </pre> olarak düzenlendi. link olarak verilen sorgu courseController.js içinde yakalanır ve sadece o kategorideki kursların gönderilmesini sağlar. Bunun için:
                </p>
                <p>
                    courseController.js içinde getAllCourses fonksiyonuna aşağıdaki ekleme yapılır. <br>
                    <pre class="prettyprint ms-0">
const categorySlug = req.query.categories; // ile gönderilen query yakalanır. 

const category = await Category.findOne({slug: categorySlug}) // ile databaseten ilgili Category bulunur. 

let filter = {} 

if(categorySlug){ 
    filter = {category:category._id}
}  // ile queryden veri gelme durumu sorgulanır. Gelmediyse filter değişkeni boş kalır. Değilse slug bilgisi ile databaseten çekilen verinin _id değeri category keyine value olarak atanır.

const courses = await Course.find(filter); // ifadesi güncellenir. if döngüsünden filter dolu çıkarsa buna göre göndereceği verileri filtreler.
                </p>
            </div>
            <div class="row" id="kayitSayfasiVeBcrypt">
                <h1>Kayıt Sayfası ve Bcrypt Paketi</h1>
    
                <h2>Kayıt Sayfası</h2>
                <p>
                    İlk önce register sayfasını oluşturacağız. Buradaki tek amacımız sayfayı görebilmek olduğu için işlemleri pageController.js ve pageRoute.js ile yapacağız.
                </p>
                <p>
                    pageController.js içine: <br>
                    <pre class="prettyprint ms-0">
exports.getRegisterPage = (req, res) => { 
    res.status(200).render('register', { 
        page_name: "register" 
    });
}
                    </pre>
                </p>
                <p>
                    pageRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/register').get(pageController.getRegisterPage)</pre>
                </p>
                <p>
                    register.html register.ejs ye dönüştürülür ve template engine'e göre düzenlenir. _navigation.ejs'deki link düzenlenir: <br>
                    <pre class="prettyprint ms-0">
&lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'register' && 'orange' %>" href="/register">&lt;span>&lt;i class="fa fa-user-plus" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li>
                    </pre>
                </p>
                <p>
                    models/User.js dosyası oluşturulur. İçine: <br>
                    <pre class="prettyprint ms-0">
const mongoose = require('mongoose'); 
const Schema = mongoose.Schema; 

const UserSchema = new Schema({ 
name: { 
    type: String, 
    required: true, 
}, 
email: { 
    type: String, 
    required: true, 
    unique: true, 
}, 
password: { 
    type: String, 
    required: true, 
} 
}); 

const User = mongoose.model('User', UserSchema); 

module.exports = User;
    
                    </pre>
                </p>
                <p>
                    controller/authControler.js dosyası oluşturulur. İçine: <br>
                    <pre class="prettyprint ms-0">
const User = require('../models/User') 

exports.createUser = async (req, res) => { 
    try { 
        const user = await User.create(req.body); 

        res.status(201).json({ 
            status: 'succest', 
            user, 
        }); 
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        });
    }
};
                    </pre> 
                </p>
                <p>
                    routes/userRoute.js oluşturulur. İçine: <br>
                    <pre class="prettyprint ms-0">
const express = require('express') 
const authController = require('../controllers/authController') 

const router = express.Router() 

router.route('/singup').post(authController.createUser); 

module.exports = router
                    </pre>
                </p>
                <p>
                    app.js içine Routes alanına: <br>
                    <pre class="prettyprint ms-0">app.use('/users', userRoute);</pre> eklendi.
                </p>
                <p>
                    register.ejs form alanı aşağıdaki gibi düzenlendi. <br>
                    <code>
                        &lt;form method=<u>"POST" action="users/singup"</u>>
                    </code>
                </p>
    
                <h2>Bcrypt</h2>
                <p>
                    Database'e gönderilen password bilgisini şifrelenmesini sağlar.
                </p>
                <p>
                    terminale: <br>
                    <pre class="prettyprint ms-0">npm i bcrypt</pre>
                </p>
                <p>
                    models/User.ejs içine bcrypt import edilir. new Schema fonksiyonunu altına aşadaki middleware eklenir. <br>
                    <pre class="prettyprint ms-0">
UserSchema.pre('save', function(next){ 
    const user = this; 
    bcrypt.hash(user.password, 10, (error, hash) => { 
        user.password = hash; 
        next(); 
    })
})
                    </pre>
                </p>
                <p>
                    Bu konuyla ilgili ileride karşılaşacağımız hata ve çözümü için <a href="#hata">tıklayın</a>
                </p>
            </div>
            <div class="row" id="giris">
                <h1>Giriş Sayfası ve Giriş İşlemi</h1>
    
                <h2>Giriş Sayfası</h2>
                <p>
                    pageController.js içine: <br>
                    <pre class="prettyprint ms-0">
exports.getLoginPage = (req, res) => { 
    res.status(200).render('login', { 
        page_name: "login" 
    });
}
                    </pre> <br>
                    eklenir
                </p>
                <p>
                    login.html, login.ejs ye dönüştürülür ve template engine'e göre düzenlenir.
                </p>
                <p>
                    _navigation.ejs içinde ilgili kısım: <br>
                    <pre class="prettyprint ms-0">
&lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'login' && 'orange' %> mr-2" href="/login">&lt;span>&lt;i class="fa fa-sign-in" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li>
                    </pre> olarak düzenlenir.
                </p>
                <p>
                    pageRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/login').get(pageController.getLoginPage);</pre> eklenir.
                </p>
    
                <h2>Giriş İşlemi</h2>
                <p>
                    authController.js içine: <br>
                    <pre class="prettyprint ms-0">
const bcrypt = require('bcrypt'); // ile bcrypt import edilir. 

exports.loginUser = async (req, res) => { 
    try { 
        const {email, password} = req.body; // ile formdan email ve password bilgisi alınır.      

        let user = await User.findOne({email: email}) // ile email bilgisi ile db üzerinde user olma durumu kontrol edilir. 

        if(user){ 
            bcrypt.compare(password, user.password, (err, same) =>{ // user var ise password bilgisinin eşleşmesi kontrol edilir. 
                if(same){ 
                    // USER SESSION 
                    res.status(200).send("you are logged in") // password bilgisi eşleşiyorsa "you are logged in" bilgisi sayfaya gönderilir. Daha sonra buraya başka işlem gelecek. 
                }
            })
        }
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        });
    }
};
                    </pre>
                </p>
                <p>
                    authController.js için bilgi göndermesi için login.ejs içindeki form ve userRoute.js düzenlenir. <br>
                    login.ejs: <br>
                    <pre class="prettyprint ms-0">&lt;form method="POST" action="users/login"></pre> olarak güncellenir. <br>
                    userRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/login').post(authController.loginUser);</pre> eklenir.
                </p>
            </div>
            <div class="row" id="session">
                <h1>Session Nedir?</h1>
                <p>
                    Session kavramı Türkçeye oturum olarak çevrilir ve kişiye özel içerik oluşturmak için kullanıcı bilgilerinin sunucu tarafında saklanmasını sağlayan araçlardır. Node.js tarafında express-session paketini kullanacağız. 
                </p>
                <p>
                    session datası sunucuda saklanır. sadece session id cookie içinde saklanır.
                </p>
                <p>
                    terminale: 
                    <pre class="prettyprint ms-0">npm i express-session</pre>
                <p>
                    app.js içine import edilir. <br>
                    <pre class="prettyprint ms-0">var session = require('express-session');</pre> <br>
                    app.js middleware alanına: <br>
                    <pre class="prettyprint ms-0">
app.use(session({ 
    secret: 'keyboard_cat_rambo', 
    resave: false, 
    saveUninitialized: true, 
}))
                    </pre> yazılır.
                </p>
                <p>
                    session bilgisini yakalamak için authController.js loginUser fonksiyonundaki //USER SESSION kısmına: <br>
                    <pre class="prettyprint ms-0">req.session.userID = user._id</pre> eklenir. <br>
                    altındaki responsive komutu da: <br>
                    <pre class="prettyprint ms-0">res.status(200).redirect('/');</pre> olarak index sayfasına yönlendirebilir. <br>
                    İşlemin başarılı olduğunu anlamak için pageController.js getIndexPage fonksiyonu içine <code>console.log(req.session.userID)</code> eklenebilir. 
                </p>
                <p>
                    Bazı bilgilerin loginden sonra bazılarının da loginden önce görünmesini isteriz. Bunun için:
                </p>
                <p>
                    app.js içine // Global Variable alanı oluşturup (middleware alanının üstüne) içine: <br>
                    <pre class="prettyprint ms-0">global.userIN = null;</pre> yazılır. null değeri if içinde false verir. <br>
                    app.js route alanına: <br>
                    <pre class="prettyprint ms-0">
app.use('*', (req, res, next)=>{ 
    userIN = req.session.userID; 
    next();
})
                    </pre> girilir. Bu sayede her durumda userIN, req.session.userID değeri varsa alır. yoksa yine null kalır. herhangi bir response olmadığından next() ile sonraki fonksiyona geçilir.
                </p>
                <p>
                    _navigation.ejs içinde login ve register butonlarının sadece userIN false iken çıkması için: <br>
                    <pre class="prettyprint ms-0">
&lt;% if(!userIN){ %> 
    &lt;ul class="nav navbar-nav navbar-right"> 
        &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'login' && 'orange' %> mr-2" href="/login">&lt;span>&lt;i class="fa fa-sign-in" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li> 
        &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'register' && 'orange' %>" href="/register">&lt;span>&lt;i class="fa fa-user-plus" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li> 
    &lt;/ul> 
&lt;% } %>
                    </pre>
                </p>
                <p>
                    userIN true iken (kullanıcı login yaptığında) logout butonunu görünmesi için: <br>
                    <pre class="prettyprint ms-0">
&lt;% if(userIN){ %> 
    &lt;ul class="nav navbar-nav navbar-right"> 
        &lt;li>&lt;a class="hover-btn-new log &lt;%= page_name === 'login' && 'orange' %> mr-2" href="/login">&lt;span>&lt;i class="fa fa-sign-out" aria-hidden="true">&lt;/i>&lt;/span>&lt;/a>&lt;/li> 
    &lt;/ul> 
&lt;% } %>
                    </pre>
                </p>
                <p>
                    Aynı durum dashboard linki için kullanıcı varsa gösterilecek şekilde uyarlanır: <br>
                    <pre class="prettyprint ms-0">
&lt;% if(userIN){ %> 
    &lt;li class="nav-item">&lt;a class="nav-link" href="dashboard.html">Dashboard&lt;/a>&lt;/li> 
&lt;% } %> 
                    </pre>
                </p>
            </div>
            <div class="row" id="cikis">
                <h1>Çıkış İşlemi</h1>
                <p>
                    authController.js içine: <br>
                    <pre class="prettyprint ms-0">
exports.logoutUser = (req, res) => { 
    req.session.destroy(() => { 
        res.redirect('/'); 
    });
};
                    </pre> <br>
                    userRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/logout').get(authController.logoutUser)</pre><br>
                    _navigation.ejs logout butonu linki: <br>
                    <pre class="prettyprint ms-0">
&lt;ul class="nav navbar-nav navbar-right">
    &lt;li>
        &lt;a class="hover-btn-new log mr-2" <u>href="/users/logout"</u>>
            &lt;span>&lt;i class="fa fa-sign-out" aria-hidden="true">&lt;/i>&lt;/span>
        &lt;/a>
    &lt;/li>
&lt;/ul>
                    </pre>
                </p>
    
                <h2>Connect Mongo</h2>
                <p>
                    Burada şöyle bir sorunumuz var, sunucuyu tekrar başlattığımızda ilgili session yani oturumu kaybediyoruz. Bunun engellemek için connect-mongo paketini indireceğiz. Bu sayede session bilgilerini mongoDB üzerinde saklayabilyoruz. Sonrasında ise bu session bilgisini kaydedeceğimiz veritabanı bağlantısını yazacağız.
                </p>
                <p>
                    terminale:
                    <pre class="prettyprint ms-0">npm i connect-mongo</pre>
                </p>
                <p>
                    app.js içine import için:
                    <pre class="prettyprint ms-0">const MongoStore = require('connect-mongo'); </pre>
                    app.js middleware alanına: app.use(session({ içine
                    <pre class="prettyprint ms-0">store: MongoStore.create({ mongoUrl: 'mongodb://localhost/smartedu-db' })</pre> parametre olarak eklenir.
                </p>
                <p>
                    Bu işlemden sonra sunucu bağlantısı kopup yeniden de bağlansa kullanıcı login ise login kalır.
                </p>
            </div>
            <div class="row" id="kullaniciSayfasi">
                <h1>Kişiye Özel İçerik</h1>
                <p>
                    dashboard.esj dosyası template engine'e göre düzenlenir.
                </p>
                <p>
                    işlem login işlemi ile yapılacağından işlemleri login işlemine uyumlu dosyalara yerleştirilecek.
                </p>
                <p>
                    authController.js içine: <br>
                    <pre class="prettyprint ms-0">
exports.getDashboardPage = (req, res) => { 
    res.status(200).render('dashboard', { 
        page_name: "dashboard" 
    });
}
                    </pre>
                </p>
                <p>
                    _navigation içinden dashboard linki: "/users/dashboard" olarak güncellenir ve class active bilgisi için düzenleme yapılır. <br>
                    <pre class="prettyprint ms-0">
&lt;li class="nav-item &lt;%= page_name === 'dashboard' && 'active' %>">&lt;a class="nav-link" href="/users/dashboard">Dashboard&lt;/a>&lt;/li>
                    </pre>
                </p>
                <p>
                    userRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/dashboard').get(authController.getDashboardPage);</pre>
                </p>
                <p>
                    authController.js içindeki loginUser fonksiyonunun redirect adresi '/users/dashboard' olarak güncellendi.
                </p>
                <p>
                    dashboard sayfasına user bilgisini göndermek için authController.js içindeki getDashboardPage fonksiyonu aşağıdaki gibi güncellenir. <br>
                    <pre class="prettyprint ms-0">
exports.getDashboardPage = async(req, res) => { 
    const user = await User.findOne({_id: req.session.userID}) 
    res.status(200).render('dashboard', { 
        page_name: "dashboard", 
        user: user 
    });
}
                    </pre>
                </p>
                <p>
                    dashboard.ejs içine ilgili yere <br>
                    <pre class="prettyprint ms-0"><%= user.name %></pre> eklenerek bilgi sayfaya yerleştirilir.
                </p>
    
    
            </div>
            <div class="row" id="ozelMiddleware">
                <h1>Özel Middleware</h1>
                <p>
                    login ve logout durumuna göre görünmesini istemediğimiz sayfaların linklerinin başka sayfaya redirect yapması için middleware yazacağız.
                </p>
    
                <h2>Logout durumunda kullanılmayacak linkler</h2>
                <p>
                    <strong>/users/dashboard</strong>
                </p>
                <p>
                    middleware/authMiddleware.js dosyası oluşturulur. İçine: <br>
                    <pre class="prettyprint ms-0">
const User = require('../models/User'); 
    
module.exports = (req, res, next) => { // ile tüm içerik export edilir. 
    User.findById(req.session.userID, (err, user) => { // ile user sorgulanır. 
        if (err || !user) return res.redirect('/login'); // user yoksa '/login' sayfasına yönledirilir. 
        next(); // ile if geçersizse sonraki fonksiyona geçilir.
    });
}; 
                    </pre>
                </p>
                <p>
                    userRoute.js içine authMiddleware import edilir. <br>
                    <pre class="prettyprint ms-0">const authMiddleware = require('../middlewares/authMiddleware');</pre>
                </p>
                <p>
                    userRoute.js dashboard route fonksiyonu aşağıdaki gibi güncellenir. <br>
                    <pre class="prettyprint ms-0">router.route('/dashboard').get(authMiddleware, authController.getDashboardPage);</pre> ilk fonksiyon "authMiddleware" next alırsa (if geçersizse) işlem sonrakine geçer. Yoksa authMiddleware içindeki res.redirect('/login'); çalışır.
                </p>
    
                <h2>Login durumunda kullanılmayacak linkler</h2>
                <p>
                    <strong>
                        /login <br>
                        /register
                    </strong>
                </p>
                <p>
                    middleware/redirectMiddleware.js dosyası oluşturulur. İçine: <br> 
                    <pre class="prettyprint ms-0">
module.exports = (req, res, next) => { 
    if (req.session.userID) return res.redirect('/'); 
    next();
};
                    </pre>
                </p>
                <p>
                    pageRoute.js içine redirectMiddleware import edilir. <br>
                    <pre class="prettyprint ms-0">const redirectMiddleware = require('../middlewares/redirectMiddleware');</pre>
                </p>
                <p>
                    pageRoute.js içinde güncelleme yapıldı. 
                    <pre class="prettyprint ms-0">
router.route('/register').get(redirectMiddleware ,pageController.getRegisterPage); 
router.route('/login').get(redirectMiddleware ,pageController.getLoginPage);
                    </pre>
                </p>
            </div>
            <div class="row" id="kullaniciRolleri">
                <h1>Kullanıcı Rolleri</h1>
                <p>
                    Önce models/user.js içine role bilgisi eklenir. <br>
                    <pre class="prettyprint ms-0">
role: { 
    type: String, 
    enum: ["student", "teacher", "admin"], 
    defult: "student", 
},
                    </pre>
                </p> 
                <p>
                    Bilginin alınması için register.ejs form içine: <br>
                    <pre class="prettyprint ms-0">
&lt;div class="offset-1 col-lg-10 col-md-10 col-sm-10"> 
    &lt;select class="form-control" name="role" id=""> 
        &lt;option>student&lt;/option> 
        &lt;option>teacher&lt;/option> 
    &lt;/select> 
&lt;/div>
                    </pre>
                </p>
                <p>
                    middlewares/roleMiddleware.js içine: br
                    <pre class="prettyprint ms-0">
module.exports = (roles) => { // fonksiyonun kullanıldığı yerde argüman olarak bu parametre (roles) array şeklinde kullanılacak. 
    return (req, res, next) => { 
        const userRole = req.body.role; 
        if(roles.includes(userRole)) { 
            next(); 
        } else { 
            return res.status(401).send('YOU CANT DO THIS');
        }
    }
}
                    </pre> 
                </p>
                <p>
                    courseRoute createCourse yönlendirmesine admin veya teacher olma şartı konulur: <br>
                    <pre class="prettyprint ms-0">router.route('/').post(roleMiddleware(["teacher", "admin"]), courseController.createCourse);</pre>
                </p>
                <p>
                    register ekranında kayıt sonrası login sayfasına yönlendirmesi için, authController.js içinde createUser respose değeri aşağıdaki gibi güncellenir. <br>
                    <pre class="prettyprint ms-0">
exports.createUser = async (req, res) => { 
    try { 
        const user = await User.create(req.body); 
    
        <u>res.status(201).redirect('/login')</u> 

    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        });
    }
};
                    </pre>
                </p>
                <p>
                    user.role bilgisine göre /dashboard içinde içeriği ayarlamak için if(user.role === '') kalıbı kullanılabilir. <br>
                    <pre class="prettyprint ms-0">
&lt;% if (user.role === 'student'){ %> 
    &lt;div class="all-title-box"> 
        &lt;div class="container text-center"> 
            &lt;h1>&lt;%= user.name %>&lt;span class="m_1">STUDENT&lt;/span>&lt;/h1> 
        &lt;/div> 
    &lt;/div> 
&lt;% } %>	 
&lt;% if (user.role === 'teacher'){ %> 
    &lt;div class="all-title-box"> 
        &lt;div class="container text-center"> 
            &lt;h1>&lt;%= user.name %>&lt;span class="m_1">Teacher&lt;/span>&lt;/h1> 
        &lt;/div> 
    &lt;/div> 
&lt;% } %>	
                    </pre>
                </p>
            </div>
            <div class="row" id="courseCreate">
                <h1>Kurs Oluşturmak</h1>
                <p>
                    dashboard.ejs if (user.role === 'student') iken görünecek kısmı yukarıda, if (user.role === 'teacher') iken görünecek kısmı aşağıda olacak şekilde tekrar düzenlenir.
                </p>
                <p>
                    dashboard.ejs teacher kısmına buton eklenir: <br>
                    <pre class="prettyprint ms-0">
&lt;div class="col-lg-12 text-center "> 
    &lt;button class="btn btn-lg btn-warning rounded-0 text-white" href="#" data-toggle="modal" data-target="#addCourse">&lt;span>CREATE NEW COURSE&lt;/span>&lt;/button> 
&lt;/div>
                    </pre> <br>
                    data-target="#addCourse" sayfanın sonuna eklediğimiz modal'a işaret eder. modal tarafında id="addCourse" yer almalıdır.
                </p>
                <p>
                    Modal içinde daha önceden oluşturduğumuz kategorileri görebilmek için authController.ejs içine Categories import edilir. dashboard içine göndermek için getDashboardPage fonksiyonuna tüm categories çağırılır ve render kısmına eklenerek gönderilir. <br>
                    <pre class="prettyprint ms-0">
exports.getDashboardPage = async(req, res) => { 
    const user = await User.findOne({_id: req.session.userID}) 
    <u>const categories = await Category.find()</u>  
    res.status(200).render('dashboard', { 
        page_name: "dashboard", 
        user: user, 
        <u>categories: categories</u>
    });
}
                    </pre> <br>
                    Bunu yakalamak için dashboard.ejs modal form kısmında for döngüsü kullanılır. <br>
                    <pre class="prettyprint ms-0">
&lt;select class="form-control" name="category"> 
    &lt;u>
        &lt;% for (let i=0; i&lt; categories.length; i++) { %> 
        &lt;option value="&lt;%= categories[i]._id %>">&lt;%= categories[i].name %>&lt;/option> 
        &lt;% } %> 
    &lt;/u>		
&lt;/select>
                    </pre>
                </p>
                <p>
                    formu post ederken form tagı içinde: <br>
                    <pre class="prettyprint ms-0">method="POST" action="/courses</pre> girilmeli
                </p>
                <p>
                    createCourse route aşamasında (courseRoute.ejs içinde) user.role sorgular. Bunu da form içinde göndermemiz gerekir. bunun için form alanının içine: <br>
                    <pre class="prettyprint ms-0">
&lt;div class="form-group"> 
    &lt;div class="col-sm-12"> 
        &lt;input type="hidden" name="role" class="form-control"  value="&lt;%= user.role %>"> 
    &lt;/div> 
&lt;/div>
                    </pre> <br>
                    ekleriz.
                </p>
                <p>Kurs yaratıldığında courses sayfasına yönlendirmesi için ilgili redirect createCourse fonksiyonunda düzenlenir: <br>
                <pre class="prettyprint ms-0">
exports.createCourse = async (req, res) => { 
    try { 
        const course = await Course.create(req.body); 
        
        res.status(201).<u>redirect('/courses');</u>
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        });
    }
};
                </pre></p>
                <p>
                    Oluşturulan kursların /courses sayfasında son oluşturulanın en üstte görünmesi için courseController.js içinde getAllCourses fonksiyonudaki const courses = await Course.find(filter) ibaresine ".sort('-createdAt');" eklenir. <br> 
                    <pre class="prettyprint ms-0">const courses = await Course.find(filter).sort('-createdAt');</pre>
                </p>
    
                <h2>Kullanılan Modal</h2>
                <p>
                    <code>
                        dashboard.ejs içinden görülebilir.
                    </code>
                </p>
            </div>
            <div class="row" id="kursOgretmen">
                <h1>Kurs - Öğretmen İlişkisi</h1>
                <p>
                    Course.js modeline <br>
                    <pre class="prettyprint ms-0">
user: { 
    type:mongoose.Schema.Types.ObjectId, 
    ref:'User' 
}
                    </pre> eklenir.
                </p>
                <p>
                    courseController.ejs içinde createCourse içinde mevcut user yakalanır: <br>
                    <pre class="prettyprint ms-0">
const course = await Course.create({ 
    name: req.body.name, 
    description: req.body.description, 
    category: req.body.category, 
    user: req.session.userID 
});
                    </pre>
                </p>
                <p>
                    user bilgisine uygun olan coursesi dashboarda eklemek için authController.ejs getDashboardPage fonksiyonuna courses aktif kullanıcıya göre filtrelenerek tanımlanır: <br>
                    <pre class="prettyprint ms-0">const courses = await Course.find({user: req.session.userID})</pre> <br>
                    ve render fonksiyonu içinde gönderilir: <br>
                    <pre class="prettyprint ms-0">
res.status(200).render('dashboard', { 
    page_name: "dashboard", 
    user: user, 
    categories: categories, 
    <u>courses: courses</u> 
});
                    </pre>
                </p>
                <p>
                    dashboard.ejs içinde courses bilgisi for döngüsü ile yakalanır ve her course için name ve description ilgili alanlara konulur. <br>
                    <pre class="prettyprint ms-0">
&lt;% for(let i=0; i&lt;courses.length; i++){ %> 
...
    &lt;%= courses[i].name %>
...
    &lt;%= courses[i].description %>
...
&lt;% } %>
                    </pre>
                </p>
                <p>
                    Tekli kurs sayfasında course.user bilgisinden user.name alabilmek için courseController.ejs içinde getCourse fonksiyonunda aşağıdaki güncelleme yapılır: <br>
                    <pre class="prettyprint ms-0">const course = await Course.findOne({ slug: req.params.slug })<u>.populate('user');</u></pre> <br>
                    user name bilgisi için: <br>
                    <pre class="prettyprint ms-0"><%= course.user.name %></pre>
                </p>
            </div>
            <div class="row" id="kursOgrenci">
                <h1>Kurs - Öğrenci İlişkisi</h1>
                <p>
                    Öğrencinin kurslara kayıt olası, kendi dashboard sayfasında katıldığı kursları görmesi ve yönetmesi işlemleri
                </p>
                <p>
                    User.js içinde UserSchema alanına aşağıdaki course bilgisi eklenir: <br>
                    <pre class="prettyprint ms-0">
courses: [{ 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Course' 
}]
                    </pre> courses array olarak oluşturuldu. Course.js modeli ile bağlandı.
                </p>
    
                <h2>Enroll işlemi</h2>
                <p>
                    course.ejs içine aşağıdaki form eklendi: <br>
                    <pre class="prettyprint ms-0">
&lt;form method="POST" action="/courses/enroll"> 
    &lt;input type="hidden" name="course_id" value="&lt;%= course._id %>"> 
    &lt;button class="btn btn-large btn-warning text-white">&lt;span>ENROLL&lt;/span>&lt;/button> 
&lt;/form> 
                    </pre>
                </p>
                <p>
                    courseController.js içinde aşağıdaki fonksiyon yazıldı: <br>
                    <pre class="prettyprint ms-0">
exports.enrollCourse = async (req, res) => { 
    try { 
        const user = await User.findById(req.session.userID);// ile şu an aktif olan user bilgisi alındı. 
        await user.courses.push({_id: req.body.course_id}); // ile tıklanılan sayfanın course_id bilgisi user.courses kısmına eklendi. 
        await user.save(); // ile user için yapılan değişiklik kaydedildi. 
        res.status(200).redirect('/users/dashboard');
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        });
    }
};
                    </pre>
                </p>
                <p>
                    courseRoute.j içine aşağıdaki kod eklenerek course.ejs ile ourseController.enrollCourse fonksiyonu bağlandı.<br>
                    <pre class="prettyprint ms-0">router.route('/enroll').post(courseController.enrollCourse);</pre>
                </p>
                <p>
                    user'a kayıtlı courses bilgisini almak için authController.js içindeki getDashboardPage fonksiyonunun ilgili kısmına .populate('courses'); eklenir. <br>
                    <pre class="prettyprint ms-0">
exports.getDashboardPage = async(req, res) => { 
    const user = await User.findOne({_id: req.session.userID})<u>.populate('courses');</u> 
    ...
                    </pre> 
                </p>
                <p>
                    dashboard.ejs student kısmında aşağıdaki for döngüsü yazılır ve ilgili bilgiler ilgili kısımlara girilir. <br>
                    <pre class="prettyprint ms-0">
<% for(let i=0; i<user.courses.length; i++){ %> 
    ... 
    ...<%= user.courses[i].name %>... 
    ...<%= user.courses[i].slug %>... 
    ...<%= user.courses[i].description %>... 
    ... 

<% } %>
                    </pre>
                </p>
                <hr>
                <p>
                    gelişim sürecinde modellerimiz üzerinde de değişiklik yaptık. Database üzerine eski tarihli gönderdiğimiz verilerde bu bilgiler eksik kaldı. Bu nedenle categories alanı hariç database i temizledik. Yenilerini oluşturduk.
                </p>
                <hr>
    
                <h2>Release</h2>
                <p>
                    dashboard student kısmında description kısmının altına aşağıdaki buton eklenir: <br>
                    <pre class="prettyprint ms-0">
&lt;form method="POST" action=<u>"/courses/release"</u>> 
    &lt;input type="hidden" name="course_id" value=<u>"&lt;%= user.courses[i]._id %>"</u>> 
    &lt;button class="btn btn-large btn-danger text-white">&lt;span>RELEASE&lt;/span>&lt;/button> 
&lt;/form>
                    </pre>
                </p>
                <p>
                    courseController.js içine releaseCourse fonksiyonu yazılır. <br>
                    <pre class="prettyprint ms-0">
exports.releaseCourse = async (req, res) => { 
    try { 
        const user = await User.findById(req.session.userID); 
        await user.courses<u>.pull</u>({_id: req.body.course_id}); 
        await user.save(); 
        res.status(200).redirect('/users/dashboard'); 
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        });
    }
};                      
                    </pre>
                </p>
                <p>
                    courseRoute içinde aşağıdaki yönlendirme ile buton ile fonksiyon bağlanır. <br>
                    <pre class="prettyprint ms-0">router.route('/release').post(courseController.releaseCourse);</pre>
                </p>
    
                <h2>Alınan kursta enrol butonunun görünmemesi için:</h2>
                <p>
                    courseController.js getCourse içinde user bilgisi göndermek için: <br>
                    <pre class="prettyprint ms-0">
exports.getCourse = async (req, res) => { 
    try { 
        const user = await User.findById(req.session.userID); 
        ... 
                    </pre> yazılır ve user render içinde gönderilir.
                </p>
                <p>
                    course.ejs içindeki enroll butonu if bloğuna alınır: <br>
                    <pre class="prettyprint ms-0">
&lt;% if(user && !user.courses.includes(course._id)) { %> 
    ...ENROLL... 
&lt;% } %> 
                    </pre> user bilgisi hiç yoksa veya user.courses içinde olduğumuz course için _id içeriyorsa buton görünmez.
                </p>
            </div>
            <div class="row" id="search">
                <h1>Search Alanı</h1>
                <p>
                    courses.ejs search alanı aşağıdaki gibi düzenlenir: <br>
                    <pre class="prettyprint ms-0">
&lt;div class="widget-search"> 
    &lt;div class="site-search-area"> 
        &lt;form <u>method="GET"</u> id="site-searchform" <u>action="/courses"></u> 
        &lt;div> 
            &lt;input class="input-text form-control" <u>name="search"</u> id="search-k" placeholder="Search..." type="text"> 
            <u>&lt;button</u> id="searchsubmit" value="Search" <u>type="submit">&lt;/button></u> 
        &lt;/div> 
        &lt;/form> 
    &lt;/div> 
&lt;/div>
                    </pre>
                </p>
                <p>
                    Buradan gelen bilgi courseRoute.js üzerinden courseController.getAllCourses fonksiyonuna aktarılır. 
                </p>
                <p>
                    Bilginin filtrelemede kullanılması için fonksiyon aşağıdaki hale güncellenir.
                    <pre class="prettyprint ms-0">
exports.getAllCourses = async (req, res) => { 
    try { 
        const categorySlug = req.query.categories; 
        const query = req.query.search;  // ile search alanındaki bilgi alınır.         
        const category = await Category.findOne({slug: categorySlug}) 
        let filter = {} 
        if(categorySlug){ 
            filter = {category:category._id} 
        } 
        if(query) {  // query varsa 
            filter = {name:query} // filter.name olarak atanır. 
        } 
    
        if(!query && !categorySlug){
            filter.name = "" 
            filter.category = null 
        } 
    
        const courses = await Course.find({ 
            $or:[ // bu ifade mongodb için veya demek. 
                {name: {$regex: '.*' + filter.name + '.*', $options: 'i'}}, // ile name başı ve sonu farketmeksizin filter.name ifadesini içerenleri sorgular. 
                {category: filter.category} 
            ] 
        }).sort('-createdAt'); 
        
        const categories = await Category.find(); 
        
        res.status(200).render('courses', { 
            courses, 
            categories, 
            page_name: 'courses', 
        }); 
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        });
    }
    };
                    </pre>
    
                    <p>
                        courses.ejs içindeki search alanı aynı şekilde course.ejs için de kullanılır.
                    </p>
                    <p>
                        courses.ejs içindeki Categories alanı aynı şekilde course.ejs için de kullanılır. Çalışması için courseController.getCourse içinde <br>
                        <pre class="prettyprint ms-0">const categories = await Category.find();</pre> eklenir ve
                        render içinde categories gönderilir.
                    </p>
                    <p>
                        courses sayfasında kursu oluşturan teacher kullanıcının adını görmek için courseController.getAllCourses fonksiyonundaki ilgili kısım aşağıdaki gibi güncellenir.<br>
                        <pre class="prettyprint ms-0">
const courses = await Course.find({ 
    $or:[ 
        {name: {$regex: '.*' + filter.name + '.*', $options: 'i'}}, 
        {category: filter.category} 
    ] 
    }).sort('-createdAt')<u>.populate('user')</u>;
                        </pre>
                    </p>
                    <p>
                        .populate('user') ile courses ile gönderilen user bilgisini almak için courses.ejs içindeki ilgili alana: 
                        <pre class="prettyprint ms-0"><%= courses[i].user.name %> eklenir.</pre>
                    </p>
                </p>
            </div>
            <div class="row" id="contactAndMail">
                <h1>İletişim Sayfası ve Mail Göndermek</h1>
    
                <h2>İletişim Sayfası</h2>
                <p>
                    contact.html contact.ejs ye dönüştürülür.
                </p>
                <p>
                    contact.ejs template engine'e göre düzenlenir.
                </p>
                <p>
                    _navigation.ejs içinde ilgili linkler düzenlenir. <br>
                    <pre class="prettyprint ms-0">
&lt;li class="nav-item &lt;%= page_name === 'contact' && 'active' %>">&lt;a class="nav-link" href="/contact">Contact&lt;/a>&lt;/li>
                    </pre>
                </p>
                <p>
                    pageRoute.js içinde ilgili yönlendirme yapıldı. <br>
                    <pre class="prettyprint ms-0">router.route('/contact').get(pageController.getContactPage);</pre>
                </p>
                <p>
                    pageController.js içinde getContactPage fonksiyonu yazılır. <br>
                    <pre class="prettyprint ms-0">
exports.getContactPage = (req, res) => {
    res.status(200).render('contact', {
        page_name: "contact"
    });
}
                    </pre>
                </p>
                <p>
                    contact.ejs içindeki form isteğe göre düzenlenir. Bize name, email ve message yeterli. Form ayarlarını da aşağıdaki gibi düzenleriz: <br>
                    <pre class="prettyprint ms-0">
&lt;form id="contactform" action="/contact" method="POST"> 
    ..... 
    ..... 
&lt;/form>
                    </pre>
                </p>
                <p>
                    formdan gelen bilgiyi almak için (şimdilik konsola yazdıracağız) pageController.js içinde sendEmail fonksiyonu yazılır. <br>
                    <pre class="prettyprint ms-0">
exports.sendEmail = (req, res) => { 
    console.log(req.body); 
}
                    </pre>
                </p>
                <p>
                    formdan gelen bilgi routeController.js içinden ilgili fonksiyona yönlendirilir. <br>
                    <pre class="prettyprint ms-0">router.route('/contact').post(pageController.sendEmail);</pre>
                </p>
    
                <h2>Mail Göndermek</h2>
                <p>
                    Bunun için ücretli servisler var. Biz bu uygulamada gmailin ücretsiz hizmetinden faydalanacağız. Bunun için kendi mail adresimizi kullanacağız.
                </p>
                <p>
                    Mail göndermek için önce nodemailer adında bir node modülü kullanacağız.
                </p>
                <p>
                    terminale: <br>
                    <pre class="prettyprint ms-0">npm i nodemailer</pre>
                </p>
                <p>
                    modül pageController.js çine import edilir. <br>
                    <pre class="prettyprint ms-0">const nodemailer = require("nodemailer");</pre>
                </p>
                <p>
                    pageController.sendEmail fonksiyonu aşağıdaki gibi düzenlenir. <br>
                    <pre class="prettyprint ms-0">
exports.sendEmail = async(req, res) => { 

    const outputMessage = ` 
    &lt;h1>Mail Details&lt;/h1> 
    &lt;ul> 
        &lt;li>Name: ${req.body.name}&lt;/li> 
        &lt;li>Email: ${req.body.email}&lt;/li> 
    &lt;/ul> 
    &lt;h1>Message&lt;/h1> 
    &lt;p>${req.body.message}&lt;/p> 
    `; //  bu kısım mailimizin gövdesi olacak. <br>
                    
    let transporter = nodemailer.createTransport({ 
        host: "smtp.gmail.com", //  gmaile yönlendiriyoruz. 
        port: 465, //  portu 465 e ayarlıyoruz. 
        secure: true, //  true for 465, false for other ports 
        auth: { 
            user: "drmuratgokduman@gmail.com", //  gmail accont: maili gönderecek olan adres 
            pass: "eqocuuyuqcrxxyhc" //  gmail password yerine google account içinde güvenlik kısmında uygulama şifrelerine girilir ve uygulama şifresi oluşturulur. uygulama: posta cihaz: windows bilgisayar 
        }, 
    }); 
    
    let info = await transporter.sendMail({ 
        from: '"Smart Edu Contact Form" &lt;drmuratgokduman@gmail.com>',  //  gönderen adres 
        to: "drmuratgokduman@gmail.com", //  alan adres 
        subject: "Smart Edu Contact Form New Message ✔", //  konu 
        html: outputMessage, // mesajın gövdesi: yukarıda oluşturmuştuk 
    }); 
    
    console.log("Message sent: %s", info.messageId);           
    console.log("Preview URL: %s", nodemailer.getTestMessageUrl(info));         
    res.status(200).redirect('contact'); 
    }
                    </pre>
                </p>
                <p>
                    nodemailer <a href="https://nodemailer.com/about/">anasayfasında</a> konuyla ilgili başka mail opsiyonları da var (cc, bcc, dosya eki vs)
                </p>
    
    
                
            </div>
            <div class="row" id="bildirim">
                <h1>Flash Bildirimleri</h1>
                <p>
                    Projemizde herhangi bir şekilde bir değişiklik yaptığımızda, yeni bir kurs oluşturduğumuzda veya mail gönderimi gibi işlemler sonucunda kullanıcıya geri bildirimde bulunmak için kullanılır.
                </p>
                <p>
                    Bu işlem için connect-flash modülü kullanılır.
                </p>
                <p>
                    terminale: <br>
                    <pre class="prettyprint ms-0">npm i connect-flash</pre>
                </p>
                <p>
                    app.js içine import edilir. <br>
                    <pre class="prettyprint ms-0">const flash = require('connect-flash');</pre>
                </p>
                <p>
                    app.js middleware alanına: <br>
                    <pre class="prettyprint ms-0">app.use(flash());</pre>
                </p>
                <p>
                    flash dan gelen mesajı lokalde bir değişkene kaydetmek için middleware alanına: <br>
                    <pre class="prettyprint ms-0">
app.use((req, res, next)=>{ 
    res.locale.flashMessages = req.flash(); 
    next(); 
})
                    </pre>
                </p>
    
                <h2>Mail gönderimi sonrası bildirim göndermek:</h2>
                <p>
                    pageController.sendMail fonksiyonunun içine en sondaki redirect komutundan önce: <br>
                    <pre class="prettyprint ms-0">req.flash("success", "We received your message succesfuly");</pre> eklenir.
                </p>
                <p>
                    Başarısız işlemlerde hata mesajı yazdırabilmek için pageController.sendMail fonksiyonunun içeriği try catch bloğuna alınır. catch kısmına: <br>
                    <pre class="prettyprint ms-0">
req.flash("error", "Something happened!"); 
res.status(200).redirect('contact');
                    </pre> eklenir.
                </p>
                <p>
                    Mesajı contact.ejs içinde görmek için istenilen yere: <br>
                    <pre class="prettyprint ms-0">
&lt;% if(flashMessages){ %> 
    &lt;% if(flashMessages.success){ %> 
        &lt;div class="alert alert-success"> 
            &lt;%= flashMessages.success %> 
        &lt;/div> 

    &lt;% } else if(flashMessages.error){ %> 
        &lt;div class="alert alert-danger"> 
            &lt;%= flashMessages.error %> 
        &lt;/div> 
    &lt;% } %> 
&lt;% } %>
                    </pre>
                </p>
                <p class="alert alert-warning">
                    Her şey normalken hata alıyorsan ağı kontrol et. şirket ağı bazı fonksiyonları kısıtlıyor.
                </p>
    
                <h2>Kurs oluşturduktan sonra bildirim almak:</h2>
                <p>
                    courseController.courseCreate fonksiyonunda try bloğunun en altındaki redirect fonksiyonundan önce: <br>
                    <pre class="prettyprint ms-0">req.flash('success', `${course.name} Has Been Created Succesfuly`);</pre> eklenir. <br>
                    catch bloğu da aşağıdaki gibi güncellenir. <br>
                    <pre class="prettyprint ms-0">
req.flash('error', `Something Happened!`); 
res.status(400).redirect('/courses');
                    </pre>
                </p>
                <p>
                    flash ile gelen bilgiyi yakalamak için courses.ejs içine mail gönderiminde eklediğimiz kodu kullanabiliriz. Bildirimi görmek istediğimiz yere ekleriz.
                </p>
                
            </div>
            <div class="row" id="dogrulama">
                <h1>Kayıt ve Kullanıcı Doğrulama</h1>
                <p>
                    Doldurulması zorunlu alanlar için html input kodlarına öz nitelik olarak required eklenebilir.
                </p>
                <p>
                    Biz bu çalışmada express-validator modülü ile form kontrolü yapacağız.
                </p>
                <p>
                    terminale: <br>
                    <pre class="prettyprint ms-0">npm i express-validator</pre>
                </p>
    
                <h2>Sing Up sayfasında form denetimi:</h2>
                <p>
                    userRoute.js içine import edilir: <br>
                    <pre class="prettyprint ms-0">const { body } = require('express-validator');</pre> bize bu kısımda sadece body fonksiyonu gerekecek.
                </p>
                <p>
                    userRoute.js içindeki singup post request routeu aşağıdaki gibi düzenlenir. <br>
                    <pre class="prettyprint ms-0">
router.route('/singup').post( 
    [ 
        body('name').not().isEmpty().withMessage('Please Enter Your Name'), // bu kısımda formdan gelen name parametresi boş ise "Please Enter Your Name" mesajı gönderilir. 
    ], 
    authController.createUser
);
                    </pre>
                </p>
                <p>
                    Gönderilen hata mesajı authControler.createUser catch tarafında yakalanır. Bunun için önce express-validator import edilir. <br>
                    <pre class="prettyprint ms-0">const { validationResult } = require('express-validator');</pre> <br>
                    sonra catch bloğunda hata mesajı yakalanır. <br>
                    <pre class="prettyprint ms-0">
const errors = validationResult(req); 
console.log(errors);
                    </pre> konsolda bir array içinde bir obje yazdırılır. bize gereken hata mesajı için: <br>
                    <pre class="prettyprint ms-0">console.log(errors.array()[0].msg);</pre>  
                </p>
                <p>
                    Aldığımız hata mesajını bir önceki konudaki flash metodu ile ilgili template'e göndereceğiz <br> 
                    bunun için catch bloğunun en altına: <br>
                    <pre class="prettyprint ms-0">
req.flash('error', errors.array()[0].msg); 
res.status(400).redirect('/register')   
                    </pre> eklenir.
                </p>
                <p>
                    Gönderilen mesaj register.ejs içinde istenilen yere daha önceki kodun aynısı olarak girilir: <br>
                    <pre class="prettyprint ms-0">
&lt;% if(flashMessages){ %> 
    &lt;% if(flashMessages.success){ %> 
        &lt;div class="alert alert-success"> 
            &lt;%= flashMessages.success %> 
        &lt;/div> 

    &lt;% } else if(flashMessages.error){ %> 
        &lt;div class="alert alert-danger"> 
            &lt;%= flashMessages.error %> 
        &lt;/div> 
    &lt;% } %> 
&lt;% } %> 
                    </pre>
                </p>
                <p>
                    userRoute.js içine: 
                    <pre class="prettyprint ms-0">const User = require('../models/User');</pre>
                </p>
                <p>
                    userRoute.js içindeki singup post request routeu diğer inputlardan gelen veriyi de değerlendirmesi için aşağıdaki gibi güncellenir. <br>
                    <pre class="prettyprint ms-0">
router.route('/singup').post( 
    [ 
        body('name').not().isEmpty().withMessage('Please Enter Your Name'), 
        body('email').isEmail().withMessage('Please Enter Valid Email') // bu kısım mail adresi değil ise mesaj gönder. 
        .custom((userEmail)=> { // bu kısımdaki sınamayı kendimiz yazdık. Mail adresinin databasete zaten olması durumunda hata mesajı gönderir. Sınamanın gerçekleşebilmesi için User modeli import edilir 
            return User.findOne({email: userEmail}).then(user => { 
                return Promise.reject('Email is already exist') 
            }) 
        }), 
        body('password').not().isEmpty().withMessage('Please Enter Your Password'), // password kısmı boş ise hata mesajı verir.

    ],  
    authController.createUser
); 
                    </pre> 
                </p>
                <p>
                    Gelen birden fazla mesajın hepsinin yazılabilmesi için authController.createUser catch blogu içine for döngüsü yazılır. <br>
                    <pre class="prettyprint ms-0">
} catch (error) {
    const errors = validationResult(req);

    for (let i=0; i&lt;errors.array().length; i++){
        req.flash('error', errors.array()[i].msg); 
    }
    
    res.status(400).redirect('/register')
} 
                    </pre>
                </p>
    
                <h2>Login sayfasında form denetimi:</h2>
                <p>
                    Bu kısımda emaile sahip user olma durumu ve password kontrol authController.loginUser fonksiyonunda zaten olduğu için userRoute içinde tekrar kontrol etmeye gerek yoktur.
                </p>
                <p>
                    if(user) bloğunun else bloğuna: <br>
                    <pre class="prettyprint ms-0">
req.flash('error', 'User Is Not Exist'); 
res.status(200).redirect('/login'); 
                    </pre> yazılarak user yoksa alınacak mesajı gönderir.
                </p>
                <p>
                    if(user) içindeki if(same) bloğunun else bloğu içine: 
                    <pre class="prettyprint ms-0">
req.flash('error', 'Your Password Is Not Correct!!'); 
res.status(200).redirect('/login'); 
                    </pre> yazılarak password doğru değilse alınacak mesajı gönderir.
                </p>
                <p>
                    login.esj içinde istenilen yerde bu mesajlar aşağıdaki kod ile yakalanır. <br>
                    <pre class="prettyprint ms-0">
&lt;% if(flashMessages){ %> 
    &lt;% if(flashMessages.success){ %> 
        &lt;div class="alert alert-success"> 
            &lt;%= flashMessages.success %> 
        &lt;/div> 

    &lt;% } else if(flashMessages.error){ %> 
        &lt;div class="alert alert-danger"> 
            &lt;%= flashMessages.error %> 
        &lt;/div> 
    &lt;% } %> 
&lt;% } %> 
                    </pre>
                </p>
                <p>
                    validation için detaylı okuma için <a href="https://github.com/validatorjs/validator.js">github.com/validatorjs</a> ve <a href="https://express-validator.github.io/docs/">express-validator.github.io/docs</a>
                </p>
            </div>
            <div class="row" id="hata">
                <h1>Bir hata ile karşılaştık</h1>
                <h2 class="text-danger">Kullanıcı bilgisi değiştiğinde password değişiyor.</h2>
                <p class="alert-danger">
                    student içine course enroll edildiğinde database üzerindeki password verisi değişiyor.
                </p>
                <p>
                    Bu durumu çözmek için google üzerinde arama yapıyoruz: <br>
                    <q>how to prevent refreshing password mongoose</q>
                </p>
                <p>
                    Bulunan <a href="https://stackoverflow.com/questions/43706606/how-to-prevent-mongoose-from-rehashing-the-user-passwords-after-modifying-a-user">stackoverflow</a> linki.
                </p>
                <p>
                    Linkteki cevabın referans verdiği <a href="https://mongoosejs.com/docs/api.html#document_Document-isModified">doküman</a>
                </p>
                <p>
                    stackoverflow da cevap olarak verilen kod null ifadesi silindikten ve userSchema <q>UserSchema</q> olarak kodumuzla uyumlu hale getirildiğinde işimizi görüyor. <br>
                    <pre class="prettyprint ms-0">
UserSchema.pre('save', function(next) { 
    const user = this; 
    if (!user.isModified('password')) return next(); 

    bcrypt.genSalt(10, function(err, salt) { 
        if (err) return next(err); 
        bcrypt.hash(user.password, salt, function(err, hash) { 
            if (err) return next(err); 
            user.password = hash; 
            next(); 
        }); 
    }); 
}); 
                    </pre> 
                </p>
    
                <h3>Benim çözümüm</h3>
                <p class="alert-success p-2">
                    Kendi kodumuzu incelediğimizde her save işleminden önce password bilgisinin tekrar hash edildiğini görüyoruz. Bunu engellemek için koda bir if koşulu eklememiz yeterli olacaktır. <br>
                    <pre class="prettyprint ms-0">
UserSchema.pre('save', function (next) { 
    const user = this; 
    <u>if(!user.isModified('password')) return next();</u> 
                          
    bcrypt.hash(user.password, 10, (error, hash) => { 
        user.password = hash; 
        next(); 
    }); 
}); 
                    </pre> 
                </p>
            </div>
            <div class="row" id="deleteCourse">
                <h1>Kurs Silmek</h1>
                <p>
                    delete ve update butonlarını eklemek için dashboard.ejs içinde teacher kısmındaki kurs kartlarına aşağıdaki kod eklenir: <br>
                    <pre class="prettyprint ms-0">
&lt;div class="clearfix"> 
    &lt;ul style="list-style-type: none;"> 
        &lt;li style="float: left;">
            &lt;button class="btn btn-primary rounded-0 text-white">&lt;span>UPDATE&lt;/span>&lt;/button>
        &lt;/li> 
        &lt;li style="float: right;">
            &lt;button class="btn btn-danger rounded-0 text-white">&lt;span>DELETE&lt;/span>&lt;/button>
        &lt;/li> 
    &lt;/ul> 
&lt;/div> 
                    </pre>
                </p>
                <p>
                    delete ve update işlemleri için method-override paketi indirilir. Terminale: <br>
                    <pre class="prettyprint ms-0">npm i method-override</pre>
                </p>
                <p>
                    app.js içine method-override import edilir. <br>
                    <pre class="prettyprint ms-0">const methodOverride = require('method-override')</pre> <br>
                    ilgili middleware ilgili alana yazılır. <br>
                    <pre class="prettyprint ms-0">
app.use( 
    methodOverride('_method', { 
        methods: ['POST', 'GET'], 
    }) 
); 
                    </pre>
                </p>
                <p>
                    dashboard.ejs delete butonu aşağıdaki gibi modifiye edilir: <br>
                    <pre class="prettyprint ms-0">
&lt;li style="float: right;">&lt;a 
    href="/courses/&lt;%= courses[i].slug %>?_method=DELETE" 
    onclick="return confirm('ARE YOU SURE?')" 
    class="btn btn-danger rounded-0 text-white">&lt;span>DELETE&lt;/span>&lt;/a>&lt;/li>
                    </pre>
                </p>
                <p>
                    courseController.js içine <br>
                    <pre class="prettyprint ms-0">
exports.deleteCourse = async (req, res) => { 
    try { 
        const course = await Course.findOneAndRemove({slug:req.params.slug}) 
        req.flash('error', `${course.name} Has Been Remote Succesfuly`); 
        res.status(200).redirect('/users/dashboard'); 
        
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        }); 
    }
};
                    </pre>
                </p>
                <p>
                    fonksiyon ile komutu bağlamak için courseRoute.js içinde <br>
                    <pre class="prettyprint ms-0">router.route('/:slug').delete(courseController.deleteCourse);</pre>
                </p>
                <p>
                    Gönderilen flash mesajı dashboard.ejs içinde istenilen yere eklenir.
                </p>
            </div>
            <div class="row" id="updateCourse">
                <h1>Kurs Güncellemek</h1>
                <p>
                    Bir önceki çalışmada method-override paketini kurmuştuk. Bunun üzerinden devam edeceğiz.
                </p>
                <p>
                    update butonuna tıkladığımızda bir modal açılacak ve içinde tıkladığımız kursun bilgileri yazacak.
                </p>
                <p>
                    CREATE NEW COURSE için kullandığımız ve sayfanın en altına yazdığımız modalı kopyalayıp kurs listelemek için kullandığımız for döngüsünün en altına yapıştırıyoruz. Bu sayede modal ilgili kursun bilgilerini alabiliyor.
                </p>
                <p>
                    dashboard.ejs içinde UPDATE butonu aşağıdaki gibi güncellenir: <br>
                    <pre class="prettyprint ms-0">
&lt;li style="float: left;">
    &lt;button class="btn btn-primary rounded-0 text-white" 
    data-toggle="modal" data-target="#updateCourse&lt;%= courses[i]._id %>" // bu kısım modal için gerekli. data-target ile modal id aynı olmalı. 
    >
        &lt;span>UPDATE&lt;/span>
    &lt;/button>
&lt;/li>
                    </pre>
                </p>
                <p>
                    modal içindeki değişiklikler: <br>
                    <pre class="prettyprint ms-0">
&lt;div class="modal fade" <u>id="updateCourse&lt;%= courses[i]._id %>"</u> tabindex="-1" role="dialog" aria-labelledby="myModalLabel"> 
... 
    &lt;form method="POST" <u>action="/courses/&lt;%= courses[i].slug %>?_method=PUT"</u> class="form-horizontal"> 
        ... 
        &lt;input type="text" name="name" <u>value="&lt;%= courses[i].name %>"</u> class="form-control"  placeholder="Course Name">
        ... 
        &lt;textarea rows="8" name="description" class="form-control" placeholder="Course Description" required><u>&lt;%= courses[i].description %></u>&lt;/textarea> 
    ...
...
                    </pre>
                </p>
                <p>
                    courseController.js içine: <br>
                    <pre class="prettyprint ms-0">
exports.updateCourse = async (req, res) => { 
    try {                     
        const course = await Course.findOne({slug:req.params.slug}) 
        course.name = req.body.name; 
        course.description = req.body.description; 
        course.category = req.body.category; 
        course.save(); 
                          
        req.flash('success', `${course.name} Has Been Update Succesfuly`); 
        res.status(200).redirect('/users/dashboard'); 
                              
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        }); 
    } 
};
                    </pre>
                </p>
                <p>
                    routeController.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/:slug').put(courseController.updateCourse);</pre> eklenir.
                </p>
            </div>
            <div class="row" id="admin">
                <h1>Admin Alanı ve Kullanıcı Silmek</h1>
                <p>
                    Bu çalışmada ayrı admin alanı oluşturmak yerine dashboard alanını kullanacağız.
                </p>
                <p>
                    Admin kullanıcısını student olarak yaratıp database üzerinden manuel admin yaptık.
                </p>
                <p>
                    dashboard.ejs student alanını kopyalayıp teacher alanının altına yapıştırdık. ve <code>user.role === 'admin'</code> olarak güncelledik.
                </p>
                <p>
                    for döngüsünü sildik ve yerine bu tamplate için kullanılan bootstrap yapısına uygun bir tablo örneği yapıştırdık.
                </p>
                <p>
                    Tüm user bilgisini dashboard.ejs de kullanabilmek için authController.getDashboardPage fonksiyonuna: <br>
                    <pre class="prettyprint ms-0">const users = await User.find()</pre> 
                    ile tüm kurslar çağırılır ve render alanında gönderilen verilere 
                    <code>
                        users
                    </code> eklenir.
                </p>
                <p>
                    users bilgisi tablo içinde yakalanır: <br>
                    <pre class="prettyprint ms-0">
&lt;table class="table"> 
    &lt;thead> 
        &lt;tr> 
            &lt;th scope="col">ID#&lt;/th> 
            &lt;th scope="col">Email&lt;/th> 
            &lt;th scope="col">Role&lt;/th> 
            &lt;th scope="col">Delete&lt;/th> 
        &lt;/tr> 
    &lt;/thead> 
    &lt;tbody> 
        &lt;% for(let i=0; i&lt;users.length; i++){ %> 
            &lt;tr> 
                &lt;th scope="row">&lt;%= users[i]._id %>&lt;/th> 
                &lt;td>&lt;%= users[i].email %>&lt;/td> 
                &lt;td>&lt;%= users[i].role %>&lt;/td> 
                &lt;td>DELETE&lt;/td> &lt;!-- DELETE butonu daha sonra aktif hale getirilecek --&gt;
            &lt;/tr> 
        &lt;% } %> 
    &lt;/tbody> 
&lt;/table>
                    </pre>
                </p>
                <p>
                    DELETE butonu için: <br>
                    <pre class="prettyprint ms-0">
&lt;td>
    &lt;a 
    href="/users/&lt;%= users[i]._id %>?_method=DELETE" 
    onclick="return confirm('ARE YOU SURE?')" 
    class="btn btn-danger rounded-0 text-white">
        &lt;span>DELETE&lt;/span>
    &lt;/a>
&lt;/td>
                    </pre>
                </p>
                <p>
                    authController.js içine: <br>
                    <pre class="prettyprint ms-0">
exports.deleteUser = async (req, res) => { 
    try { 
        await User.findByIdAndRemove(req.params.id); 
        res.status(200).redirect('/users/dashboard'); 
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        }); 
    } 
};
                    </pre>
                </p>
                <p>
                    userRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/:id').delete(authController.deleteUser);</pre>
                </p>
                <p>
                    role: teacher olan bir kullanıcıyı kaldırdığımızda, onun oluşturduğu kurslar kalmaya devam eder ve hata alırız. Bu nedenle teacher kaldırıldığında ona bağlı kurslar da kaldırılsın isteriz. Bu nedenle authController.deleteUser fonksiyonunu aşağıdaki gibi modifiye ederiz. <br>
                    <pre class="prettyprint ms-0">
exports.deleteUser = async (req, res) => { 
    try { 
        await User.findByIdAndRemove(req.params.id); 
        <u>await Course.deleteMany({ user: req.params.id });</u> 
        res.status(200).redirect('/users/dashboard'); 
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        }); 
    } 
}; 
                    </pre>
                </p>
            </div>
            <div class="row" id="category">
                <h1>Kategori Eklemek ve Silmek</h1>
                <p>
                    dashboard.ejs admin alanındaki tablonun altına kendi kopyasını oluşturup modifiye edip üzerinde çalışacağız. <br>
                    <pre class="prettyprint ms-0">
&lt;div class="row mt-5"> 
    &lt;h2>Categories&lt;/h2> 
    &lt;table class="table"> 
        &lt;thead> 
            &lt;tr> 
                &lt;th scope="col">ID#&lt;/th> 
                &lt;th scope="col">Categories&lt;/th> 
                &lt;th scope="col">Add&lt;/th> 
                &lt;th scope="col">Delete&lt;/th> 
            &lt;/tr> 
        &lt;/thead> 
        &lt;tbody>   
            &lt;% for(let i=0; i&lt;categories.length; i++){ %> 
                &lt;tr> 
                    &lt;th scope="row">&lt;%= categories[i]._id %>&lt;/th> 
                    &lt;td>&lt;%= categories[i].name %>&lt;/td> 
                                            &lt;td>ADD&lt;/td> &lt;!-- add butonu daha sonra düzenlenecek  --&gt;

                    &lt;td>
                        &lt;a  
                        href="/categories/&lt;%= categories[i]._id %>?_method=DELETE" 
                        onclick="return confirm('ARE YOU SURE?')" 
                        class="btn btn-danger rounded-0 text-white">
                            &lt;span>DELETE&lt;/span>
                        &lt;/a>
                    &lt;/td> 
                &lt;/tr> 
            &lt;% } %> 
        &lt;/tbody> 
    &lt;/table> 
&lt;/div>&lt;!-- end row --> <br>
                    </pre>
                </p>
    
                <h2>Kategori silmek</h2>
                <p>
                    categoryController içine: <br>
                    <pre class="prettyprint ms-0">
exports.deleteCategory = async (req, res) => { 
    try { 
        await Category.findByIdAndRemove(req.params.id); 
        res.status(200).redirect('/users/dashboard'); 
    } catch (error) { 
        res.status(400).json({ 
            status: 'fail', 
            error, 
        }); 
    } 
};
                    </pre>
                </p>
                <p>
                    fonksiyon ile isteği bağdaştırmak için categoryRoute.js içine: <br>
                    <pre class="prettyprint ms-0">router.route('/:id').delete(categoryController.deleteCategory);</pre>
                </p>
    
                <h2>Kategori eklemek</h2>
                <p>
                    add butonu: <br>
                    <pre class="prettyprint ms-0">&lt;button class="btn btn-warning rounded-0 text-white" href="#" data-toggle="modal" data-target="#addCategory">&lt;span>ADD&lt;/span>&lt;/button></pre>
                </p>
                <p>
                    categoryController.createCourse fonksiyonunu daha önce yazmıştık. Sadece <pre class="prettyprint ms-0">res.status(201).redirect('/users/dashboard');</pre> yönlendirmesi eklendi. 
                </p>
                <p>
                    ilgili route daha önce yazılmıştı.
                </p>
            </div>
            <div class="row" id="homePage">
                <h1>Anasayfa düzeni</h1>
                <p>
                    pageController.getIndexPage fonksiyonu içinde anasayfada kullanmak için bazı bilgiler göndereceğiz. <br>
                    <pre class="prettyprint ms-0">
exports.getIndexPage = async (req, res) => { 

    const courses = await Course.find().sort('-createdAt').limit(2); // kursları oluşturulma sırasına göre tersten sıralıyoruz ve iki tanesini alıyoruz. 
    const totalCourses = await Course.find().countDocuments();  // toplam kurs sayısı 
    const totalStudents = await User.countDocuments({role: 'student'}); // toplam öğrenci sayısı 
    const totalTeachers = await User.countDocuments({role: 'teacher'}); // toplam öğretmen sayısı 

    res.status(200).render('index', { 
        page_name: 'index', 
        courses, 
        totalCourses, 
        totalStudents, 
        totalTeachers, 
    }); 
};
                    </pre>
                </p>
                <p>
                    Gönderilen veriler anasayfada yerleştirilerek kullanılır.
                </p>
            </div>
            <div class="row" id="deployment">
                <h1>Deployment</h1>
                <p>
                    daha önceki projenin aynısı.
                </p>
                <p>
                    Yeni database e bağlanırlen tüm veriler sıfırlanacağı için, index sayfasında courses verilerini if(courses[0]) benzeri koşullara alıyoruz. 
                </p>
                <p>
                    connect için kullandığımız mongodb bağlantısını middleware içindeki kısmı update ederken kullanmayı unutma. <br>
                    bağlantı için: <br>
                    <pre class="prettyprint ms-0"> 
mongoose 
    .connect('<u>mongodb+srv://arslan_ng:narniag7A.@cluster0.cqw1stg.mongodb.net/?retryWrites=true&w=majority</u>') 
    .then(() => console.log('DB Connected!'));
                    </pre> 
                    session middleware için: 
                    <pre class="prettyprint ms-0">
app.use( 
    session({ 
        secret: 'keyboard_cat_rambo', 
        resave: false, 
        saveUninitialized: true, 
        store: MongoStore.create({ mongoUrl: '<u>mongodb+srv://arslan_ng:narniag7A.@cluster0.cqw1stg.mongodb.net/?retryWrites=true&w=majority</u>' }), 
    }) 
); 
                    </pre>
                </p>
            </div>
          </div>
        </div>
      </div>

    </div>
    <!-- İçerik End -->
    <!-- footer start -->
    <!-- footer end -->
    <!-- JS -->
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&amp;skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>