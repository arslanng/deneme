<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
          list-style-position: inside;
        }
        table, th ,td{
          border: 1px black solid;
          border-collapse: collapse;
          text-align: center;
        }
    </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">React</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2 class="text-center">Konu Listesi </h2>
            <ul style="max-height: 400px; overflow: auto;">
                <div class="giris">
                  <h3>Giriş</h3>
                  <li><a href="#giris">React Giriş</a></li>
                  <li><a href="#ES6">ES6 Modül Sistemi</a></li>
                  <li><a href="#callback">Callback Functions / async-await</a></li>
                  <li><a href="#promises">Promises</a></li>               
                  <li><a href="#arrayFunctions">Array Functions</a></li>
                </div>                   
                <div class="components">
                  <h3>Components</h3>
                  <li><a href="#createReactProject">Bir React Projesini Ayağa Kaldırmak (create-react-app)</a></li>
                  <li><a href="#component">Component Nedir?</a></li>
                  <li><a href="#crateComponet">Component Oluşturmak/Kullanmak</a></li>
                  <li><a href="#jsx">JSX ve Temel Kuralları</a></li>
                </div>
                <div class="props">
                  <h3>Props</h3>
                  <li><a href="#propsNedir">Props Nedir? Nasıl Kullanılır?</a></li>
                  <li><a href="#keyProp">Döngülerde "key" Prop'u</a></li>
                  <li><a href="#reactDeveloperTool">React Developer Tools</a></li>
                  <li><a href="#propTypes">Prop Types</a></li>
                  <li><a href="#defaultProps">Default Props</a></li>
                </div>
                <div id="states">
                  <h3>States</h3>
                  <li><a href="#stateNedir">State Nedir? Nasıl Oluşturulur?</a></li>
                  <li><a href="#arrayState">Array States</a></li>
                  <li><a href="#objectState">Object States</a></li>
                  <li><a href="#ornekCount">Sayaç Uygulaması</a></li>
                  <li><a href="#inputState">Input için State Tanımı Yapmak</a></li>
                </div>
                <div id="lifecycle">
                  <h3>Lifecycle</h3>
                  <li><a href="#useEffect">useEffect</a></li>
                  <li><a href="#componentUnmont">Component Unmount</a></li>
                </div>
                <div id="contactsApp">
                  <h3>Contacts App</h3>
                  <li><a href="#contactsApp">Contacts App</a></li>
                  <li><a href="#contactsForm">Form Component'inin Geliştirilmesi</a></li>
                  <li><a href="#contactsList">Kayıtların Listelenmesi</a></li>
                  <li><a href="#contactsFilter">Filtreleme İşlemi</a></li>
                  <li><a href="#contactsStil">Stil Tanımlarının Yapılması</a></li>
                </div>
                <div id="Stil">
                  <h3>Stillendirme Temelleri</h3>
                  <li><a href="#stilTanimi">Stil Tanımı Yapmak</a></li>
                  <li><a href="#moduleCss">Module CSS</a></li> 
                </div>
                <div id="Fetching">
                  <h3>Fetching</h3>
                  <li><a href="#nativeFetch">Native Fetch</a></li>
                  <li><a href="#axios">Axios</a></li>
                </div>
                <div id="Routing">
                  <h3>Routing</h3>
                  <li><a href="#routingKurulum">Kurulum</a></li>
                  <li><a href="#exactProp">Exact Prop</a></li>
                  <li><a href="#urlParameters">URL Parameters</a></li>
                  <li><a href="#nesting">Nesting</a></li>
                  <li><a href="#navlink">NavLink</a></li>
                  <li><a href="#noMatch">No Match (404)</a></li>
                </div>
                <div id="formik">
                  <h3>Formik ile Form Yönetimi</h3>
                  <li><a href="#formikKurulum">Kurulum</a></li>
                  <li><a href="#handleSubmitHandleChange">handleSubmit & handleChange</a></li>
                  <li><a href="#radioCheckboxDropdown">Radio / Checkbox / Dropdown</a></li>
                  <li><a href="#useFormik">useFormik</a></li>
                  <li><a href="#formValidasyon">Form Validasyonları (yup)</a></li>
                </div>
                <div id="memo">
                  <h3>Memoization</h3>
                  <li><a href="#reactMemo">React.memo</a></li>
                  <li><a href="#useMemo">useMemo</a></li>
                  <li><a href="#useCallback">useCallback</a></li>                  
                </div>
                <div id="contextApi">
                  <h3>Context API</h3>
                  <li><a href="#contextNedir">Context Nedir?</a></li>
                  <li><a href="#contextOlusturmak">Context Oluşturmak</a></li>
                  <li><a href="#contextProvider">Context Provider</a></li>
                  <li><a href="#themeSwitcher">Theme Switcher Yapımı</a></li>
                  <li><a href="#contextProviderSideEffects">Context Provider Side Effects</a></li>
                  <li><a href="#multiContext">Multi Context</a></li>
                  <li><a href="#customContextHook">Custom Context Hook</a></li>
                  <li><a href="#contextOdev">Ödev Notları</a></li>
                </div>
                <div id="realTime">
                  <h3>Real Time Çalışan Uygulamalar Geliştirmek</h3>
                  <li><a href="#arayuz">Arayüzün Hazırlanması</a></li>
                  <li><a href="#connectSocketServer">Socket Server'a Bağlanmak</a></li>
                  <li><a href="#backendVeri">Backend'e Veri İletmek</a></li>
                  <li><a href="#KanalAbone">Bir Kanala Abone Olmak</a></li>
                  <li><a href="#aboutSocket">Socket Io hakkında</a></li>
                </div>
                <div id="chatApp">
                  <h3>Chat App</h3>
                  <li><a href="#chatAppGiris">Giriş</a></li>
                  <li><a href="#chatContext">Chat Context</a></li>
                  <li><a href="#chatBilesenler">Temel Bileşenlerin Geliştirilmesi</a></li>
                  <li><a href="#backendBaglanti">Backend Bağlantısı</a></li>
                  <li><a href="#sendMessages">Mesajların İletilmesi</a></li>
                  <li><a href="#listMessages">Mesajların Listelenmesi</a></li>
                  <li><a href="#feedScroll">Feed Scroll</a></li>
                </div>
                <div id="localization">
                  <h3>Localization</h3>
                  <li><a href="#reactIntl">React Intl - Kurulum</a></li>
                  <li><a href="#defaultLocale">Default Locale</a></li>
                  <li><a href="#parametreGecmek">Parametre Geçmek</a></li>
                </div>
                <div id="testing">
                  <h3>Testing</h3>
                  <li><a href="#nedenTest">Neden Test Yazarız?</a></li>
                  <li><a href="#reactTestingLibrary1">React Testing Library Örnek 1</a></li>
                  <li><a href="#reactTestingLibrary2">React Testing Library Örnek 2</a></li>
                </div>
                <div id="testing">
                  <h3>Publishing</h3>
                  <li><a href="#createReactLibrary">create-react-library</a></li>
                  <li><a href="#publishislemleri">Publish İşlemleri</a></li>
                  <li><a href="#sematicVersiyonlama">Semantic Versiyonlama</a></li>
                </div>
                <div id="deploy">
                  <h3>Deploy</h3>
                  <li><a href="#surgeSh">Surge.sh</a></li>
                  <li><a href="#netlify">Netlify</a></li>
                  <li><a href="#awsEc2Deploy">AWS EC2 Üzerine Deploy İşlemleri</a></li>
                </div>
                <div id="eCommerceApp">
                  <h3>E-Commerce App (Örnek Proje)</h3>
                  <li><a href="#tanitim">Uygulama Tanıtımı</a></li>
                  <li><a href="#backendeGenelBakis">Backend'e Genel Bakış</a></li>
                  <li><a href="#chakraUI">Chakra UI Kurulumu</a></li>
                  <li><a href="#productEkrani">Products Ekranının Hazırlanması</a></li>
                  <li><a href="#reactQuery">React Query</a></li>
                  <li><a href="#reactQueryDevTools">React Query Dev Tools</a></li>
                  <li><a href="#urunDetay">Ürün Detay Sayfasının Geliştirilmesi</a></li>
                  <li><a href="#useInfiniteQuery">useInfiniteQuery</a></li>
                  <li><a href="#userRegister">Kullanıcı Kayıt İşlemleri</a></li>
                  <li><a href="#userLogout">Çıkış İşlemleri</a></li>
                  <li><a href="#protectedRoutes">Protected Routes</a></li>
                  <li><a href="#userLogin">Login İşlemleri</a></li>
                  <li><a href="#addToBasket">Sepete Atma İşlemleri</a></li>
                  <li><a href="#createOrder">Sipariş Oluşturma İşlemleri</a></li>
                  <li><a href="#adminRouting">Admin: Routing İşlemleri</a></li>
                  <li><a href="#adminOrder">Admin: Order Sayfası</a></li>
                  <li><a href="#adminProducts">Admin: Products Sayfası</a></li>
                  <li><a href="#adminProductUpdate">Admin: Product Update İşlemleri</a></li>
                  <li><a href="#adminNewProduct">Admin: Yeni Ürün Eklemek</a></li>
                  <li><a href="#MyModif">Projeye Benim Katkım</a></li>
                </div>
            </ul>
        </div>
        <div class="col-sm-9">
          <div class="row" id="giris">
            <h1>React Nedir? Ne Zaman İhtiyaç Duyarız?</h1>
            <p>
              User interfaces oluşturmak için JS kütüphanesi
            </p>
            <p>
              React düzenli DOM manuplasyonu yapılan sitelerde kullanılır. Bütün sayfa render edilmeden sadece ilgili alan render edilir.
            </p>
            <h2>Real DOM</h2>
            <p>
              Web sayfasını oluşturan html etiketlerinin tamamı Real DOM'u oluşturur.
            </p>

            <h2>Vitrual DOM</h2>
            <p>
              real DOM yapısının js üzerinde obje olarak tutulan kopyası.
            </p>
            <p>
              Veri güncellendiğinde react vitrual DOM ve real DOM'u karşılaştırır. Fark var ise sadece fark olan yer real DOM üzerinde değiştirilir. Bu sayede tüm sayfa render edilmemiş olur.
            </p>
          </div>
          <div class="row" id="ES6">
            <h1>ES6 Modül Sistemi</h1>
            <p>
              Modül sistemini çalışması için package.json içine "type": "module" verisi girilmeli. <br>
              Bunu yazdıktan sonra daha önce require ile çağırdığımız modülleri artık farklı bir şekilde import edeceğiz. <br>
              <strong>Her iki import şekli aynı anda çalışmaz. Modül aktif edildiğinde require hata verir.</strong>
            </p>
            <p>
              <pre class="prettyprint ms-0">
const slugify = require('suligify'); 
              </pre> 
              <p>
                yerine
              </p>
              <pre class="prettyprint ms-0">
import slugify from "slugify"
              </pre> kullanılır.
            </p>
            <p>
              Modülü export ederken de iki sistem arasında yazım farkları mevcut. <br>
              <strong>Modüle aktif değilken:</strong> <br>
              <pre class="prettyprint ms-0">
exports.topla = (a, b) => {console.log(a + b);};
exports.hello = () => {console.log("hello")};
              </pre> kullanılır. import için de
              <pre class="prettyprint ms-0">const {hello, topla} = require("../js/myModule")</pre> kullanılır.
               <br><br>
              <strong>Modüle aktifken:</strong> <br>
              <pre class="prettyprint ms-0">
export const topla = (a, b) => {console.log(a + b);}; 
export const hello = () => {console.log("hello")}; 
              </pre> veya 
              <pre class="prettyprint ms-0">
const topla = (a, b) => {console.log(a + b);}; 
const hello = () => {console.log("hello")}; 
export {topla, hello}
              </pre> kullanılır. <br><br>
              import için de: <br>
              <pre class="prettyprint ms-0">import {topla, hello} from "../js/myModule"</pre> kullanılır.
            </p>
            <p>
              modül kullanımında tek bir fonksiyon default olarak dışa aktarılabilir. <br>
              <pre class="prettyprint ms-0">
export const topla = (a, b) => {console.log(a + b);};
export const hello = () => {console.log("hello")}; 
const cikar = (a, b) => {console.log(a - b);}; 
export default hello;
              </pre> default olarak gönderilen fonksiyon çağırılırken süslü paranteze konmaz. <br>
              <pre class="prettyprint ms-0">
import cikar, {topla, hello} from "../js/myModule"
              </pre> <br>
              default fonksiyon çağırılırken oluşturulan ismi dışında bir isimle de çağırılabilir. <br>
              <pre class="prettyprint ms-0">
import app, {topla, hello} from "../js/myModule"
              </pre> bu yazımda cikar fonksiyonu çağırıldığı yerde app adı ile kullanılır.
            </p>
            <p>
              her iki import yapısıyla da fonksiyon dışında diğer değişkenler (sting, array, object vs) de import-export edilebilir.
            </p>
          </div>
          <div class="row" id="callback">
            <h1>Callback Functions / async-await</h1>
            
            <h2>İşimize yarayacak fonksiyonlar.</h2>
            <p>
              <b>setTimeout()</b> belirli bir süre sonunda içine tanımlanan fonksiyonun gerçekleşmesini sağlar. 2 parametre alır. ilk parametreye fonksiyon ikinciye milisaniye cinsinden süre yazılır. <br>
              <b>setInterval()</b> belirli bir sürede tanımlanan fonksiyonun tekrar tekrar gerçekleşmesini sağlar. 2 parametre alır. ilk parametreye fonksiyon ikinciye milisaniye cinsinden süre yazılır. <br>
              <b>fetch()</b> herhangi bir veri kaynağına bağlanıp aldığı veriyi bize getirir.
            </p>
            <p>
              <b>Callback</b>: başka bir kod parçasına argüman olarak iletilen yürütülebilir koda yapılan herhangi bir başvurudur. Bir fonksiyon çalışmasını tamamladıktan sonra başka bir fonksiyonun çalışmasını sağlayan fonksiyonlara callback fonksiyon denir. 
            </p>
            <p>
              js yapısı gereği fonksiyonlar birbirinin tamamlanmasını beklemeden devreye girerler. Bunu olmasını engellemek istediğimiz fonksiyonlar ya .then yapılarıyla yada async-await ile yazılır.
            </p>
            <p>
              <b>.then örneği:</b> <br>
              <pre class="prettyprint ms-0">
fetch("https://jsonplaceholder.typicode.com/users/1") 
.then((data) => data.json()) 
.then((users) => { 
  console.log("users yüklendi", users); 

  fetch("https://jsonplaceholder.typicode.com/posts/1") 
    .then((data) => data.json()) 
    .then((posts) => console.log("post yüklendi", posts));
});
              </pre> Bu yapıda her .then() kendinden önceki fonksiyonu bekler ve ondan gelen veriyi alır.
            </p>
            <p>
              <b>async-await örneği</b> <br>
              <pre class="prettyprint ms-0">
async function getData() { 
  const user = await ( 
    await fetch("https://jsonplaceholder.typicode.com/users/1") 
  ).json(); 

  const post = await ( 
    await fetch("https://jsonplaceholder.typicode.com/posts/1") 
  ).json(); 

  console.log("users yüklendi", user); 
  console.log("post yüklendi", post); 
} 

getData(); 
              </pre> Bu yapıda asenkron olması için fonksiyonun başına async eklenir. Tamamlanması beklenecek her fonksiyonun başına da await eklenir. Sonra da fonksiyon çağırılır.
            </p>
            <p>
              Fonksiyonu isimlendirmek ve ayrıca çağırmak istemediğimiz durumlarda anonim fonksiyon yapısı kullanılır. <br>
              (()=>{})();
              <b>Örnek:</b> <br>
              <pre class="prettyprint ms-0">
(async()=>{ 
  const user = await ( 
      await fetch("https://jsonplaceholder.typicode.com/users/1") 
    ).json(); 
  
    const post = await ( 
      await fetch("https://jsonplaceholder.typicode.com/posts/1") 
    ).json(); 
  
    console.log("users yüklendi", user); 
    console.log("post yüklendi", post); 
})();
              </pre>

            </p>
            <p>
              hoca fetch işlevi için npm den node-fetch kurdurup fetch adıyla import edilir diyor ama paket indirmeden de fetch komutu çalışıyor. node versiyonu ile ilgili olabilir.
            </p>
            <p>
              axios kütüphanesi fetch'in yaptığı işi daha kolay yapmamızı sağlıyormuş. <br>
              kodun axios hali: <br>
              <pre class="prettyprint ms-0">
(async()=>{ 
  const {data: user} = await axios("https://jsonplaceholder.typicode.com/users/1") // {data: user} axios tarafından gelen data değişkeninin adını user yapar.              
  const {data: post} = await axios("https://jsonplaceholder.typicode.com/posts/1") 

    console.log("users yüklendi", user); 
    console.log("post yüklendi", post); 
})();
              </pre>
            </p>
          </div>
          <div class="row" id="promises">
            <h1>Promises</h1>
            <p>
              .then() fonksiyonu ile data alınabilen fonksiyonlara <b>promise</b> denir. <br>
              <b>.then()</b> ile olumlu sonuç (resolve) yakalanır. <br>
              <b>.catch()</b> ile olumsuz sonuç (reject) yakalanır.
            </p>
            <p>
              <b>Örnek 1:</b> <br>
              <pre class="prettyprint ms-0">
const getComment = (number) => {
  return new Promise((resolve, reject)=>{ // bu satırda bir promise başlatıyoruz. promise 2 parametre alır.
      if(number === 1){ <br>
          resolve('comments'); // Bu kısım .then() ile yakalanır. <br>        
      } 
      reject('bir problem var') // Bu kısım .catch() ile yakalanır. 
  }) 
} 

getComment(1) 
.then((data) => console.log(data)) 
.catch((e)=> console.log(e))
              </pre>
            </p>
            <p>
              <b>Örnek 2</b>
              <pre class="prettyprint ms-0">
const getUser = (userId) => { 
  return new Promise(async(resolve, reject)=>{ 
      const user = await ( 
              await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)) 
              .json();  
      resolve(user) 
  })
}

getUser(2) 
.then((data) => {console.log(data); return data.name}).then((data) => console.log(data)) 
.catch((e)=> console.log(e))
              </pre> 
              <p>veya</p>
              <pre class="prettyprint ms-0">
const getUser = (userId) => { 
  return new Promise(async(resolve, reject)=>{ 
      const user = await ( 
              await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)) 
              .json();  
      resolve(user) 
  }) 
} 

(async () => { 
  try { 
    const user = await getUser(2); 
    console.log(user); 
  } catch (err) { 
    console.log(err); 
  } 
})();
              </pre> Burada kullanılan try-catch bloğu hata yakalamak için kullanılır.
            </p>
            <p>
              Birden fazla promise yapısında fonksiyonu çalıştırmak için <pre class="prettyprint ms-0">Promise.all()</pre> içine array olarak çalışması istenen fonksiyonların adı yazılır. <br>
              <pre class="prettyprint ms-0">
Promise.all([getUsers(), getPost(1)]) 
.then(console.log) 
.catch(console.log)
              </pre>
            </p>
          </div>
          <div class="row" id="arrayFunctions">
            <h1>Array Fonksiyonları</h1>
            <p>
              push, map, find, filter, some, every, includes
            </p>
            
            <h2>push</h2>
            <p>
              Örnek<br>
              <pre class="prettyprint ms-0">
const users = ["Mehmet", "Ahmet". "Murat"] 
users.push("Ayşe") 
console.log(users)
              </pre> 
              <p>çıktı:</p> 
              <pre class="prettyprint ms-0">
["Mehmet", "Ahmet". "Murat", "Ayşe"]
              </pre>
            </p>

            <h2>map</h2>
            <p>
              For döngüsü gibi array içindeki tüm değerlerde dönüyor.
            </p>
            <p>
              Örnek<br>
              <pre class="prettyprint ms-0">
const users = ["Mehmet", "Ahmet". "Murat"] 
users.map((x)=>{console.log(x)}) 
              </pre> 
              <p>çıktı: </p> 
              <pre class="prettyprint ms-0">
Mehmet 
Ahmet 
Murat
              </pre>
            </p>

            <h2>find</h2>
            <p>
              Array içinde arama yapar. Koşula uyan bir şey varsa ilk bulduğunu getirir. Yoksa undefined döner. Aramada mantık operatörleri kullanılabilir.
            </p>
            <p>
              Örnek: <br>
              <pre class="prettyprint ms-0">
const users = [ 
{ 
  name: "Mehmet",
  age: 18
}, 
{
  name: "Mehmet",
  age: 25
}, 
{
  name: "Murat",
  age: 28
}, 
] 
const result = users.find((x)=> x.name === "Mehmet" && x.age > 20) 
console.log(result)
              </pre> 
              <p>
                çıktı:
              </p>
              <pre class="prettyprint ms-0">
{ name: 'Mehmet', age: 25 }
              </pre>
            </p>

            <h2>filter</h2>
            <p>
              Filtreleme yapar.
            </p>
            <p>
              Örnek: <br>
              <pre class="prettyprint ms-0">
const users = [ 
{ 
  name: "Mehmet",
  age: 18
}, 
{
  name: "Mehmet",
  age: 25
}, 
{
  name: "Murat",
  age: 28
}, 
] 
const filtered = users.filter((x)=> x.name === "Mehmet" && x.age > 10) 
console.log(filtered)
              </pre> <p> veya </p>
              <pre class="prettyprint ms-0">
const filtered = users.filter(({ name, age })=> name === "Mehmet" && age > 10) 
console.log(filtered)
              </pre> 
              <p>Çıktı:</p> 
              <pre class="prettyprint ms-0">
[ 
{ name: 'Mehmet', age: 18 }, 
{ name: 'Mehmet', age: 25 }  
]
              </pre>
            </p>

            <h2>some</h2>
            <p>
              Array içindeki değerlerden biri koşula uyuyorsa true, hiçbiri uymuyorsa false döner
            </p>
            <p>
              Örnek: <br>
              <pre class="prettyprint ms-0">
const users = [ 
{ 
  name: "Mehmet",
  age: 18
}, 
{
  name: "Mehmet",
  age: 25
}, 
{
  name: "Murat",
  age: 28
}, 
{
  name: "Hasan",
  age: 10
}, 
] 
const some = users.some((x)=> x.age = 10) 
console.log(some)
              </pre> 
              <p>
                çıktı:
              </p> 
              <pre class="prettyprint ms-0">
true
              </pre>
            </p>
            <h2>every</h2>
            <p>
              Array içindeki değerlerin hepsi uyuyorsa true, biri bile uymuyorsa false döner
            </p>
            <p>
              Örnek: <br>
              <pre class="prettyprint ms-0">
const users = [ 
{ 
  name: "Mehmet",
  age: 18
}, 
{
  name: "Mehmet",
  age: 25
}, 
{
  name: "Murat",
  age: 28
}, 
{
  name: "Hasan",
  age: 10
}, 
] 
const every = users.every((x)=> x.age > 9) 
console.log(every)
              </pre> 
             <p>
              çıktı:
             </p> 
              <pre class="prettyprint ms-0">
true
              </pre>
            </p>

            <h2>includes</h2>
            <p>
              Arrayin içinde olma durumunu verir. Varsa true, yoksa false verir.
            </p>
            <p>
              Örnek: <br>
              <pre class="prettyprint ms-0">
const meyveler = ["elma", "armut", "muz"]; 
const isIncluded = meyveler.includes("muz"); 
console.log(isIncluded)
              </pre> 
              <p>
                çıktı:
              </p> 
              <pre class="prettyprint ms-0">
true
              </pre>
            </p>
          </div>
          <div class="row" id="createReactProject">
            <h1>Bir React Projesini Ayağa Kaldırmak (create-react-app)</h1>
            <p>
              create-react-app facebook'un hazırladığı ve paylaştığı hazır bir react geliştirme ortamı. <a href="https://github.com/facebook/create-react-app">github.com/facebook/create-react-app</a>
            </p>
            <p>
              crate-react-app için npx kurmak gerekiyor. Bu da node yüklenirken bilgisayara yüklenmiş oluyor. npx, npm de global olarak kurulup kullanılması gereken paketlerin kurulmadan kullanılmasına olanak sağlıyormuş.
            </p>
            <p>
              create-react-app kurulumu için terminale: <br>
              <pre class="prettyprint ms-0">
npx create-react-app my-example-app
              </pre> my-example-app yerine kendi projemizin adını yazıyoruz. Bunun sonucunda terminalin içinde olduğu dizine projemizin adında bir klasör oluşturuluyor. my-example-app yerine nokta (.) koyarsak bulunduğumuz dizinin içine kurar.
            </p>
            <p>
              projeyi açmak için terminale: <br>
              <pre class="prettyprint ms-0">
cd my-example-app
              </pre>
              (bizim klasörümüzün adı neyse o yazılacak) ile klasörün içine girip sonra: <br>
              <pre class="prettyprint ms-0">
npm start
              </pre> ile uygulama başlatılır. Açıldığında bizi http://localhost:3000/ adresinde karşılar. 3000 portu dolu ise başka bir portta açar. Açtığı portu terminalde gösterir. Hatta varsayılan tarayıcıda da açar.
            </p>
          </div>
          <div class="row" id="component">
            <h1>Component Nedir?</h1>
            <p>
              Web sayfasını meydana getiren bileşenlerdir. Bu companentler birleşerek başka kompanentleri ve sonunda web sayfamızı oluştururlar.
            </p>
          </div>
          <div class="row" id="crateComponet">
            <h1>Component Oluşturmak/Kullanmak</h1>
            <p>
              create-react-app işlemi sonrası bizim için kurulan dosyalar: <br>
              <b>node_modules:</b> bize react için gereken node modulleri <br>
              <b>public:</b> <br>
              <b>source:</b> bizim için asıl önemli kısım: <br>
              <ul>
                <li><b>App.js</b> bundan sonra yazacağımız bütün kompanentleri bu app kompanentinde birleştirerek ilerleyeceğiz.</li>
              </ul>
            </p>
            <p>
              Companent oluşturmak için companentin adında bir fonksiyon oluşturmak ve return ile istediğimiz companent htmlsini yazmamız yeterli
            </p>
            <p>
              public/index.html içinde id si root olan bir div mevcut. <br> 
              src/index.js içinde 'react' ve 'react-dom' import edilmiş. './index.css' imort edilmiş. App modülü ve reportWebVitals modülü de import edilmiş. devamında <br>
              <pre class="prettyprint ms-0">
const root = ReactDOM.createRoot(document.getElementById('root'));
              </pre> ile index.html içinde id='root' olan elemente ulaşıyor. <br>
              <pre class="prettyprint ms-0">
root.render(
  &lt;React.StrictMode>
    &lt;App />
  &lt;/React.StrictMode>
);
              </pre> bu elemente app companentini yerleştiriyor.
            </p>
            <p>
              App.js içindeki kompanenti değiştirdiğimizde sayfada görünen kısım da değişiyor.
            </p>
            <p>
              Kendi kompanentimizi yazmak: <br>
              src içine components/Header.js oluşturuldu. içine: <br>
              <pre class="prettyprint ms-0">
function Header(){ 
  return( 
    &lt;div> 
        Merhaba Ben Header Bileşeniyim. 
    &lt;/div> 
  ); 
} 
import default Header; 
              </pre> yazıldı. <br>
              App.js içine import edildi ve kullanıldı. <br>
              <pre class="prettyprint ms-0">
import './App.css';
import Header, {  } from "./components/Header";

function App(){
  return (
    &lt;div>
      <u> &lt;Header /></u>
    &lt;/div>
  );
}

export default App;
              </pre>
            </p>
          </div>
          <div class="row" id="jsx">
            <h1>JSX ve Temel Kuralları</h1>
            <p>
              JavaScript’in bir söz dizimi uzantısıdır. Bu olmadan da react yazılabilir ama kod çok karmaşıklaşır. JSX sayesinde html yazar gibi js kodları yazabiliyoruz.
            </p>

            <h2>JSX kuralları</h2>
            <p>
              Kompanent belirtilen fonksiyon adının büyük harf olmasına dikkat edelim. Bu sayede html etiketleri ile karışmazlar. Küçük harfle başlarsa react yorumlarken kompanenti html etiketi olarak yorumlar.
            </p>
            <p>
              Her kompanent eklenirken bir kapsayıcı etiket içine dahil edilir. <br>
              <b>&lt;div>&lt;/div></b> veya <b>boş etiket "&lt;>  &lt;/>" </b>kullanılabilir.
            </p>
            <p>
              JS için özel tanımlı keywordler kullanılmaz. <br>
              <b>class</b> ifadesi js içinözel tanımlı. yerine <b>classname</b> kullanılır. <br>
              <b>for</b> yerine <b>htmlFor</b> kullanılır. vs<br>
              Bu kullanım sayedinde js'de de anlamı olan keywordler jsx içinde kullanılmamış olut.
            </p>

            <h2>JSX içinde değişken kullanma:</h2>
            <p>İki şekilde yapılabilir.</p>
            <p>
              Değişken süslü parantez içine alınabilir. <br>
              <pre class="prettyprint ms-0">
... 
  &lt;h1>Benim Adim {name}&lt;/h1> 
... 
              </pre> veya süslü parantez arasına backtick ile yazılabilir.<br>
              <pre class="prettyprint ms-0">
... 
 &lt;h1>{`Benim adım: ${name}`}&lt;/h1> 
... 
              </pre>

              <h2>Koşullu Render</h2>
              <p>
                Koşulu sorgulama için isLoggedIn adında boolean değerli bir değişken oluşturduk. <br>
                <pre class="prettyprint ms-0">
... <br>
  &lt;h1>{isLoggedIn && `Benim adım: ${name}`}&lt;/h1> 
  &lt;h1>{!isLoggedIn && `Giriş Yapmadınız`}&lt;/h1> 
... 
                </pre> <p>
                  veya
                </p> 
                <pre class="prettyprint ms-0">
... 
  &lt;h1>{isLoggedIn ? `Benim adım: ${name}` : `Giriş Yapmadınız` }&lt;/h1> 
... 
                </pre>
              </p>
            </p>
          </div>
          <div class="row" id="propsNedir">
            <h1>Props Nedir? Nasıl Kullanılır?</h1>
            <p>
              Props (properties) kompanent içinde parametre geçebileceğimiz bir yapı. html etiketlerindeki Attribute-value gruplarına benzer şekilde veri App.js üzerinde kullanılan componente girilerek componentin işlemesi sağlanır. 
            </p>
            <p>
              App.js içinde: <br>
              <pre class="prettyprint ms-0">
&lt;div> 
  &lt;User name="Murat" surname="Gökduman" isLoggedIn={false}/> 
&lt;/div> 
              </pre>
              ile props olarak bilgiler gönderilir. props gönderildiği yerde işlenir ve User componenti olarak kullanılır.
            </p>
            <p>
              User.js içinde: <br>
              <pre class="prettyprint ms-0">
  function User(props){ 
    return( 
        &lt;div> 
            {props.isLoggedIn ? `${props.name} ${props.surname}`: "Giriş Yapmadınız"}            
        &lt;/div> 
    ) 
} 

export default User 
              </pre> kuralına uygun olarak veri işlenir ve gönderilir. Bu kodda props obje yapısında olduğundan: <br>
              <pre class="prettyprint ms-0">
  function User(<u>{name, surname, isLoggedIn}</u>){ 
    return( 
        &lt;div> 
            {<u>isLoggedIn</u> ? `<u>${name} ${surname}</u>`: "Giriş Yapmadınız"}            
        &lt;/div> 
    ) 
} 

export default User  
              </pre> olarak da yazılabilir.
            </p>
            <p>
              props gönderme ve alma sırası önemli değil.
            </p>
          </div>
          <div class="row" id="keyProp">
            <h1>Döngülerde "key" Prop'u</h1>
            <p>
              Kompanente prop olarak bir array ekleyip görüntüleyeceğiz.
            </p>
            <p>
              Array listelenen durumlarda her elemanını üstündeki etikette unique bir key değeri belirtilmeli. Bunun için array map metodundan alınan index değeri kullanılabilir.
            </p>
            <p>
              ket değeri reactın performansı için gerekli. Yzılmazsa konsola uyarı verir.
            </p>
            <p>
              Daha önceki örnekte kullandığımız User kompanentine App.js içinde bir array prop olarak girildi: <br>
              <pre class="prettyprint ms-0">
friends={["Ahmet", "Tayfun", "Gökhan", "Ayşe", "Fatma"]}
              </pre> <br>
              User.js içinde .map() metodu ile tek tek çağırıldı. 
              <pre class="prettyprint ms-0">
  {friends.map((friend, index) => ( 
    &lt;div key={index}> 
        {index} - {friend} 
    &lt;/div> 
))} 
              </pre> key olarak index kullanıldı.
            </p>
            <p>
              Kullandığımız array obje yapısındaysa ve unique bir id değeri varsa bu değer de kullanılabilir.
            </p>
            <p>

              örn: <br>
              App.js içinde: <br>
              <pre class="prettyprint ms-0">
const friends = [{name: "Ahmet", id: 1}, {name: "Tayfun", id: 2} , {name: "Gökhan", id: 3} , {name: "Ayşe", id: 4}, {name: "Fatma", id: 5}] 
... 
friends={friends} 
... 
              </pre>
              User.js içinde:
              <pre class="prettyprint ms-0">
{friends.map((friend) => ( 
  &lt;div key={friend.id}> 
  {friend.id} - {friend.name} 
  &lt;/div> 
  ))} 
                </pre> 
                <p>
                  veya
                </p> 
                <pre class="prettyprint ms-0">
{friends.map((friend) => { 
  return (&lt;div key={friend.id}> 
  {friend.id} - {friend.name} 
  &lt;/div>)  
})}
                </pre> Bu yapı özellikle fonksiyon içinde başka bir işlem de yapılacaksa faydalıdır.
              </p>
          </div>
          <div class="row" id="reactDeveloperTool">
            <h1>React Developer Tools</h1>
            <p>
              chrome extansion: <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools</a>
            </p>
            <p>
              Sayfayı sağ tıklayıp incele dediğimizde çıkan menüye Components sekmesi ekler. Bu sayede companentleri ve propslarını sayfamızda ayırdedebiliriz. Hiyerarşik olarak gösterir. Anlık olarak değiştirip değişikliğin sonucunu da deneyebiliriz.
            </p>
          </div>
          <div class="row" id="propTypes">
            <h1>Prop Types</h1>
            <p>
              Kompanentin hangi prop tiplerini kabul edeceğini ayarlamak için kullandığımız bir araç.
            </p>
            <p>
              User kompanenti için User.js içine: <br>
              <pre class="prettyprint ms-0">
import PropTypes from "prop-types";
              </pre> ile "prop-types" import edilir. <br>
              <pre class="prettyprint ms-0">
  User.propTypes = { 
    name: PropTypes.string, 
    surname: PropTypes.string, 
    isLoggedIn: PropTypes.bool, 
    friends: PropTypes.array 
    age: PropTypes.number 
}
              </pre> ile prop tipleri belirtilir.
            </p>

            <h2>isRequired</h2>
            <p>
              Gönderilecek propun zorunlu olduğunu belirtmek için: <br>
              <pre class="prettyprint ms-0">
... 
  name: PropTypes.string.isRequired, 
... 
              </pre>
            </p>

            <h2>oneOfType</h2>
            <p>
              Bir prop için birden fazla veri tipi kabul etmek için: <br>
              <pre class="prettyprint ms-0">
... 
  age: PropTypes.<u>oneOfType</u>([ 
    PropTypes.number, 
    PropTypes.string 
  ]), 
... 
              </pre>
            </p>

            <h2>shape</h2>
            <p>
              Obje olarak gönderilen prop için kullanılabilir. <br>
              <pre class="prettyprint ms-0">
  ... 
  adress: PropTypes.<u>shape</u>({ 
    title: PropTypes.string, 
    zip: PropTypes.number, 
}) 
... 
              </pre>
            </p>
          </div>
          <div class="row" id="defaultProps">
            <h1>Default Props</h1>
            <p>
              İlgili kompanent içinde özellikle prop değeri belirtilmemiş proplar için de default prop değeri atanabilir. <br>
              <pre class="prettyprint ms-0">
User.defaultProps = { 
  isLoggedIn: false, 
} 
              </pre>
              Prop olarak değer gelirse gelen değeri, gelmezse default değeri kullanır.
            </p>
          </div>
          <div class="row" id="stateNedir">
            <h1>State Nedir? Nasıl Oluşturulur?</h1>
            <p>
              State kompanentler üzerinde değerinin değişme potansiyeli olan bütün değerleri tutan JS objesidir. State değişince ilgili kompanentdeki değişim ekrana render edilir. 
            </p>
            <p> 
              <pre class="prettyprint ms-0">
import { useState } from "react"; // useState yapısı react içinden import edilir.
              
function App(){ 
  const [name, setName] = useState("Murat") //fonksiyon içine ilgili state tanımlanır. useState içindeki değer default değerdir.
  ...

    return ( 
    &lt;div> 
        &lt;h1>Hello {name} &lt;/h1>  {/* return içinde değişken gibi kullanılır. */}

        &lt;button onClick={() => setName("Ahmet")}>Click&lt;/button> {/* setname fonksiyonu ile değer değiştirilir. değiştirilmesini sağlayan bir işlem sonrası yeni hali render edilir. */}
  &lt;/div> 
  ); 
}    

export default App;
              </pre>
            </p>
            <p>
              state değeri js içinde kullanılacak tüm değişkenleri içerebilir.
            </p>
            <p>
              Herhangi bir state güncellendiği anda render işlemi baştan yapılır.
            </p>
          </div>
          <div class="row" id="arrayState">
            <h1>Array States</h1>
            <p>
              App.js App fonksiyonunda daha önceki stateleri eklediğimiz yere: <br>
              <pre class="prettyprint ms-0">
const [friends, setFriends] = useState(['Ahmet', 'Murat']);
              </pre> ile array yapıda state eklenir. <br>
              App fonksiyonunun return parantezinin içindeki kapsayıcı div etiketinin içine: <br>
              <pre class="prettyprint ms-0">
&lt;h2>Friends&lt;/h2> 
  { 
    friends.map((friend, i) => ( 
      &lt;div key={i}>{friend}&lt;/div> 
    )) 
  }
              </pre> ile arrayin render edileceği fonksiyon yazılır. 
              <pre class="prettyprint ms-0">
&lt;button onClick={() => setFriends([...friends, 'Ayşe'])}>add new friend&lt;/button>
              </pre> setFriends içindeki yapı ilk tanımdaki gibi array olmalıdır. Buna dikkat edilmezse arrayi yansıtırken kullanılacak kodlarda hata alırız.
            </p>
            <p>
              array içindeki <code>...friends</code> ifadesi mevcut arrayin korunmasını sağlar. Yeni ifade bunun sonuna yazılırsa sonuna, öncesine yazılırsa başına eklenir. 
            </p>
            <p>
              Mevcut ifadeyi korumanın bir başka yolu: <br>
              <pre class="prettyprint ms-0">
setFriends((prevState) => [...prevState, 'Ayşe'])
              </pre> ile önceden eklenen kısım çağırılıp dizine eklenebilir.
            </p>
          </div>
          <div class="row" id="objectState">
            <h1>Object States</h1>
            <p>
              App.js App fonksiyonunda daha önceki stateleri eklediğimiz yere: <br>
              <pre class="prettyprint ms-0">
const [address, setAddress] = useState({ title: 'ev', zip: 34765, city: 'Ankara' });
              </pre> ile object yapıda state eklenir. <br>
              App fonksiyonunun return parantezinin içindeki kapsayıcı div etiketinin içine: <br>
              <pre class="prettyprint ms-0">
&lt;h2>Address&lt;/h2> 
&lt;div>{address.title} {address.zip} {address.city}&lt;/div>
              </pre> ile objenin render edileceği fonksiyon yazılır. <br>
              <pre class="prettyprint ms-0">
&lt;button onClick={() => setAddress({...address, title: 'iş', zip: 34344})}>Change Address&lt;/button>
              </pre> setAddress içindeki yapı ilk tanımdaki gibi object olmalıdır. Buna dikkat edilmezse objeyi yansıtırken kullanılacak kodlarda hata alırız. <br>
            </p>
            <p>
              obje içindeki <pre class="prettyprint ms-0">...address</pre> ifadesi mevcut address bilgilerinin default olmasını sağlar. Bu sayede yeni tanımlanmayan değerler ilk tanıma bağlı kalır. <pre class="prettyprint ms-0">...address</pre> olmazsa value değeri alamayan keyler silinir.
            </p>
            <p>
              Mevcut ifadeyi korumanın bir başka yolu: <br>
              <pre class="prettyprint ms-0">
setAddress((prevState) => {...prevState, title: 'iş', zip: 34344})
              </pre> ile önceden eklenen kısım çağırılıp dizine eklenebilir.
            </p>
          </div>
          <div class="row" id="ornekCount">
            <h1>Sayaç Uygulaması</h1>
            <p>
              src/components içinde Counter.js dosyası oluşturulur. İçine: <br>
              <pre class="prettyprint ms-0">
import React, { useState } from 'react'
              </pre> ile useState import edilir. <br>
              <pre class="prettyprint ms-0">
function Counter() { 
  const [count, setCount] = useState(0)
              </pre> ile state oluşturulur. 
              <pre class="prettyprint ms-0">
  return ( 
    &lt;div> 
        &lt;h1>{count}&lt;/h1>
              </pre> ile state yerleştirilir. 
              <pre class="prettyprint ms-0">
        &lt;button onClick={() => setCount(count+1)}>Decrease&lt;/button> 
        &lt;button onClick={() => setCount(count-1)}>Increase&lt;/button>
              </pre> ile butonlara setCount fonksiyonu verilir. 
              <pre class="prettyprint ms-0">
    &lt;/div> 
  )
} 

export default Counter
              </pre> ile export edilir.
            </p>
            <p>
              App.js içinde veya doğrudan index.js içinde import edilerek kullanılır.
            </p>
            <p>
              onClick fonksiyonlar başka yerde tanımlanıp daha sonra onClick içinde kullanılabilir. <br>
              <pre class="prettyprint ms-0">
function Counter() { 
  const [count, setCount] = useState(0) 

  const increase = () => {
      setCount(count-1)
  } 

  const decrease = () => {
      setCount(count+1)
  } 
  return ( 
    &lt;div> 
        &lt;h1>{count}&lt;/h1> 
        &lt;button onClick={decrease}>Decrease&lt;/button> 
        &lt;button onClick={increase}>Increase&lt;/button> 
    &lt;/div> 
  )
}
              </pre>
            </p>
          </div>
          <div class="row" id="inputState">
            <h1>Input için State Tanımı Yapmak</h1>
            <p>
              src/components içine InputExample.js oluşturulud. içine: <br>
              <pre class="prettyprint ms-0">
import { useState } from "react" 

function InputExample() { 
    const [name, setName] = useState('test') br
    return( 
        &lt;div> 
            Please enter a name: &lt;br /> 
            &lt;input value={name} onChange={(event)=>setName(event.target.value)}/>
              </pre> ile formda değişiklik yapıldığında setName işlemi çağırılır. Forma yazılan value event.target.value yakalanır. 
              <pre class="prettyprint ms-0">
            &lt;br /> 
            {name} 
        &lt;/div> 
    ) 
} 

export default InputExample 
              </pre>
            </p>

            <p>
              onchange içindeki fonksiyonu dışa taşımak için: <br>
              <pre class="prettyprint ms-0">
import { useState } from "react" 

function InputExample() { 
    const [name, setName] = useState('test') 
    const nameChange = (event)=>setName(event.target.value)
              </pre> fonksiyon buraya tanımlanır ve içeride kullanılır. 
              <pre class="prettyprint ms-0">
    return( 
        &lt;div> 
            Please enter a name: &lt;br /> 
            &lt;input value={name} onChange={nameChange}/> 

            &lt;br /> 
            {name} 
        &lt;/div> 
    ) 
} 

export default InputExample 
              </pre>
            </p>
            <p>
              Birden fazla veri alıcak formlarda state'i object olarak vermek daha kullanışlı olacaktır. Bu sayede tek fonksiyon ile tüm formlarda onChange'den veri alınabilir.
              <pre class="prettyprint ms-0">
import { useState } from "react" 

function InputExample() { 
    const [form, setForm] = useState({name:'', surname:''})
              </pre> ile form statei içine name ve surname keyleri boş value ile atanır. 
              <pre class="prettyprint ms-0">
    const formChange = (event)=> setForm({...form, [event.target.name]: event.target.value})
              </pre> ile formdaki değişiklikleri takip edecek fonksiyon yazılır. state objenin key değeri formdaki name değeri ile aynı olmalıdır. 
              <pre class="prettyprint ms-0">
    return(  
        &lt;div> 
            Please enter a name: &lt;br /> 
            &lt;input name='name' value={form.name} onChange={formChange}/> 
            &lt;br /> 
            Please enter a surnamename: &lt;br /> 
            &lt;input name='surname' value={form.surname} onChange={formChange}/> 

            &lt;br /> 
            {form.name} {form.surname} 
        &lt;/div> 
    )
} 

export default InputExample 
              </pre>
            </p>
          </div>
          <div class="row" id="useEffect">
            <h1>useEffect</h1>
            <p>
              kompanenetler DOM'a mount olduğu anda, state değiştiğinde, prop değiştiğinde veya unmount olduğunda bu durmları yakalayıp işlem yaptırabiliyoruz.
            </p>
            <p>
              kompanent içinde herhangi bir ifade değiştiğinde useEffect() çalışır.
            </p>
            <p class="alert alert-warning">
              useState(), useEffect() gibi hooklar kompanentin en başında olmalı ve herhangi bir koşul yapısıda olmamalı.
            </p>
            <p>
              <pre class="prettyprint ms-0">
import { useState, useEffect } from "react";
              </pre> ile useState ve useEffect import edilir. 
              <pre class="prettyprint ms-0">
function App(){ 

  const [age, setAge] = useState(33); 
  const [name, setName] = useState('Murat'); 
  
  useEffect(()=>{ 
    console.log('state güncellendi') 
  })
              </pre> herhangi bir state güncellendiğinde çalışır. 
              <pre class="prettyprint ms-0">
  useEffect(()=>{ 
    console.log('Component mounted') 
  }, []);
              </pre> [] bu şekilde boş ise komponentin mount edildiği anda çalışır. 
              <pre class="prettyprint ms-0">
  useEffect(()=>{ 
    console.log('Age component update') 
  }, [age]);
              </pre> age komponenti güncellendiği anda çalışır. 
              <pre class="prettyprint ms-0">
  useEffect(()=>{ 
    console.log('Age veya name component update') 
  }, [age, name]); 
              </pre> age veya name komponenti güncellendiği anda çalışır. 
              <pre class="prettyprint ms-0">
  return ( 
    &lt;div> 
        
        &lt;h1> 
        Age: {age} &lt;br /> 
        &lt;button onClick={() => setAge(age + 1)}>+&lt;/button> 
        &lt;button onClick={() => setAge(age - 1)}>-&lt;/button> 
        &lt;/h1> 
        &lt;h1> 
        Name: {name} &lt;br /> 
        &lt;button onClick={() => setName('Ahmet')}>değiş&lt;/button> 
        &lt;/h1> 
        
    &lt;/div> 
  );
} 

export default App;
              </pre>
            </p>
          </div>
          <div class="row" id="componentUnmont">
            <h1>Component Unmount</h1>
            <p>
              src/components içinde Counter.js adında yeni dir dosya oluşturuyoruz ve useEffect ve useState fonksiyonunu import ediyoruz. 
            </p>
            <p>
              <pre class="prettyprint ms-0">
function Counter() { 
  const [count, setCount] = useState(0) 

  useEffect(()=>{ 
    console.log('count state update') 
  },[count]) 

  useEffect(()=>{ 
    console.log('componet mounted'); 
    const interval = setInterval(()=>{ 
      setCount((n) => n+1 
    )}, 1000); // bu kısım component mount edildiğinde çalışmaya başlar. 

      return () => clearInterval(interval) // useEffect içindeki returndan sonraki kısım component unmount edildiğinde çalışır. Bizim örneğimizde unmount olduğunda intervali durdurur. <br>
  },[]) 
              
  const increase = () => {
      setCount(count-1) 
  } 

  const decrease = () => {
      setCount(count+1)
  } 
  return ( 
    &lt;div> 
        &lt;h1>{count}&lt;/h1> 
        &lt;button onClick={decrease}>Decrease&lt;/button> 
        &lt;button onClick={increase}>Increase&lt;/button> 
    &lt;/div> 
  ) 
} 

export default Counter 
              </pre>
            </p>
            <p>
              useState ve yeni oluşturduğumuz Counter kompanenti App.js içine import edilir ve sonra: <br>
              <pre class="prettyprint ms-0">
function App() { 
  const [isVisible, setIsVisible] = useState(true) 
  return ( 
    &lt;div> 
      {isVisible && &lt;Counter />} 
      &lt;button onClick={() => setIsVisible(!isVisible)}>change visible&lt;/button> {/* ile butona her basıldığında isVisible değeri değişir. Buna bağlı olarak da Counter mount veya unmount edilir. */}
    &lt;/div> <br> 
  ); 
} <br>
                
export default App; <br>
              </pre>
            </p>
          </div>
          <div class="row" id="contactsApp">
            <h1>Contacts App</h1>
            <p>
              terminale <code>npx create-react-app contacts-app</code> ile yeni bir proje başlattık.
            </p>
            <p>
              src/components/Contacts dosyası oluşturuldu. içine index.js oluşturuldu.
            </p>
            <p>
              .../Contacts/Form ve .../Contacts/List dosyaları oluşturuldu ve her birinin içine index.js oluşturuldu. her iki index.js içinde de birer component tanımlandı ve bunlar .../Contacts/index.js içine import edildi.
            </p>
            <p>
              .../Contacts/index.js içinde bir component oluşturuldu ve içinde import edilen diğer iki component kullanıldı. Oluşan bu component de App.js içinde import edilip kullanıldı.
            </p>
            <p>
              Bu noktaya kadar yazılan componentlerin içine sadece temsili bilgiler girildi.
            </p>
          </div>
          <div class="row" id="contactsForm">
            <h1>Form Component'inin Geliştirilmesi</h1>  
            <p>
              Form/index.js içindeki kompanenetin return kısmında bir form içinde iki tane input bir tane de buton oluşturduk.
            </p>
            <p>
              kompanentin içinde bir form adında obje özellikli bir state oluşturduk. Bu objedeki keyler ile input name değerleri aynı adı taşıyor. 
            </p>
            <p>
              inputlardan gelen event.target.value değerini setForm ile alması için bir fonksiyon yazıp input onChange özelliğine dahil ettik.
            </p>
            <p>
              Contacts/index.js içinde contacts adında array bir state oluşturup hem kendisini hem de değiştirme fonksiyonunu props olarak Form/index.js deki fonksiyona gönderdik.
            </p>
            <p>
              Gelen değiştirme fonksiyonunu form submit sırasında kullanılacak bir fonksiyona dahil ettik. Bu sayede formdan gelen bilgiyi contacts içine ekledik.
            </p>
            <p>
              submit sonrası formu temizlemek için setForm fonksiyonunu kullandık. Bunu ister submt içinde ister useEffect içinde kullanabiliriz.
            </p>
            <p>
              Form/index.js son hali: <br>
              <pre class="prettyprint ms-0">
import { useEffect, useState } from "react"; 

function Form({ addContacts, contacts }) { // ile props olarak gelen state karşılanır. 
              
  const [form, setForm] = useState({ fullname: "", phone_number: "" }); 

  useEffect(()=>{ 
    setForm({ fullname: "", phone_number: "" }) 
  },[contacts]) // ile form içeriği sıfırlanır. 

  const onChangeInput = (e) => { 
    setForm({ ...form, [e.target.name]: e.target.value }); 
  }; // inputa değer girildiğinde form statine dahil eden fonksiyon. input içinde onChange ile kullanılıyor. 
  
  const onSubmit = (e) => { // form submit edildiğinde kullanılan fonksiyon. 
    e.preventDefault(); // formun submit sırasında kullandığı default işlemi engeller. Bu olmazsa submit işlemi adres çubuğunda query ile sonlanır.
    if(form.fullname === ''|| form.phone_number ===''){ 
      return false; 
    } // formda boş kalan yer varsa işlemi sonlandırır. 
    addContacts([...contacts, form]) 
    console.log(form); 
    // setForm({ fullname: "", phone_number: "" }) // işi biten formu sıfırlama işlemi burada da yapılabilir. 
              
  }; 

  return ( 
    &lt;form onSubmit={onSubmit}> // onSubmit fonksiyonu burada kullanıır. 
              
      &lt;div> 
        &lt;input
          name="fullname"
          placeholder="Full Name"
          value={form.fullname}
          onChange={onChangeInput}
        /> 
      &lt;/div> 
      &lt;div> 
        &lt;input
          name="phone_number"
          placeholder="Phone Number"
          value={form.phone_number}
          onChange={onChangeInput}
        /> 
      &lt;/div> 
      &lt;div> 
        &lt;button>Add&lt;/button> 
      &lt;/div> 
    &lt;/form> 
  );
} 

export default Form;

              </pre>
            </p>
            <p>
              Contacts/index.js son hali: <br>
              <pre class="prettyprint ms-0">
import {useState, useEffect} from 'react' 

import List from "./List"; 
import Form from "./Form"; 

function Contacts() { 
  const [contacts, setContacts] = useState([]); 

  useEffect(()=>{ 
    console.log(contacts) 
  },[contacts]) 
  return ( 
    &lt;div>contacts 
        &lt;List /> 
        &lt;Form addContacts={setContacts} contacts={contacts}/> 
    &lt;/div> 
  )
} 
export default Contacts
              </pre>
            </p>
            <p>
              contacts statei daha sonra listeleme işleminde de kullanılacak. Bu nedenle üst companenette oluşturulup props olarak alt companente göndeildi.
            </p>
          </div>
          <div class="row" id="contactsList">
            <h1>Kayıtların Listelenmesi</h1>
            <p>
              Contacts/index.js içinde contacts statei List companentine prop olarak gönderildi. <br>
              <pre class="prettyprint ms-0">
&lt;List contacts={contacts}/>
              </pre>
            </p>
            <p>
              List/index.js içinde gönderilen prop kullanıldı. <br>
              <pre class="prettyprint ms-0">
import {useState} from 'react' 

function List({ contacts }) { 
  return ( 
    &lt;div> 
      &lt;ul> 
        { 
          contacts.map((contact, i)=>( 
            &lt;li key={i}>{contact.fullname}&lt;/li> 
          )) 
        } 
      &lt;/ul> 
    &lt;/div> 
  )
} 

export default List
              </pre>
            </p>
          </div>
          <div class="row" id="contactsFilter">
            <h1>Filtreleme İşlemi</h1>
            <p>
              İşlemi rahat takip edebilmek için Contacts/index.js içinde contacts stateine default değerler atandı.
            </p>
            <p>
              List/index.js içinde filterText statei oluşturuldu. 
            </p>
            <p>
              Filter inputu oluşturuldu. value olarak filterText onChange fonksiyonu olarak da setFilterText atandı. Bu sayede input değeri filterText stateine atanmış oldu.
            </p>
            <p>
              filtered adında bir değişkene contacts üzerinden filter() metodu ile filtreleme yapıldı.
            </p>
            <p>
              return içindeki contents.map() işlemi filtered.map() olarak güncellendi. 
            </p>
            <p>
              List/index.js List companetinin güncel hali: <br>
              <pre class="prettyprint ms-0">
function List({ contacts }) { 
  const [filterText, setFilterText] = useState(""); 
  const filtered = contacts.filter((item) => { // filter() fonksiyonu array içindeki her bir item için döner. item ile bu itemler yakalanır. Fonksiyon sonunda true dönenler filtered değişkenine atanır.
    return Object.keys(item).some((key) => ( // yakalanan itemler obje yapısındadır. Object.keys(item) ile her bir key yakalanır. some() içindeki değerlerden biri true ise true döner.  
      item[key] // ile value yakalanır. 
      .toString() // ile stringe çevirilir. 
      .toLowerCase() //ile tamamı küçük harfe çevrilir. aynı işlem karşılaştırılacağı değere de yapılır. Bu sayede büyük-küçük harf duyarlılığı yaşanmaz. 
      .includes(filterText.toLowerCase()) 
    )); 
  }); 
  
  return ( 
    &lt;div> 
      &lt;input 
        placeholder="Filter contact" 
        value={filterText} 
        onChange={(e) => setFilterText(e.target.value)} 
      /> 

      &lt;ul> 
        {filtered.map((contact, i) => ( // ile filtrelenen değerler yazdırılır. 
          &lt;li key={i}>{contact.fullname}&lt;/li>  
        ))} 
      &lt;/ul> 
    &lt;/div> 
  );
}
              </pre>
            </p>
          </div>
          <div class="row" id="contactsStil">
            <h1>Stil Tanımlarının Yapılması</h1>
            <p>
              css dosyası oluşturup kullanacağımız kompanentin yazıldığı js dosyasına import etmemiz gerekiyor. <br>
              <pre class="prettyprint ms-0">
import './App.css';
              </pre> gibi.
            </p>
            <p>
              Bundan sonraki kısım bildiğiniz css. Css kodlarının çalışması için companent içinde ilgili kısımlara class ve id atıyoruz. <br>
              örnek: <br>
              <pre class="prettyprint ms-0">
&lt;div className="btn"> 
&lt;ul className="list"> 
&lt;div id='container'>
              </pre>
            </p>
          </div>
          <div class="row" id="stilTanimi">
            <h1>Stil Tanımı Yapmak</h1>
            <p>
              Css dosyasını <code>import "./App.css";</code> şeklinde import edebiliriz.
            </p>
            <p>
              Return içinde (JSX) inline style tanımlarını süslü parantez içine obje olarak verebiliriz. <br>
              <pre class="prettyprint ms-0">
&lt;div style={{ color: "red", backgroundColor: "white" }}>&lt;/div>
              </pre><br>
            </p>
            <p>
              js içerisinde tire (-) işareti tanımlamalarda kullanılmadığından stil etiketleri camelcase olarak yazılır. <br>
              background-color yerine <code>backgroundColor</code> <br>
              padding-top yerine <code>paddinTop</code> vs
            </p>
            <p>
              Bootstrap gibi dış kaynak eklemek için: index.html içinde head kısmına yerleştirilebilir.
            </p>
          </div>
          <div class="row" id="moduleCss">
            <h1>Module CSS</h1>
            <p>
              Aynı class ismine sahip farklı companenetler için stil dosyası özellikleri çakışması sonucu stil bilgisi düzgün çalışmıyor. Her birinin kendi style.css dosyasına da tanım girilse react hepsini tek yerde topladığı için, çakışma sorunu çözülmüyor.
            </p>
            <p>
              Burada çözüm olarak module.css kavramı devreye giriyor. <br>
              <table>
                <tr>
                  <th></th>
                  <th>css</th>
                  <th>module.css</th>
                </tr>
                <tr>
                  <th>Dosya Adı</th>
                  <td>styles.css</td>
                  <td>styles.module.css</td>
                </tr>
                <tr>
                  <th>Import</th>
                  <td>import "./styles.css"</td>
                  <td>import styles from "./styles.module.css"</td>
                </tr>
                <tr>
                  <th>className</th>
                  <td>className="title"</td>
                  <td>className={styles.title}</td>
                </tr>
              </table>
            </p>
          </div>
          <div class="row" id="nativeFetch">
            <h1>Native Fetch</h1>
            <p>
              Başka bir kaynaktaki veriyi alıp sayfamızda gösterme işlemi. Bunun için veriyi <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a> adresinden alacağız.
            </p>
            <p>
              Önce src/components içine Users.js dosyası oluşturuldu.
            </p>
            <p>
              içine users statei oluşturuldu. fetch işlemi ile yakalanan veri setUsers ile yakalandı ve return içinde kullanıldı.
            </p>
            <p>
              Yükleme tamamlanana kadar loading... yazması için isLoading statei oluşturuldu ve default değer true atandı. 
            </p>
            <p>
              Koşul olarak isLoading true iken çalışacak şekilde return içinde "Loading..." yazısı eklendi. 
            </p>
            <p>
              fetch işleminin sonuna setIsLoading(false) yerleştirilerek fetch sonrası "Loading..." yazısının kalkması sağlandı.
            </p>
            <p>
              kompanent App.js içine import edilir.
            </p>
            <p>
              Users.js içindeki kod: <br>
              <pre class="prettyprint ms-0">
                import { useEffect, useState } from 'react' 

                function Users() { 
                  const [users, setUsers] = useState([]); 
                  const [isLoading, setIsLoading] = useState(true) 

                  useEffect(()=>{  // component mount edilirken fetch işlemi başlasın 
                    fetch("https://jsonplaceholder.typicode.com/users") // ile veri alınır. 
                    .then(res => res.json()) // ile kullanılabilir hale getirilir. 
                    .then(data => setUsers(data)) // ile users stateine set edilir. 
                    .catch((e) => console.log(e)) 
                    .finally(() => setIsLoading(false)); // ile isLoading false değeri alır. 
              
                  },[]) 

                  return ( 
                    &lt;div> 
                      &lt;h1>Users&lt;/h1> 

                      {isLoading && &lt;div>Loading...&lt;/div&gt;} {/* isLoading true ise Loading... yazar. */}
              
                      {users.map((user)=>( 
                        &lt;p key={user.id}>{user.name}&lt;/p> 
                      ))} 
                    &lt;/div> 
                  )
                } 

                export default Users
              </pre>
            </p>
          </div>
          <div class="row" id="axios">
            <h1>Axios</h1>
            <p>
              fetch işlemi için kullanılan bir diğer kütüphane. fetch ile farkları için: <a href="https://www.geeksforgeeks.org/difference-between-fetch-and-axios-js-for-making-http-requests/">tıklayınız</a>
            </p>
            <p>
              axiosda body obje olarak döner.
            </p>
            <p>
              terminale:
              <pre class="prettyprint ms-0">
npm i axios</pre> yazılır ve kompanente import edilir.
            </p>
            <p>
              yukarıda fetch ile yazılan kodun axios versiyonu: <br>
              <pre class="prettyprint ms-0">
useEffect(()=>{ <br>
  axios("https://jsonplaceholder.typicode.com/users") 
  .then(res => setUsers(res.data)) // gelen response içinde data bizim istediğimiz asıl veriyi verir. 
  .catch((e) => console.log(e)) 
  .finally(() => setIsLoading(false)); 
},[])
              </pre>
            </p>
          </div>
          <div class="row" id="routingKurulum">
            <h1>React Router Kurulum</h1>
            <p>
              <a href="https://reactrouter.com/en/main">reactrouter.com</a> <br>
              <a href="https://v5.reactrouter.com/web/guides/quick-start">v5.reactrouter.com/web/guides/quick-start</a>
            </p>
            <p>
              terminale: <br>
              <pre class="prettyprint ms-0">
npm i react-router-dom
              </pre>
            </p>
            <p>
              video react-router-dom.v5 ile oluşturulmuş. Güncel versiyon react-router-dom.v6. Video ile birebir gidebilmek için terminale: <br>
              <pre class="prettyprint ms-0">
npm install react-router-dom@5
              </pre>
            </p>
            <p>
              Biz yeni versiyon ile devam edeceğiz. Bu <a href="https://reactrouter.com/en/v6.3.0/getting-started/installation">link</a> çok faydalı
              <ul>
                <li>İmport ederken Switch metodu yerine Routes metodu import edilecek</li>
                <li>Routes içindeki Route söz dizimi biraz daha farklı: <br> <pre class="prettyprint ms-0">&lt;Route path="/about">&lt;About />&lt;/Route></pre> <br> yerine <br> <pre class="prettyprint ms-0">&lt;Route path="/about" element={&lt;About/>}/></pre></li>
              </ul> 
            </p>
            <p>
              Sayfaları bu şekilde tanımladığımızda bütün sayfa değil sadece değişecek kısım re-render edilir.
            </p>
            <p>
              <ul>React router dom kullanabilmek için
                <li>en dışa: <b>Router</b> (BrowserRouter) etiketiyle yazılır.</li>
                <li> re-render edilecek kısmın linki <br>Link etiketiyle yazılır. Örn: <pre class="prettyprint ms-0">&lt;Link to="/">Home&lt;/Link></pre></li>
                <li>render edilecek alan <b>Routes</b> etiketinin altına yazılır. (Daha önceki versiyonda Switch kullanılıyor.) Burada koşul belirtilir. Uygun koşula ait kısım render edilir.</li>
                <li> Routes içine koşullar <b>Route</b> etiketi ile yazılır. Örn: <pre class="prettyprint ms-0">&lt;Route path="/about" element={&lt;About/>}/></pre> Bu örnekte çalıştırılan path "/about" ise &lt;About/> kompanenti render edilir.</li>
              </ul>
              <p>
                Örnek App.js: 
                <pre class="prettyprint ms-0">
import "./App.css";
import { Routes, Route, Link, BrowserRouter as Router } from "react-router-dom";

function App() {
  return (
    &lt;>
      &lt;Router>
        &lt;Link to="/">Home&lt;/Link> &lt;br />
        &lt;Link to="/about">About&lt;/Link>
        &lt;Routes>
          &lt;Route path="/" element={&lt;Home />} />
          &lt;Route path="/about" element={&lt;About />} />
        &lt;/Routes>
      &lt;/Router>
    &lt;/>
  );
};

function Home() {
  return (
    &lt;>
      &lt;main>
        &lt;h2>Welcome to the homepage!&lt;/h2>
        &lt;p>You can do this, I believe in you.&lt;/p>
      &lt;/main>
      &lt;nav>
        &lt;Link to="/about">About&lt;/Link>
      &lt;/nav>
    &lt;/>
  );
};

function About() {
  return (
    &lt;>
      &lt;main>
        &lt;h2>Who are we?&lt;/h2>
        &lt;p>That feels like an existential question, dont you think?&lt;/p>
      &lt;/main>
      &lt;nav>
        &lt;Link to="/">Home&lt;/Link>
      &lt;/nav>
    &lt;/>
  );
};

export default App;

                </pre>
              </p>
            </p>
          </div>
          <div class="row" id="exactProp">
            <h1>Exact Prop</h1>
            <p>
              v6 için gerekli değil.
            </p>
            <p>
              v5 te Switch etiketi içinde yazılan path yukarıdan aşağı doğru taranır. İlk eşleşmede değeri getirir. Bu nedenle path="/" üstteyse path="/..." olanlara geçmez. bunu engellemek için exact probu kullanılır.
            </p>
          </div>
          <div class="row" id="urlParameters">
            <h1>URL Parameters</h1>
            <p>
              Bütün fonksiyonlar companent/Rooting adında kendi .js dosyalarına taşındı ve App.js içine import edildi.
            </p>
            <p>
              User.js kompanenti oluşturuldu ve import edildi.
            </p>
            <p>
              App.js Routes alanına ilgili route yazıldı. <br>
              <pre class="prettyprint ms-0">
&lt;Route path="/users/:id" element={&lt;User />} />
              </pre> bu sayede id değişkeni olan durumlarda User kompanenti kullanılacak. Burayda id yerine yazılan değer de User kompanentinde yakalanacak.
            </p>
            <p>
              Users içinde fake api den alınan bilgi kullanıldı ve tekil User sayfaları için link oluşturuldu. <br>
              <pre class="prettyprint ms-0">
import axios from "axios"; 
import { useEffect, useState } from "react"; 
import { Link } from "react-router-dom";  

function Users() { 
  const [users, setUsers] = useState([]); 
  const [loading, setLoading] = useState(true); // Loading... yazısı için 

  useEffect(() => { 
    axios("https://jsonplaceholder.typicode.com/users") 
      .then((res) => setUsers(res.data)) 
      .catch((e) => console.log(e)) 
      .finally(() => setLoading(false)); 
  }, []); 
  return ( 
    &lt;div> 
      &lt;h1>Users&lt;/h1> 
      {loading && &lt;div>Loading...&lt;/div>} 
      &lt;ul> 
        {users.map((user) => ( 
          &lt;li key={user.id}> 
            &lt;Link to={`/users/${user.id}`}>{user.name}&lt;/Link> {/* user.id params olarak gönderildi. User tekil sayfasında tutulup kullanılacak. */}
          &lt;/li> 
        ))} 
      &lt;/ul> 
    &lt;/div> 
  );
} 

export default Users;

              </pre>
            </p>
            <p>
              user içinde :id parametresi yakalandı ve axios içinde ilgili veriyi çekmek için kullanıldı.
            </p>
            <p>
              Her id değiştiğinde sayfanın useEffect çalıştırması için dependency array içine id eklendi.
            </p>
            <p>
              User.js <br>
              <pre class="prettyprint ms-0">
import { useParams } from "react-router-dom"; 
import { useState, useEffect } from "react"; 
import axios from "axios"; 
import Users from "./Users"; 
import { Link } from "react-router-dom"; 

function User() { 
  const [user, setUser] = useState({}); 
  const [loading, setLoading] = useState(true); 

  const { id } = useParams(); // Bağlantıdan gelen params yakalandı. 

  useEffect(() => { 
    axios(`https://jsonplaceholder.typicode.com/users/${id}`) 
      .then((res) => setUser(res.data)) 
      .catch((e) => console.log(e)) 
      .finally(() => setLoading(false)); 
  }, [id]);  //  dependency array alanına id girildi ki bu işlem her id değiştiğinde yenilensin.  
  return ( 
    &lt;div> 
      {loading && &lt;div>Loading...&lt;/div>} 
      &lt;h1>User Detail&lt;/h1> 
      &lt;p>Name: {user.name}&lt;/p> 
      &lt;p>Email: {user.email}&lt;/p> 
      {!loading && &lt;code>{JSON.stringify(user)}&lt;/code>} 
      &lt;p>id: {id}&lt;/p> 
      &lt;Link to={`/users/${parseInt(id) + 1}`}>  //  toplama işleminin yapılabilmesi için string yapıdaki id integer olarak değiştirildi. 
        Next User ({parseInt(id) + 1}) 
      &lt;/Link> 
    &lt;/div> 
  );
} 

export default User;

              </pre>
            </p>
          </div>
          <div class="row" id="nesting">
            <h1>Nesting</h1>
            <p>
              Mevcut kompanent açık kalırken ona bağlı başka bir kompanentin yüklenmesi işlemi.
            </p>
            <p>
              v6 ya göre yapımı için: <a href="https://ui.dev/react-router-nested-routes">tıklayın</a>
            </p>
            <p>
              İlk önce App.js içindeki Routes alanında child olan kompanenti ayarlıyoruz. <br>
              <pre class="prettyprint ms-0">
&lt;Routes>
  &lt;Route path="/about" element={&lt;About/>}/> 
  &lt;Route path="/" element={&lt;Home />} /> 
  &lt;Route path="/users/*" element={&lt;Users/>}> 
    &lt;Route path=":id" element={&lt;User />} /> // bu kısım child kompanente ait. path kısmına da parent kompanentin devamına gelecek kısım yazılır. 
  &lt;/Route> 
&lt;/Routes> 
              </pre>
            </p>
            <p>
              Daha sonra Users.js içine Outlet fonksiyonu "react-router-dom" üzerinden import edilir. <br>
              <pre class="prettyprint ms-0">
import { Link, Outlet} from "react-router-dom";
              </pre>
            </p>
            <p>
              Child kompanentin olmasını istediğimiz yere kompanent yazar gibi <code>&lt;Outlet/></code> eklenir. <br>
<pre class="prettyprint ms-0">
  ... 
  return( 
  ... 
  &lt;Outlet/> 
  ...
  )
</pre>
            </p>
          </div>
          <div class="row" id="navlink">
            <h1>NavLink</h1>
            <p>
              Link etiketinden farklı olarak aktif olma durumunu da veriyor. Buna göre de aktif olan link özelleştirilebiliyor.
            </p>
            <p>
              aktif olduğunda kullanılacak stil verisi jsx yapısına uygun şekilde bir obje olarak bir değişkene atanır.
              <pre class="prettyprint ms-0">
&lt;NavLink style={({isActive}) => isActive ? activeStyle : undefined} to="/">Home&lt;/NavLink>
              </pre> ile style içinde isActive durumu için koşul oluşturulur. Koşul doğru ise daha önceden hazırlanan activeStyle değişkenindeki değer kullanılır.
            </p>
            <p>
              Aynı işlem className için de yapılabilir.
            </p>
          </div>
          <div class="row" id="noMatch">
            <h1>No Match (404)</h1>
            <p>
              Varolan sayfaların dışında kalan tüm path değişkenleri için App.js Routes içine: <br>
              <pre class="prettyprint ms-0">
&lt;Route path="*" element={&lt;Error404 />} />
              </pre> eklenir. Error404 adlı kompanent yaratılır ve App.js içine import edilir. 
            </p>
          </div>
          <div class="row" id="formikKurulum">
            <h1>Formik Kurulum</h1>
            <p>
              Yeni bir react projesi oluşturduk. <br>
              <pre class="prettyprint ms-0">
npx create-react-app formik
              </pre>
            </p>
            <p>
              formik paketi projeye dahil edilir. <br>
              <pre class="prettyprint ms-0">
npm i formik
              </pre>
            </p>
            <p>
              formik dökümantasyonu için <a href="https://formik.org/docs/overview">tıklayınız</a>
            </p>
            <p>
              App.js içinde kullanılır. <br>
              <pre class="prettyprint ms-0">
import React from 'react'; <br>
import { Formik, Field, Form } from 'formik';
</pre> ile formik bileşenleri import edilir. <br>
<pre class="prettyprint ms-0">
import './App.css'; 

function App() { 
  return ( 
    &lt;div className="App"> 
      &lt;h1>Sign Up&lt;/h1> 
    &lt;Formik // Formik yapıları bu etiketin arasına kurgulanır. Açılış etiketine de gerekli formüller yazılır. 
      initialValues={{ // Bu alana state yapısındaki gibi alınacak verinin boş halini giriyoruz. 
        firstName: '', 
        lastName: '', 
        email: '', 
      }} 
      
      onSubmit={(values) => { // input edilen değerlere ne yapılacağını belirleyen fonksiyon 
        console.log(values); 
      }}
    > 
      
      &lt;Form> // Formik yapısının Form oluşturma etiketi. 
        &lt;label htmlFor="firstName">First Name&lt;/label> 
        &lt;Field id="firstName" name="firstName" placeholder="Jane" /> // Field bize inpup yaratıyor. Field alanındaki name ile initialValues alanındaki key aynı olmalı. id önemli değil. 
        &lt;br />
        &lt;br /> 

        &lt;label htmlFor="lastName">Last Name&lt;/label> 
        &lt;Field id="lastName" name="lastName" placeholder="Doe" /> 
        &lt;br />
        &lt;br /> 

        &lt;label htmlFor="email">Email&lt;/label> 
        &lt;Field
          id="email"
          name="email"
          placeholder="jane@acme.com"
          type="email"
        /> 
        &lt;br />
        &lt;br /> 
        &lt;button type="submit">Submit&lt;/button> 
      &lt;/Form> 
    &lt;/Formik> 
    &lt;/div> 
  );
} 

export default App;

              </pre>
            </p>
          </div>
          <div class="row" id="handleSubmitHandleChange">
            <h1>handleSubmit & handleChange</h1>
            <p>
              Formik yapısındaki Form - Field yapısı yerine html yapısında kullanılan form-input yapısını kullanamabilmek için kullanılır.
            </p>
            <p>
              Bir önceki sayfada yazılan kodun handleSubmit ve handleChange ile düzenlenmişi:
              <pre class="prettyprint ms-0">
import React from 'react'; 
import { Formik } from 'formik'; // Form ve Field kısnmına gerek kalmadı. 
import './App.css'; 

function App() { 
  return (br
    &lt;div className="App"> 
      &lt;h1>Sign Up&lt;/h1> 
    &lt;Formik 
      initialValues={{ 
        firstName: '', 
        lastName: '', 
        email: '', 
      }} 
      
      onSubmit={(values) => { 
        console.log(values); 
      }} 
    > 
      {({handleSubmit, handleChange }) => ( // parametre olarak handleSubmit, handleChange kullanılan bir fonksiyon return edilir. Bu iki fonksiyon Formik modülünde tanımlıdır. 
        &lt;form onSubmit={handleSubmit}> // handleSubmit fonksiyonu onSubmit işlemine atanır. 
        &lt;label htmlFor="firstName">First Name&lt;/label> 
        &lt;input name="firstName" onChange={handleChange}/>  // handleChange fonksiyonu onChange işlemine atanır. 
      
        &lt;br />
        &lt;br /> 

        &lt;label htmlFor="lastName">Last Name&lt;/label> 
        &lt;input name="lastName" onChange={handleChange}/> 
        
        &lt;br />
        &lt;br /> 

        &lt;label htmlFor="email">Email&lt;/label> 
        &lt;input name="email" type="email" onChange={handleChange}/> 
        &lt;br />
        &lt;br /> 
        &lt;button type="submit">Submit&lt;/button> 
      &lt;/form> 
      )} 
      
    &lt;/Formik> 
    &lt;/div> 
  ); 
} 

export default App;
              </pre>
            </p>
          </div>
          <div class="row" id="radioCheckboxDropdown">
            <h1>Radio / Checkbox / Dropdown</h1>
            <p>
              forma eklenecek bilgilerin alınabilmesi için formda name keyine karşılık gelen value initialValues alanına eklenmeli. <br>
              <pre class="prettyprint ms-0">
... 
&lt;Formik 
  initialValues={{ 
    firstName: "", 
    lastName: "", 
    email: "drmuratgokduman@gmail.com", // formda varsayılan olarak gelmesini istediğimiz değer varsa bu şekilde yazabiliriz. bunu da value={values.email} ile formda yakalayabiliriz. 

    gender: "male", 
    hobies: [], 
    county: "tr", 
  }} 
  ... 
</pre>
</p>
<p>
Formda yaptığımız değişiklerin etkisini görmek için: 
<pre class="prettyprint ms-0">
... 
          <u>&lt;code>{JSON.stringify(values)}&lt;/code></u> 
    &lt;/form> 
  )} 
&lt;/Formik> 
... 
              </pre>
            </p>
            
            <h2>Radio</h2>
            <p>
              <pre class="prettyprint ms-0">
... 
&lt;span>Male&lt;/span> 
&lt;input 
  type={"radio"} 
  name="gender"  // initialValues alanı ile eşleşecek. 
  value={"male"} // seçilirse forma gönderilecek veri 
  onChange={handleChange} 
  checked={values.gender === "male"} // form varsayılanı olarak initialValues içinde girilen değerin form açıldığında seçili gelmesini sağlar. 
/> 
&lt;span>Female&lt;/span> 
&lt;input 
  type={"radio"} 
  name="gender" 
  value={"female"} 
  onChange={handleChange} 
  checked={values.gender === "female"} 
  ... 
              </pre>
            </p>

            <h2>Checkbox</h2>
            <p>
              <pre class="prettyprint ms-0">
&lt;div> 
  &lt;input 
    type="checkbox" 
    name="hobies" 
    value="Play Playstation" 
    onChange={handleChange} 
  /> 
  Play Playstation 
&lt;/div> 
&lt;div> 
  &lt;input 
    type="checkbox" 
    name="hobies" 
    value="Read a Book" 
    onChange={handleChange} 
  /> 
  Read a Book 
&lt;/div> 
&lt;div> 
  &lt;input 
    type="checkbox" 
    name="hobies" 
    value="Write Code" 
    onChange={handleChange} 
  /> 
  Write Code 
&lt;/div>
              </pre>
            </p>

            <h2>Dropdown</h2>
            <p>
              <pre class="prettyprint ms-0">
&lt;select name="coutry" value={values.county} onChange={handleChange}> // value={values.county} ile formda değişiklik yoksa default değer kullanılır. 
  &lt;option value="tr">Turkey&lt;/option> 
  &lt;option value="en">England&lt;/option> 
  &lt;option value="usa">USA&lt;/option> 
&lt;/select>
              </pre>
            </p>
          </div>
          <div class="row" id="useFormik">
            <h1>useFormik</h1>
            <p>
              Formu &lt;Formik> etiketi ile sarmalamadan formik yapısı kullanmak için useFormik hooku kullanılabilir. 
            </p>

            <p>
              returndan önceki tanımlama kısmına <br>
              <pre class="prettyprint ms-0">
const Formik = useFormik({ 
  initialValues: { 
    firstName: "", 
    ... 
  } 
  onSubmit: (values) => { 
    console.log(values); 
  }, 
})
              </pre> yazılır. form içinde kullanılan diğer hooklar <br>
              <code>
                <b>handleSubmit</b>: Formik.handleSubmit <br>
                <b>handleChange</b>: Formik.handleChange 
              </code> gibi kullanılabilir. 
            </p>
            <p>
              veya tanımda Formik yerine yazılarak daha önce kullanıldıkları halleri ile kullanılabilirler. <br>
              <pre class="prettyprint ms-0">
                const { handleSubmit, handleChange, values } = useFormik({ ...
              </pre>
            </p>
            <p>
              Daha önceki konularda oluşturduğumuz formun useFormik ile yazılmış hali: <br>
              <pre class="prettyprint ms-0">
import React from "react"; 
import { useFormik } from "formik"; //ile useFormik import edilir. 
import "./App.css"; 

function App() { 
  const { handleSubmit, handleChange, values } = useFormik({ // ile tanımlamalar yapılır. 
    initialValues: { 
      firstName: "", 
      lastName: "", 
      email: "drmuratgokduman@gmail.com", 
      gender: "male",  
      hobies: [], 
      county: "tr", 
    }, 
    onSubmit: (values) => { 
      console.log(values); 
    }, 
  }); 

  return ( 
    &lt;div className="App"> // Form &lt;Formik> etiketi kullanılmadan yazılır. 
      &lt;/div> 
      &lt;h1>Sign Up&lt;/h1> 

      &lt;form onSubmit={handleSubmit}> 
        &lt;label htmlFor="firstName">First Name&lt;/label> 
        &lt;input name="firstName" onChange={handleChange} /> 

        &lt;br /> 
        &lt;br /> 

        &lt;label htmlFor="lastName">Last Name&lt;/label> 
        &lt;input name="lastName" onChange={handleChange} /> 

        &lt;br />
        &lt;br /> 

        &lt;label htmlFor="email">Email&lt;/label> 
        &lt;input
          name="email"
          type="email"
          value={values.email}
          onChange={handleChange}
        /> 
        &lt;br />
        &lt;br /> 

        &lt;span>Male&lt;/span> 
        &lt;input
          type={"radio"}
          name="gender"
          value={"male"}
          onChange={handleChange}
          checked={values.gender === "male"}
        /> 
        &lt;span>Female&lt;/span> 
        &lt;input
          type={"radio"}
          name="gender"
          value={"female"}
          onChange={handleChange}
          checked={values.gender === "female"}
        /> 
        &lt;br />
        &lt;br /> 

        &lt;div> 
          &lt;input
            type="checkbox"
            name="hobies"
            value="Play Playstation"
            onChange={handleChange}
          /> 
          Play Playstation 
        &lt;/div> 
        &lt;div> 
          &lt;input
            type="checkbox"
            name="hobies"
            value="Read a Book"
            onChange={handleChange}
          /> 
          Read a Book 
        &lt;/div> 
        &lt;div> 
          &lt;input
            type="checkbox"
            name="hobies"
            value="Write Code"
            onChange={handleChange}
          /> 
          Write Code 
        &lt;/div> 

        &lt;br />
        &lt;br /> 

        &lt;select name="coutry" value={values.county} onChange={handleChange}> 
          &lt;option value="tr">Turkey&lt;/option> 
          &lt;option value="en">England&lt;/option> 
          &lt;option value="usa">USA&lt;/option> 
        &lt;/select> 
        &lt;br />
        &lt;br /> 
        &lt;button type="submit">Submit&lt;/button> 
        &lt;br />
        &lt;br /> 
        &lt;code>{JSON.stringify(values)}&lt;/code> 
      &lt;/form> 
    &lt;/div> 
  );
} 

export default App;

              </pre>
            </p>

          </div>
          <div class="row" id="formValidasyon">
            <h1>Form Validasyonları (yup)</h1>
            <p>
              Validasyon çalışması için formumuzu email, password ve confirm password imputlarıyla ouşturduk. 
            </p>
            <p>
              Validasyon işlemini <q>yup</q> paketi ile yapacağız. Bunun için terminale:<br>
              <pre class="prettyprint ms-0">
npm i yup
              </pre>
            </p>
            <p>
              App.js içindeki kompanent src/components/Singup.js içine taşındı ve App.js içinde import edilerek kullanıldı.
            </p>
            <p>
              src/components/validations içinde validasyon işlemi tanımlandı ve export edildi. <br>
              <pre class="prettyprint ms-0">
import * as yup from "yup"; <br><br>

const validations = yup.object().shape({ // validasyon kuralları yup içinde obje olarak tanımlanır. 
  email:  // buradaki key ler valide edilecek formun initialValues alanındakiler ile aynı olmalı. 
    yup.string() // string yapıda 
      .email() // email formatında 
      .required(), // ve zorunlu olarak doldurulacak. 
  password:  
    yup.string() 
      .min(5) // en az 5 karakter. 
      .required(), 
  passwordComfirm: 
    yup.string() 
      .oneOf([yup.ref("password")]) // password alanındaki veriyle aynı olmalı. 
      .required(), 
}); 

export default validations;

              </pre>
            </p>
            <p>
              validasyon kullanılacağı Singup.js içine import edilir ve formik yapısı içindeki validationSchema ile eşleştirilir. <br>
              <pre class="prettyprint ms-0">
import React from "react"; 
import { useFormik } from "formik"; 
import validations from "./validation"; 

function Singup() { 
  const { handleSubmit, handleChange, values } = useFormik({ 
    initialValues: { 
      email: "", 
      password: "", 
      passwordComfirm: "", 
    }, 
    onSubmit: (values) => { 
      console.log(values); 
    }, 
    validationSchema: validations // validations import edilirken validationSchema adıyla alınırsa bu eşleştirmeye gerek kalmadan sadece "validationSchema" yazılarak da kullanılabilir. 
  }); 
  return ( 
    &lt;div> 
      &lt;h1>Sign Up&lt;/h1> 
      &lt;form onSubmit={handleSubmit}> 
        &lt;label>Email&lt;/label> 
        &lt;input
          name="email"
          value={values.email}
          onChange={handleChange}
        />
        &lt;br />
        &lt;br /> 
        &lt;label>Password&lt;/label> 
        &lt;input
          name="password"
          value={values.password}
          onChange={handleChange}
        />
        &lt;br />
        &lt;br /> 
        &lt;label>Password Comfirm&lt;/label> 
        &lt;input 
          name="passwordComfirm"
          value={values.passwordComfirm}
          onChange={handleChange}
        /> 
        &lt;br />
        &lt;br /> 
        &lt;button type="submit">Submit&lt;/button>
        &lt;br />
        &lt;br /> 
        &lt;code>{JSON.stringify(values)}&lt;/code> 
      &lt;/form> 
    &lt;/div> 
  );
} 

export default Singup;

              </pre>
            </p>

            <h2>Hata Mesajlarının Gösterimi</h2>
            <p>
              Bunun için formik yapısına errors, touched ve handleBlur özellikleri import edilir. <br>
              <b>errors</b>: hata mesajlarını yakalar. hatanın olduğu kısım key, hata mesajı value olan bir object döner. <br>
              <b>touched</b>: yazıldığı kısma kullanıcı teması olma durumunu verir. <br>
              <b>handleBlur</b>: touched değerini günceller.
            </p>
            <p>
              Koşul cümlesi ile hata mesajı alınır. <br>
              <pre class="prettyprint ms-0">
{errors.email && touched.email && &lt;div className="error">&lt;br/>{errors.email}&lt;/div>}
              </pre> <br>
              <b>errors.email</b>: hata mesajı varsa <br>
              <b>touched.email</b>: email inputuna dokunulduysa <br>
              <b>&lt;div className="error">&lt;br/>{errors.email}&lt;/div>}</b> kodunu yerleştir.
            </p>
            <p>
              Örnek: <br>
              <pre class="prettyprint ms-0">
  ... 
return( 
  ... 
  &lt;input
    name="password"
    value={values.password}
    onChange={handleChange}
    onBlur={handleBlur}
  /> 
  &lt;br /> 
  {errors.password && touched.password && &lt;div className="error">&lt;br/>{errors.password}&lt;/div>} 
  &lt;br /> 
  ... 
)
              </pre>
            </p>
            <p>
              Koşula göre verilen hata kodu default haliyle ingilizce açıklamalar verir. Bunu özelleştirebiliriz. Bunun için validation.js içinde: <br>
              <pre class="prettyprint ms-0">
import * as yup from "yup"; 

const validations = yup.object({ 
  email: 
    yup.string() 
    .email('<u>Geçerli bir email girin</u>') 
    .required('<u>Doldurulması zorunludur</u>'), 
  password: 
    yup.string() 
    .min(5, '<u>Parolanız en az 5 karakter olmalıdır</u>') 
    .required('<u>Doldurulması zorunludur</u>'), 
  passwordComfirm: 
    yup.string() 
    .oneOf([yup.ref("password")], '<u>Parolalar uyuşmuyor</u>') 
    .required('<u>Doldurulması zorunludur</u>'), 
}); 

export default validations;

              </pre>
            </p>
          </div>
          <div class="row" id="reactMemo">
            <h1>React.memo</h1>
            <p>
              React içindeki gereksiz render işlemlerini engelleyip performansı arttırmak için kullanılır.
            </p>
            <p>
              React projesinde bir kompanentin içinde yer alan kompanent dış kompanent her render edildiğinde kendisinde bir değişiklik olmasa bile yeniden render ediliyor. Bunu engellemek için export işlemi sırasında React.memo kullanılır. Örn: <br>
              <pre class="prettyprint ms-0">
export default React.memo(Header)
              </pre>
            </p>
            <p>
              Bu durumda Header kompanentinde veya gelen propunda bir değişiklik olmadıkça re-render edilmez.
            </p>
            <h2>Örnek</h2>
            <p>
              Header.js: <br>
              <pre class="prettyprint ms-0">
import React from 'react' 

function Header({number}) { 
    console.log("Header Component Re-Rendered!"); // Re-render işlemini konsoldan takip edebilmek için yazıldı. 
  return ( 
    &lt;div>Header - {number}&lt;/div> 
  ) 
} 

export default React.memo(Header) // export edilecek fonksiyon React.memo ile sarmalandı.
              </pre> 
            </p>
            <p>
              App.js <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import { useState } from "react"; 
import Header from './components/Header' 

function App() { 
  const [number, setNumber] = useState(0) 
  return ( 
    &lt;div className="App"> 
      &lt;Header number={number &lt; 5 ? 0 : number} /> // Header içine gönderilecek number probu number 5 ten küçük olduğu sürece 0 olarak gönderilecek. 
      &lt;hr /> 
      &lt;h1>{number}&lt;/h1> 
      &lt;button onClick={()=>setNumber(number +1)}>Click&lt;/button> 

    &lt;/div> 
  );
} 

export default App;

              </pre>
            </p>
            <p>
              Yukarıdaki örnekte number stateti 0 dan başlar ve her butona basıldığında number 1 artar. number değeri 5i geçene kadar gönderilen number propu 0 olarak kalır. Bu nedenle de o ana kadar Header kompanentinde re-render olmaz.
            </p>
            <p>
              Header içinde proptan gelen veri kullanılmasa da değer değiştiğinde re-rendering olur.
            </p>
          </div>
          <div class="row" id="useMemo">
            <h1>useMemo</h1>
            <p>
              Aynı içeriğe sahip object veya array yapılarının denkliği js üzerinden sorgulandığında, arka plandaki referansları farklı olduğundan değer false döner. Bu nedenle prop olarak gönderilen object veya array kompanent içindeyse, içinde olduğu kompanent her render edildiğinde prop da yeni veri göndermiş gibi davranır.
            </p>
            <p>
              Bundan kurtulmak için prop olarak gönderilecek object veya array kompanentin dışında tanımlanabilir.
            </p>
            <p>
              Kompanentin içinde yazılması gerekiyorsa useMemo hooku kullanılır. örn: <br>
              <pre class="prettyprint ms-0">
const data = useMemo(()=>{ 
  return {name: "Murat"} 
},[])
              </pre>
            </p>
            <p>
              useMemo useEffect gibi davranır. dependence array'e yazılan değer değiştiğinde içerideki değeri tekrar döndürür.
            </p>

            <h2>Örnek 1</h2>
            <p>
              Header.js: <br>
              <pre class="prettyprint ms-0">
import React from 'react' 

function Header({number, data}) { 
    console.log("Header Component Re-Rendered!"); 
  return ( 
    &lt;div>Header - {number} - {JSON.stringify(data)&lt;/div> 
  ) 
} 

export default React.memo(Header) //export edilecek fonksiyon React.memo ile sarmalandı.
              </pre> 
            </p>
            <p>
              App.js <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import { useState } from "react"; 
import Header from './components/Header' 

function App() { 
  const [number, setNumber] = useState(0) 
  const data = useMemo(()=>{ // data object yapısı useMemo ile tanımlandı. 
    return {name: "Murat"}
  },[]) // [] içine girilen yapı değiştiğinde verinin yeniden gönderimini yapar. [] içi boşsa değeri sabit tutar. 
  return ( 
    &lt;div className="App"> 
      &lt;Header number={number &lt; 5 ? 0 : number} />
      &lt;hr /> 
      &lt;h1>{number}&lt;/h1> 
      &lt;button onClick={()=>setNumber(number +1)}>Click&lt;/button> 

    &lt;/div> 
  );
} 

export default App;
              </pre>
            </p>
            <h2>Örnek 2</h2>
            <p>
              Bize değişken olarak verilen değer bir fonksiyonun çıktısıysa ve biz her seferinde bu fonksiyonun çalışmasını istemiyorsak useMemo kullanırız.
            </p>
            <p>
              App.js: <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import { useMemo, useState } from "react"; 
import Header from './components/Header' 

function App() { 
  const [number, setNumber] = useState(0) 
  const [text, setText] = useState("") 
  
  const data = useMemo(()=>{ 
    return caculateObject() 
  },[]) 

  return ( 
    &lt;div className="App"> 
      &lt;Header number={number &lt; 5 ? 0 : number} data={data} /> 
      &lt;hr /> 
      &lt;h1>{number}&lt;/h1> 
      &lt;button onClick={()=>setNumber(number +1)}>Click&lt;/button> 
      &lt;br /> 
      &lt;br /> 
      &lt;input value={text} onChange={({target}) => setText(target.value)}/> 
    &lt;/div> 
  ); 

  function caculateObject(){ // Objeyi return edecek fonksiyon. 
    console.log("Calculating..."); 
    for(let i=0; i&lt;1000000000; i++){} // hesaplamanın zaman aldığı bir işlem simüle edildi. 
    console.log("Calculating completed!"); 

    return {name: "Murat"} 
  } 

} 

export default App;

              </pre>
            </p>
            <p>
              Biz burada useMemo kullanmak yerine <pre class="prettyprint ms-0">const data = caculateObject()</pre> ile tanımlama yaparsak forma her bir harf girmeye çalıştığımızda yukarıdaki fonksiyon tekrar çalışır ve bizi bekletir.
            </p>
          </div>
          <div class="row" id="useCallback">
            <h1>useCallback</h1>
            <p>
              İç içe kompanent yapısında içteki kompanente prop olarak fonksiyon gönderdiğimizde ve dıştaki kompanent re-render edildiğinde, fonksiyon baştan hesaplandığı için React.memo kullanılsa bile içteki kompanent de re-render ediliyor. Bunu engellemek için <b>useCallback</b> kullanılıyor.
            </p>
            <p>
              Kullanımı useMemo gibi. Fonksiyon useCallback içinde tanımlanır ve prop olarak gönderilir.
            </p>
            <p>
              <pre class="prettyprint ms-0">
const increment = useCallback(() => { 
  setNumber(number + 1) 
},[number]) 
              </pre>setNumber(number + 1) fonksiyonunun döndüğü durumda [] içine number yazılmazsa ilk değeri 0 olan number fonksiyonda işlenir ve sonuca sabitlenir. Number güncellendiğinde fonksiyonun tekrar çalışabilmesi için dependence array ("[]") içine yazılır. Ancak bu durmumda da yeni bir fonksiyon tanımlandığından Header re-render edilir. Bunu engellemek için fonksiyon number olmadan yazılmalıdır.
            </p> 
            <p>
              <pre class="prettyprint ms-0">
const increment = useCallback(() => { 
  setNumber((preState) => preState + 1); 
}, []); 
              </pre>
            </p>

            <h2>Örnek</h2>
            <p>
              App.js <br>
              <pre class="prettyprint ms-0">
import "./App.css"; 
import { useMemo, useState, useCallback } from "react"; 
import Header from "./components/Header"; 

function App() { 
  const [number, setNumber] = useState(0); 
  const [text, setText] = useState(""); 

  const increment = useCallback(() => { // Fonksiyon useCallback içinde tanımlanır. 
    setNumber((preState) => preState + 1); 
  }, []); 

  return ( 
    &lt;div className="App"> 
      &lt;Header increment={increment} /> // tanımlanan fonksiyon prop ile gönderilir. 
      &lt;hr /> 
      &lt;h1>{number}&lt;/h1> 

      &lt;br /> 
      &lt;br /> 
      &lt;input value={text} onChange={({ target }) => setText(target.value)} /> 
    &lt;/div> 
  );
} 

export default App;

              </pre>
            </p>
            <p>
              Header.js: <br>
              <pre class="prettyprint ms-0">
import React from 'react' 

function Header({number, increment}) {  // ile prop alındı. 
    console.log("Header Component Re-Rendered!"); 
  return ( 
    &lt;div> 
        Header - {number} 
        &lt;br /> 
        &lt;br /> 
        &lt;button onClick={increment}>Click&lt;/button> {/* ile alınan prop kullanıldı. */}
    &lt;/div> 
  )
} 

export default React.memo(Header)
              </pre>
            </p>
          </div>
          <div class="row" id="contextNedir">
            <h1>Context Nedir?</h1>
            <p>
              Elimizdeki datanın tüm kompanentlerde kullanılabilmesini sağlar. Contex içindeki dataya herhangi bir kompanentten ulaşıp manipule edebiliriz.
            </p>
          </div>
          <div class="row" id="contextOlusturmak">
            <h1>Context Oluşturmak</h1>
            <p>
              src/context klasörü içine ThemeContext.js dosyası oluşturulur. <br>
              <pre class="prettyprint ms-0">
import { createContext } from "react";

const ThemeContext = createContext(); // ile context yaratıldı

export default ThemeContext; 
              </pre>
            </p>
            <p>
              Context içine veri göndermek için App.js: <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import Button from './components/Button'; 
import ThemeContext from "./context/ThemeContext"; // ile context import edildi.

function App() { 
  return ( 
    &lt;ThemeContext.Provider value="dark"> // ile içine yazılacak tüm kompanentlere veri gönderildi.
      &lt;Button/> 
    &lt;/ThemeContext.Provider> 
  );
} 

export default App; 

              </pre>
            </p>
            <p>
              Context içindeki veriyi almak için Button.js içine: <br>
              <pre class="prettyprint ms-0">
import { useContext } from 'react' 
import ThemeContext from "../context/ThemeContext"; 

function Button() { 
    const data = useContext(ThemeContext) // data ile ThemeContext içinde gönderilen veri değişkene atandı.
    console.log(data); 
  return ( 
    &lt;div>Button ({data})&lt;/div> 
  ) 
} 

export default Button
              </pre>
            </p>
          </div>
          <div class="row" id="contextProvider">
            <h1>Context Provider</h1>
            <p>
              Children: bir kompanenti kapalı parantezle değil de html tagi gibi yazarsak arasına yazdığımız değerler prop gibi kompanente gönderilir ve chidren ile yakalanıp kullanılabilir.
            </p>
            <p>
              chidren perspektifinde ThemeContext.Provider etiketi ve ona eklenen veriler ThemeContext.js dosyasına aktarılabilir.
            </p>
            <p>
              ThemeContext.js: <br>
              <pre class="prettyprint ms-0">
import { createContext, useState } from "react"; 

const ThemeContext = createContext(); 

export const ThemeProvider = ({ children }) => { //  ThemeProvider değişkeni kompanent yapısıyla export edilir. İçine yazılacaklar children ile prop olarak alınır.
    const [theme, setTheme] = useState("dark")  // ile state oluşturuldu. 
    const values = { 
        theme, 
        setTheme 
    }  //  ile state değerleri değişkene atandı. 
  return &lt;ThemeContext.Provider value={values}>{children}&lt;/ThemeContext.Provider>;  {/*  ThemeContext.Provider parantezleri, values verisi ve children verisi return edilir. */}
}; 

export default ThemeContext;

              </pre>
            </p>
            <p>
              App.js içinde: <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import Button from './components/Button'; 
import Header from './components/Header'; 
import {ThemeProvider} from "./context/ThemeContext"; 

function App() { 
  return ( 
    &lt;ThemeProvider> // ile kompanent içinde children olacak şekilde kurgulanır. Buradan gönderilen veri children olarak ThemeContext.js içinde kullanılır ve o perspektifte render edilir.
      &lt;Header/> 
      &lt;hr /> 
      &lt;Button/> // chidren olarak Header ve Button kompanentleri yerleştirilir.
    &lt;/ThemeProvider> 
  );
} 

export default App;
              </pre>
            </p>
            <p>
              Kompanent içinden context içindeki veriyi almak ve manipule etmek için Header.js<br>
              <pre class="prettyprint ms-0">
import React, { useContext } from 'react' 
import ThemeContext from '../context/ThemeContext' 

function Header() { 
    const {theme, setTheme} = useContext(ThemeContext) // ile ThemeContext içinden gönderilen value yakalandı.

  return ( 
    &lt;div>Header: {theme} &lt;button onClick={()=>setTheme(theme === "dark" ? "light" : "dark")}>Click&lt;/button> 
    &lt;/div> 
  )
} 

export default Header 
              </pre>
            </p>
            <p>
              Aynı işlem Button.js içinde de tekrarlanabilir. Her iki buton da theme değerini değiştirir. <br>
              <pre class="prettyprint ms-0">
import { useContext } from 'react' 
import ThemeContext from "../context/ThemeContext"; 

function Button() { 
    const {theme, setTheme} = useContext(ThemeContext) 
  return ( 
    &lt;div> 
      Active Theme: {theme} 
      &lt;button onClick={()=>setTheme(theme === "dark" ? "light": "dark")}>Click&lt;/button> 
    &lt;/div>  
  )
} 

export default Button 
              </pre>
            </p>
          </div>
          <div class="row" id="themeSwitcher">
            <h1>Theme Switcher Yapımı</h1>
            <p>
              Kapsayıcı kompanent olması için Container kompanenti oluşturuldu ve diğer kompanenetler onun içinde kullanıldı. Container kompanenti de App.js içinde import edilip kullanıldı.
            </p>
            <p>
              Daha önce ThemeContext içinde gönderdiğimiz veriyi Container içindeki kapsayıcı div etiketine className vermek için kullandık. Bu className değerini de App.css içinde style ile karşıladık.
            </p>
            <p>
              App.js <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import Container from './components/Container'; 
import {ThemeProvider} from "./context/ThemeContext"; 

function App() { 
  return ( 
    &lt;ThemeProvider> 
      &lt;Container/> 
    &lt;/ThemeProvider> 
  ); 
} 

export default App;
 
              </pre>
            </p>
            <p>
              Container.js <br>
              <pre class="prettyprint ms-0">
import React, { useContext } from "react"; 
import Button from "./Button"; 
import Header from "./Header"; 
import ThemeContext from "../context/ThemeContext"; 

function Container() { 
  const { theme } = useContext(ThemeContext); 
  return ( 
    &lt;div className={`app ${theme}`}> // butona her basıldığında theme değiştiğinden div etiketinin aldığı className de değişiyor. 
      &lt;Header /> 
      &lt;hr /> 
      &lt;Button /> 
    &lt;/div> 
  );
} 

export default Container;

              </pre>
            </p>
            <p>
              App.css <br>
              <pre class="prettyprint ms-0">
.app { 
  text-align: center; 
  height: 100vh; 
} 

.dark { 
  color: white; 
  background-color: black; 
}
              </pre>
            </p>
          </div>
          <div class="row" id="contextProviderSideEffects">
            <h1>Context Provider Side Effects</h1>
            <p>
              theme bilgisini localStorage üzerine ekleyeceğiz. Bu sayede sayfa yenilendiğinde son verdiğimiz hali bize gösterecek.
            </p>
            <p>
              ThemeContext.js içinde: <br>
              <pre class="prettyprint ms-0">
import { createContext, useEffect, useState } from "react"; 

const ThemeContext = createContext(); 

export const ThemeProvider = ({ children }) => { 
  const [theme, setTheme] = useState(localStorage.getItem('theme') || 'light'); // localStorage içinde theme keyine ait value varsa getir. yoksa 'light' değerini ata.

  useEffect(()=>{ 
    localStorage.setItem("theme", theme) 
  },[theme]) // theme değeri her değiştiğinde yeni değeri localStorage içine theme keyine karşılık ata.

  const values = { 
    theme, 
    setTheme, 
  }; 

  return ( 
    &lt;ThemeContext.Provider value={values}>{children}&lt;/ThemeContext.Provider> 
  ); 
}; 

export default ThemeContext;

              </pre>
            </p>
          </div>
          <div class="row" id="multiContext">
            <h1>Multi Context</h1>
            <p>
              Yeni bir context oluşturduk. UserContext.js: <br>
              <pre class="prettyprint ms-0">
const { createContext, useState } = require("react"); 

const UserContext = createContext() 

export const UserProvider = ({children})=> { // App.js içinde bu contexten gelen veriyi alacak olan kompanentleri sarmalaması için UserProvider tanımlanır.
    const [user, setUser] = useState(null) // context ile göndermek için state oluşturuldu.
    const values = {
        user,
        setUser,
    } 

    return &lt;UserContext.Provider value={values}>{children}&lt;/UserContext.Provider> 
} 

export default UserContext
              </pre>
            </p>
            <p>
              App.js içinde <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import Container from './components/Container'; 
import {ThemeProvider} from "./context/ThemeContext"; 
import { UserProvider } from './context/UserContext'; 

function App() { 
  return ( 
    &lt;ThemeProvider> 
      &lt;UserProvider> // ile Container sarılır.
        &lt;Container/> 
      &lt;/UserProvider> 
    &lt;/ThemeProvider> 
  );
} 

export default App;
 
              </pre>
            </p>
            <p>
              Profile.js kompanenti oluşturulur ve Container içine import edilir.
            </p>
            <p>
              Profile.js içinde: <br>
              <pre class="prettyprint ms-0">
import { useContext, useState } from "react"; 

import UserContext from "../context/UserContext";

function Profile() { 
  const { user, setUser } = useContext(UserContext); 
  const [loading, setLoading] = useState(false);  

  const handleLogin = () => { 
    setLoading(true); 
    setTimeout(() => { 
      setUser({ 
        id: 1, 
        username: "arslanng", 
        bio: "lorem ipsum dolor", 
      }); 
      setLoading(false); 
    }, 1500); // ile süre alan bir işlem simüle edilerek loading yazısı ekranda gösterilmiştir.
  }; 
  return ( 
    &lt;div> 
      {!user && ( 
        &lt;button onClick={handleLogin}> 
          {loading ? "loading..." : "Login"} 
        &lt;/button> 
      )} 
      {JSON.stringify(user)} 

      {user && &lt;button onClick={()=>setUser(null)}>Logout&lt;/button>} 

    &lt;/div> 
  ); 
} 

export default Profile;

              </pre>
            </p>
          </div>
          <div class="row" id="customContextHook">
            <h1>Custom Context Hook</h1>
            <p>
              Birden fazla yerde yapılacak context ile ilgili işlemler context içinde tanımlanıp export edilerek kullanılabilir. <br>
              <code>useContext(ThemeContext); </code> örneğimizde birden fazla kompanentte kullanılıyor. Kodu sadeleştirmek için bu işlemi kompanentte değil context dosyasında yapabiliriz.
            </p>
            <p>
              ThemeContext.js: <br>
              <pre class="prettyprint ms-0">
import { createContext, useContext, useEffect, useState } from "react"; 

const ThemeContext = createContext(); 

export const ThemeProvider = ({ children }) => { 
  const [theme, setTheme] = useState(localStorage.getItem("theme") || "light"); 

  useEffect(() => { 
    localStorage.setItem("theme", theme); 
  }, [theme]); 

  const values = { 
    theme, 
    setTheme, 
  }; 

  return ( 
    &lt;ThemeContext.Provider value={values}>{children}&lt;/ThemeContext.Provider> 
  ); 
}; 

export const useTheme = () => useContext(ThemeContext); // ile işlem tanımlanıp export edildi.
              </pre> 
            </p>
            <p>
              Button.js içinde: <br>
              <pre class="prettyprint ms-0">
import { useTheme } from "../context/ThemeContext"; // ile useTheme import edildi.  

function Button() { 
  const { theme, setTheme } = useTheme(); // ile fonksiyon kullanıldı ve veriler elde edildi. 
  return ( 
    &lt;div> 
      Active Theme: {theme}{" "} 
      &lt;button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}> 
        Click 
      &lt;/button> 
    &lt;/div> 
  ); 
} 

export default Button; 

              </pre>
            </p>
            <p>
              Header ve Container için de aynı işlem tekrarlanır.
            </p>
          </div>
          <div class="row" id="contextOdev">
            <h1>Context Ödev Notları</h1>
            <p>
              Verinin yansıtıldığı kompanent içine veri alınamazsa veya alınması zaman alırsa gösterilmesi için if koşulu ile bir loading ifadesi return edilir. Yoksa kod hata veriyor.
            </p>
          </div>
          <div class="row" id="arayuz">
            <h1>Arayüzün Hazırlanması</h1>
            <p>
              Projenin amacı, bir kullanıcı renk seçtiğinde bu seçimin tüm kullanıcıları anlık etkilemesi.
            </p>
            <p>
              Hocanın daha önceden hazırladığı bir backend dosyası ile çalışacağız.
            </p>
            <p>
              Bu backend <a href="https://socket.io/">socket.io</a> kütüphanesini kullanıyor.
            </p>
            <p>
              Backendde olması gereken paketleri yüklemek için terminal backendde iken terminale: <br>
              <pre class="prettyprint ms-0">
npm i
              </pre> yazılır.
            </p>
            <p>
              Terminale <code>npm start</code> yazılarak backend çalıştırılır.
            </p>
            <p>
              paket yükleme işlemi client için de yapılır.
            </p>
            <p>
              client tarafında Palette adında bir kompanent oluşturularak içine bir input [type="color"] ve bir buton ekledik. Bunu App.js içinde kullandık. App.css ile de stil tanımları atadık.
            </p>
          </div>
          <div class="row" id="connectSocketServer">
            <h1>Socket Server'a Bağlanmak</h1>
            <p>
              Client tarafını server'a bağlamak için socket.io-client kullanılır. Terminale: <br>
              <pre class="prettyprint ms-0">
npm install socket.io-client
              </pre>
            </p>
            <p>
              src/socketApi.js dosyası oluşturuldu. içine: <br>
              <pre class="prettyprint ms-0">
import io from "socket.io-client"; 

let socket; 

export const init = () => { // bizim socket server bağlantı fonksiyonumuz. 
    console.log("Sunucuya bağlanılıyor...") 
    socket = io('http://localhost:3001', { // backend tarafında belirlenen server ile bağlantı sağlar. 
        transports: ["websocket"] 
    }) 

    socket.on("connect", () => // bağlantı sağlandığında aşağıdaki fonksiyonu çalıştırır.  
    console.log("Sununucuya bağlandı") 
    ); 
}
              </pre>
            </p>
            <p>
              App.js içinde bu fonksiyon karşılanır ve kullanılır. <br>
              <pre class="prettyprint ms-0">
import { useEffect } from 'react'; 
import './App.css'; 
import Palette from './components/Palette'; 
import { init } from './socketApi'; 

function App() { 
  useEffect(()=>{ 
    init() 
  },[]) 
  return ( 
    &lt;div className="App"> 
      &lt;Palette/> 
    &lt;/div> 
  );
} 

export default App;

              </pre>
            </p>
          </div>
          <div class="row" id="backendVeri">
            <h1>Backend'e Veri İletmek</h1>
            <p>
              Veri iletmek için socketApi.js içine aşağıdaki fonksiyon eklenir: <br>
              <pre class="prettyprint ms-0">
export const send = (color) => { 
  socket.emit("newColor", color) 
}
              </pre>emit metodu clientte isek backende backendde isek cliente veri gönderir. İki parametre alır. Hangi kanal? data ne?. Kanal bilgisi backendden alınır.
            </p>
            <p>
              Bu fonksiyon Palette.js içinde butonda onClick eventinde kullanılır. <br>
              <pre class="prettyprint ms-0">
import React, { useState } from "react"; 
import { send } from "../socketApi"; 

function Palette() { 
  const [color, setColor] = useState('') // renk bilgisinin tutulduğu state.
  return ( 
    &lt;div className="palette"> 
      &lt;input type="color" value={color} onChange={(e)=>setColor(e.target.value)} /> 
      &lt;button onClick={()=>send(color)}>Click&lt;/button> 
    &lt;/div> 
  );
} 

export default Palette;

              </pre>
            </p>
          </div>
          <div class="row" id="KanalAbone">
            <h1>Bir Kanala Abone Olmak</h1>
            <p>
              Socket io üzerinden veriyi bir kanal aracılığı ile alıyoruz. Aldığımız kanalın adı backend tarafında belirtiliyor.
            </p>
            <p>
              Veriyi almak için SocketApi.js ye aşağıdaki fonksiyonu ekliyoruz. <br>
              <pre class="prettyprint ms-0">
export const subscribe = (cb) => { // cb parametresi ile fonksiyon olarak verilen parametre karşılanır.
  socket.on("receive", (color)=>{ 
      console.log(color); 
      cb(color) // ile karşılanan fonksiyona parametre geçilerek çalıştırılır.
  })
} 
              </pre>
            </p>
            <p>
              Tanımlanan fonksiyon App.js içinde uygulanır. <br>
              <pre class="prettyprint ms-0">
import { useEffect, useState } from 'react'; 
import './App.css'; 
import Palette from './components/Palette'; 
import { init, subscribe } from './socketApi'; 

function App() { 
  const [activeColor, setActiveColor] = useState('#969696') // ile kanaldan çekilecek veri için state oluşturulur.  

  useEffect(()=>{ 
    init(); 
    subscribe((color)=>{ // ile ilgili stateti set edecek fonksiyon kanaldan veri çekecek fonksiyona parametre olarak atanır. 
      setActiveColor(color)  // kanaldan gelen veri set edilir. 
    }); 
  },[]) 
  return ( 
    &lt;div className="App" style={{backgroundColor: activeColor}}> // ile kanaldan alınan veri background-color olarak kullanılır. 
      &lt;Palette activeColor={activeColor}/> // ile veri Palette kompanenetine prop olarak gönderilir. 
    &lt;/div> 
  ); 
} 

export default App;

              </pre>
            </p>
            <p>
              background-color değiştiğinde diğer clientlerde inputun da uyumlu olarak değişmesi için prop olarak gönderilen activeColor bilgisi Palette.js içinde input value olarak kullanılır.
            </p>
          </div>
          <div class="row" id="aboutSocket">
            <h1>Socket Io hakkında</h1>
            <p>
              Socket.IO, bir istemci ile bir sunucu arasında düşük gecikmeli, çift yönlü ve olay tabanlı iletişim sağlayan bir kitaplıktır.
            </p>
            <p>
              WebSocket protokolünün üzerine inşa edilmiştir ve HTTP uzun yoklama veya otomatik yeniden bağlanmaya geri dönüş gibi ek garantiler sağlar.
            </p>

            <h2>Socket.IO ne değildir?</h2>
            <p>
              Socket.IO bir WebSocket uygulaması DEĞİLDİR.
            </p>
            <p>
              Socket.IO gerçekten de mümkün olduğunda aktarım için WebSocket kullansa da, her pakete ek meta veriler ekler. Bu nedenle, bir WebSocket istemcisi bir Socket.IO sunucusuna başarılı bir şekilde bağlanamaz ve bir Socket.IO istemcisi de düz bir WebSocket sunucusuna bağlanamaz.
            </p>

            <div class="alert alert-success">
              <h3>Websoket Nedir?</h3>
              <p>
                WebSocket API, bir kullanıcının tarayıcısı ve bir sunucu arasında iki yönlü etkileşimli bir iletişim oturumu açmasını mümkün kılan gelişmiş bir teknolojidir.
              </p>
              <p>
                Websocket durum bilgisi olan bir protokoldür, yani istemci ve sunucu arasındaki bağlantı, taraflardan biri (istemci veya sunucu) tarafından sonlandırılıncaya kadar canlı kalır. İstemci ve sunucudan herhangi biri tarafından bağlantıyı kapattıktan sonra, bağlantı her iki uçtan da sonlandırılır.
              </p>
            </div>
            <p>
              Socket.IO, mobil uygulamalar için bir arka plan hizmetinde kullanılmak üzere tasarlanmamıştır.
            </p>
            <p>
              Socket.IO kitaplığı, sunucuya açık bir TCP bağlantısı tutar ve bu, kullanıcılarınız için yüksek pil tüketimine neden olabilir. Lütfen bu kullanım durumu için FCM gibi özel bir mesajlaşma platformu kullanın.
            </p>
            <p>
              Detay okuma için <a href="https://socket.io/docs/v4/">tıklayınız.</a>
            </p>
          </div>
          <div class="row" id="chatAppGiris">
            <h1>Chat App Giriş</h1>
            <p>
              Uygulamanın çalışması için <a href="https://redis.io/">redis</a> uygulamasını yükleyeceğiz. Bu uygulamada gelen mesajları depolamak ve görüntülemek için kullanacağız.
            </p>
            <p>
              redis kurabilmek için önce <a href="https://learn.microsoft.com/en-us/windows/wsl/install">wsl</a> (The Windows Subsystem for Linux) kurmamız gerekiyor. Alternatif olarak  Microsoft Open Tech‘in 64 bit Windows sürümleri için portlamış olduğu bir Redis sürümü bulunmaktadır. Bunun için <a href="https://github.com/microsoftarchive/redis/releases">tıklayınız</a>
            </p>
            <p>
              redisin çalışması için terminale: <br>
              <pre class="prettyprint ms-0">server-redis</pre> yazıyoruz.
            </p>
            <p>
              <a href="https://mennankose.com/windowsta-redis-kullanimi/">mennankose.com/windowsta-redis-kullanimi</a>
            </p>
            <p class="alert alert-success">
              Redis – Remote Dictionary Server (Uzak Sözlük Sunucusu); ilişkisel olmayan anahtar/değer veri tabanlarını ve önbellekleri uygulamak için yaygın olarak kullanılan açık kaynaklı bir bellek içi veri deposudur.
            </p>
            <p>
              Projenin backend tarafı bize hazır verildi. redisin çalışması için bir takım ortam değişkenleri tanımlıyoruz. Bunun için backend dizinine .env dosyası oluşturduk. <br>
              <pre class="prettyprint ms-0">
REDIS_HOST=localhost // redisin çalışacağı host: bizim için localhost 
REDIS_PORT=6374 // redisin çalışacağı port: 6374 default değerdir. 
REDIS_PASS= // boş bırakıyoruz.
              </pre>
            </p>
            <p>
              backend tarafında gereken node paketlerini yüklemek için terminalde backend açılır ve br:
              <pre class="prettyprint ms-0">npm i</pre> yazılır.
            </p>
            <p>
              Yazılım geliştirirken rahat etmek için projeye nodemon ilave edilebilir. Bu sayede her değişiklikten sonra backend kendini tekrar başlatabilir. terminale: <br>
              <pre class="prettyprint ms-0">npm install --save-dev nodemon</pre>
            </p>
            <p>
              Backend - db - client veri aktarımı için bu projede socket.io kullanılıyor.
            </p>
          </div>
          <div class="row" id="chatContext">
            <h1>Chat Context</h1>
            <p>
              client tarafında src/context/ChatContext.js oluşturuludu ve içinde <br> 
              <pre class="prettyprint ms-0">
import { createContext, useState } from "react"; 

const ChatContext = createContext() 

export const ChatProvider = ({children}) => { 
  const [messages, setMessages] = useState([]) 
  const values = { 
      messages, 
      setMessages 
  } 
  return( 
      &lt;ChatContext.Provider value={values}>{children}&lt;/ChatContext.Provider> 
  )
}  

export default ChatContext;
              </pre>
            </p>
            <p>
              client/src/component içinde ChatForm.js ve ChatList.js taslak komponent olarak oluşturuldu ve Container.js komponentinde kullanıldı. <br>
              <pre class="prettyprint ms-0">
import React from 'react'
import ChatList from './ChatList'
import ChatForm from './ChatForm'

function Container() {
  return (
    &lt;div>
        &lt;ChatList/>
        &lt;ChatForm/>
    &lt;/div>
  )
}

export default Container
              </pre>
            </p>
            <p>
              client/App.js içinde hepsi birleştirildi: <br>
              <pre class="prettyprint ms-0">
import './App.css'; 
import Container from './components/Container';
import {ChatProvider} from './context/ChatContext';

function App() {
  return (
      &lt;ChatProvider>
        &lt;Container/>
      &lt;/ChatProvider>
  );
}

export default App;

              </pre>
            </p>
          </div>
          <div class="row" id="chatBilesenler">
            <h1>Temel Bileşenlerin Geliştirilmesi</h1>
            <p>
              components içinde style.module.css oluşturuldu ve içine hazır olarak verilen css bilgisi eklendi.
            </p>
            <p>
              Mesaj gelmesini simüle etmek için context/textContext.js messages stateine iki tane mesaj default olarak girildi. <br>
              <pre class="prettyprint ms-0">
const [messages, setMessages] = useState([ 
  { message: "Selam" },
  { message: "Naber" },
]);
              </pre>
            </p>
            <p>
              ChatList.js içinde alınan mesaj yerleştirildi.<br>
              <pre class="prettyprint ms-0">
import React from "react"; 
import { useChat } from "../context/ChatContext";
import ChatItem from "./ChatItem";
import styles from "./styles.module.css";

function ChatList() {
  const { messages } = useChat();
  return (
    &lt;div className={styles.chatlist}> 
      &lt;div>
        {messages.map((item, key) => (
          &lt;ChatItem key={key} item={item} />
        ))}
      &lt;/div>
    &lt;/div>
  );
}

export default ChatList;

              </pre>
            </p>
            <p>
              Bu yerleştirme sırasında ChatItem kompanenti oluşturuldu ve içine prop olarak gönderilen veri ile kullanıldı. <br>
              <pre class="prettyprint ms-0">
import React from "react";
import styles from "./styles.module.css";

function ChatItem({ item }) {
  return &lt;div className={styles.chatItem}>{item.message}&lt;/div>;
}

export default ChatItem;

              </pre>
            </p>
            <p>
              Chatform.js içinde formdan gelen veriyi alacak bir state oluşturuldu. Forma her veri girdiğinde sayfanın yenilenmemesi için onSubmit için tanımlanan fonksiyona <code>e.preventDefault();</code> kodu eklendi. <br>
              <pre class="prettyprint ms-0">
import React, { useState } from "react";

import styles from "./styles.module.css";

function ChatForm() {
  const [message, setMessage] = useState("");
  const handleSubmit = (e) => {
    e.preventDefault(); // sayfanın yenilenmesini engeller.
    console.log(message);
    setMessage(""); // mesajı sıfırlayarak submit sonrası formun temizlenmesini sağlar.
  };
  return (
    &lt;div>
      &lt;form onSubmit={handleSubmit}>
        &lt;input
          className={styles.textInput}
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
      &lt;/form>
    &lt;/div>
  );
}

export default ChatForm;

              </pre>
            </p>
            <p>
              Daha görsel olması için stiller düzenlenir.
            </p>
          </div>
          <div class="row" id="backendBaglanti">
            <h1>Backend Bağlantısı</h1>
            <p>
              Backend de bize hazır gelen socket-io serverı ile bağlanabilmemiz için client tarafında src/socketApi.js oluşturuldu ve içine: <br>
              <pre class="prettyprint ms-0">
import io from "socket.io-client"; 

let socket;

export const init = () => {
  console.log("Connecting...");
  socket = io("http://localhost:3000", { // backendimiz neredeyse onun urlsi girilir.
    transports: ["websocket"],
  });

  socket.on("connect", () => console.log("Connected")); // socket connect olduğunda çalışacak fonksiyon.
}; 

              </pre>
            </p>
            <p>
              Yukarıda yazılan init fonksiyonu Container.js içinde karşılanır. <br>
              <pre class="prettyprint ms-0">
import React, { useEffect } from "react"; 
import ChatList from "./ChatList";
import ChatForm from "./ChatForm";

import { init } from "../socketApi";

function Container() {
  useEffect(() => {
    init();
  }, []);
  return (
    &lt;div className="App">
      &lt;ChatList />
      &lt;ChatForm />
    &lt;/div>
  );
}

export default Container;

              </pre>
            </p>
          </div>
          <div class="row" id="sendMessages">
            <h1>Mesajların İletilmesi</h1>
            <p>
              Stil tanımlarını rahat yapmak için ChatContext içinde messages statei için kullandığımız default mesajla silindi.
            </p>
            <p>
              mesajı göndermek için socketApi.js içinde: <br>
              <pre class="prettyprint ms-0">
export const sendMessage = (message) => { 
  if(socket) socket.emit("new-message", message); 
} 
              </pre> socket.emit() işleminde ilk parametre gönderilecek kanalı ikincisi gönderilecek olan veriyi belirtir.
            </p>
            <p>
              ChatForm.js içinde setMessages statei çekilir. Yazılan mesajın messages değişkenine atanması için kullanılır.
              <pre class="prettyprint ms-0">
import React, { useState } from "react"; 

import styles from "./styles.module.css"; 
import { sendMessage } from "../socketApi";
import { useChat } from "../context/ChatContext";

function ChatForm() {
  const { setMessages } = useChat();
  const [message, setMessage] = useState("");

  const handleSubmit = (e) => { 
    e.preventDefault(); 
    console.log(message); 

    setMessages((prevState) => [...prevState, { message, fromMe: true }]); // formdan gelen message değişkenini chatContext teki messages değişkenine ekler. forMe parametresi ile de bizden çıkan mesajları işaretler. 
    sendMessage(message);  // ile mesajı gönderir. formMe message değişkenine dahil olmadığı için beckende gönderilmez.
    setMessage(""); 
  };
  return (
    &lt;div>
      &lt;form onSubmit={handleSubmit}>
        &lt;input
          className={styles.textInput}
          value={message}
          onChange={(e) => setMessage(e.target.value)}
        />
      &lt;/form>
    &lt;/div>
  );
}

export default ChatForm;

              </pre>
            </p>
            <p>
              Alınan mesajları listelemek için socketApi.js içinde aşağıdaki fonksiyon yazıldı: <br>
              <pre class="prettyprint ms-0">
export const subscribeChat = (cb) => { 
  if(!socket) return;

  socket.on("receive-message", (message)=>{ // receive-message kanalı dinlenir. Oradan gelen mesaj bilgisi alınır. 
    console.log("Yeni mesaj var", message); 
    cb(message)  // fonksiyonun kullanıldığı yerde parametre olarak belirtilen fonksiyon cb() olarak çekilir ve içine parametre olarak message değişkeni kullanılır. 
  }) 
}
              </pre>
            </p>
            <p>
              Container.js içinde subscribeChat() fonksiyonu kullanılır. <br>
              <pre class="prettyprint ms-0">
import React, { useEffect } from "react"; 
import ChatList from "./ChatList";
import ChatForm from "./ChatForm";
import { useChat } from "../context/ChatContext";

import { init, subscribeChat } from "../socketApi";

function Container() {
  const { setMessages } = useChat();

  useEffect(() => {
    init();

    subscribeChat((message) => {
      setMessages((prevState) => [...prevState, { message }]);
    }); // subscribeChat() fonksiyonu ile alınan veri messages değişkenine eklenir. Bu verilerde forMe değeri bulunmaz.
  }, []); 
  return (
    &lt;div className="App">
      &lt;ChatList />
      &lt;ChatForm />
    &lt;/div>
  );
}

export default Container;

              </pre>
            </p>
            <p>
              ChatItem.js içinde listeleme yaparken forMe varlığı sorgulanır. forMe varsa ilave className alır. Buna bağlı olarak da stili değişir. Bizim gönderdiklerimizde forMe olur. Dışarıdan gelenlerde olmaz. <br>
              <pre class="prettyprint ms-0">
import React from "react"; 
import styles from "./styles.module.css";

function ChatItem({ item }) {
  return &lt;div className={`${styles.chatItem} ${item.fromMe ? styles.right : ""}`}>{item.message}&lt;/div>;
}

export default ChatItem;

              </pre>
            </p>
          </div>
          <div class="row" id="listMessages">
            <h1>Mesajların Listelenmesi</h1>
            <p>
              SocketApi.js içine listelenmiş mesajları alması için bir fonksiyon eklendi. <br>
              <pre class="prettyprint ms-0">
export const subscribeInitialMessages = (cb) => { 
  if (!socket) return; 

  socket.on("message-list", (messages) => { 
    console.log("Initial", messages); 
    cb(messages); 
  }); 
}; 
              </pre> Mesajların gösterilmesi için kullanılan tekniğin aynısı kullanıldı. Sadece kanal adı değiştirildi. 
            </p>
            <p>
              Gelen veri Container.js içinde karşılandı. <br>
              <pre class="prettyprint ms-0">
import React, { useEffect } from "react"; 
import ChatList from "./ChatList";
import ChatForm from "./ChatForm";
import { useChat } from "../context/ChatContext";

import { init, subscribeChat, subscribeInitialMessages } from "../socketApi";

function Container() {
  const { setMessages } = useChat();

  useEffect(() => {
    init();

    subscribeInitialMessages((messages) => setMessages(messages)) // backend tarafından alınan mesaj bilgisi messages değişkeni olarak atandı.
    subscribeChat((message) => {
      setMessages((prevState) => [...prevState, { message }]);
    });
  }, []);
  return (
    &lt;div className="App">
      &lt;ChatList />
      &lt;ChatForm />
    &lt;/div>
  );
}

export default Container;

              </pre>
            </p>
            <p>
              Geçmiş mesajlar uygulamamız ilk açıldığında messages değişkenine atanıp listeleniyor. Geldiği yere forMe özelliği olmadan gönderildiğinden tüm mesajlar aynı görünüyor. user girişi olmadan bunu değiştirmenin bir yolu yok.
            </p>
          </div>
          <div class="row" id="feedScroll">
            <h1>Feed Scroll</h1>
            <p>
              Bunun için <a href="https://www.npmjs.com/package/react-scrollable-feed">react-scrollable-feed</a> kütüphanesini kullanacağız. 
            </p>
            <p>
              Terminale: <br>
              <pre class="prettyprint ms-0">npm i react-scrollable-feed</pre>
            </p>
            <p>
              Chatlist.js içinde modülü import edip scrollun beslendiği alanı modülle sarmalayacağır. <br>
              <pre class="prettyprint ms-0">
import React from "react"; 
import { useChat } from "../context/ChatContext";
import ChatItem from "./ChatItem";
import styles from "./styles.module.css";
import ScrollableFeed from "react-scrollable-feed"

function ChatList() {
  const { messages } = useChat();
  return (
    &lt;div className={styles.chatlist}>
      &lt;ScrollableFeed>
        {messages.map((item, key) => (
          &lt;ChatItem key={key} item={item} />
        ))}
      &lt;/ScrollableFeed>
    &lt;/div>
  );
}

export default ChatList;

              </pre>
            </p>
          </div>
          <div class="row" id="reactIntl">
            <h1>React Intl - Kurulum</h1>
            <p>
              Lokalization işlemleri yani dil ile alakalı işlemleri gerçekleştirmek.
            </p>
            <p>
              Kullanıcağımız kütüphane <a href="https://formatjs.io/docs/getting-started/installation">React Intl</a> terminale:
              <pre class="prettyprint ms-0">npm i react-intl</pre>
            </p>
            <p>
              App.js içinde import edilir ve kullanılır. <br>
              <pre class="prettyprint ms-0">
import "./App.css";

import { IntlProvider, FormattedMessage, FormattedNumber } from "react-intl"; // ile kullanılacak ksımlar import edilir. 
import { useState } from "react";

const messages = {  // ile kullanılacak veri oluşturulur. 
  "tr-TR": {
    title: "Merhaba Dünya",
    description: "3 yeni mesaj",
  },
  "en-US": {
    title: "Hello World",
    description: "3 new messages"
  }
  
};

function App() {
  const [lang, setLang] = useState("tr-TR")  // ile dil değişimi için state tanımlanır. 
  return ( 
    &lt;div className="App"> 
      &lt;IntlProvider messages={messages[lang]}> // ile react-intl kullanılacak alan kaplanır ve yayınlanacak mesajın verildiği obje messages keyi ile belirtilir. 
        &lt;FormattedMessage id="title" />  // id içinde verilen değer messages objesindeki gösterilmek istenen key değeridir. 
        &lt;p> 
        &lt;FormattedMessage id="description" /> 
        &lt;/p>
        &lt;br /> &lt;br />
        &lt;button onClick={()=>setLang("tr-TR")}>TR&lt;/button>
        &lt;button onClick={()=>setLang("en-US")}>EN&lt;/button>
      &lt;/IntlProvider>
    &lt;/div>
  );
}

export default App;

              </pre>
            </p>

          </div>
          <div class="row" id="defaultLocale">
            <h1>Default Locale</h1>
            <p>
              Açılışta browser dili ile aynı dilin atanmasını ve daha sonra seçilen dilin sayfa yenilendiğinde kalmasını sağlayacağız.
            </p>
            <p>
              navigator arabirimi, kullanıcı aracısının durumunu ve kimliğini temsil eder. Komut dosyalarının onu sorgulamasına ve bazı etkinlikleri yürütmek için kendilerini kaydettirmesine olanak tanır. İleri okuma için <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator">tıklayınız.</a>
            </p>
            <p>
              <pre class="prettyprint ms-0">
import "./App.css"; 

import { IntlProvider, FormattedMessage } from "react-intl";
import { useEffect, useState } from "react";

const messages = {
  "tr-TR": {
    title: "Merhaba Dünya",
    description: "3 yeni mesaj",
  },
  "en-US": {
    title: "Hello World",
    description: "3 new messages",
  },
};

function App() {
  const defaultLocale = localStorage.getItem("lang") || navigator.language; // localStorage içinde lang tanımı varsa onu alır. Yoksa browser default değerini alır. 
  const [lang, setLang] = useState(defaultLocale);

  useEffect(()=>{ 
    localStorage.setItem("lang", lang);
  }, [lang]) // lang değeri değiştiğinde değişen değeri localStorage içine gönderir. 
  return (
    &lt;div className="App">
      &lt;IntlProvider locale={lang} messages={messages[lang]}>
        &lt;FormattedMessage id="title" />
        &lt;p>
          &lt;FormattedMessage id="description" />
        &lt;/p>
        &lt;br /> &lt;br />
        &lt;button onClick={() => setLang("tr-TR")}>TR&lt;/button>
        &lt;button onClick={() => setLang("en-US")}>EN&lt;/button>
      &lt;/IntlProvider>
    &lt;/div>
  );
}

export default App;

              </pre>
            </p>
          </div>
          <div class="row" id="parametreGecmek">
            <h1>Parametre Geçmek</h1>
            <p>
              Kullanılacak veri içine FormattedMessage içinden parametre gönderebiliriz. <br>
              <pre class="prettyprint ms-0">
import "./App.css"; 

import { IntlProvider, FormattedMessage } from "react-intl";
import { useEffect, useState } from "react";

const messages = {
  "tr-TR": {
    title: "Merhaba Dünya",
    description: "{count} yeni mesaj",  // parametrenin alınıp kullanıldığı yer. 
  },
  "en-US": {
    title: "Hello World",
    description: "{count} new messages",  // parametrenin alınıp kullanıldığı yer. 
  },
};

function App() {
  const defaultLocale = localStorage.getItem("lang") || navigator.language;
  console.log(defaultLocale);
  const [lang, setLang] = useState(defaultLocale);

  useEffect(()=>{
    localStorage.setItem("lang", lang);
  }, [lang])
  return (
    &lt;div className="App">
      &lt;IntlProvider locale={lang} messages={messages[lang]}>
        &lt;FormattedMessage id="title" />
        &lt;p>
          &lt;FormattedMessage id="description" values={{count: 5}}/> // Parametrenin gönderildiği yer. 
        &lt;/p>
        &lt;br /> &lt;br />
        &lt;button onClick={() => setLang("tr-TR")}>TR&lt;/button>
        &lt;button onClick={() => setLang("en-US")}>EN&lt;/button>
      &lt;/IntlProvider>
    &lt;/div>
  );
}

export default App;

              </pre>
            </p>
          </div>
          <div class="row" id="nedenTest">
            <h1>Neden Test Yazarız?</h1>
            <p>
              Birden fazla kompanent yazdığımızda ve her birini yazdıktan hemen sonra test ettiğimizde, daha sonra yazdığımız bir kodun daha öncekini bozup bozmadığını bilemeyiz. Bunun için her işlemin sonunda hepsini test etmek gerekir.
            </p>
            <p>
              Bu süreci otomatize etmek için test yazarız.
            </p>
            <p>
              <pre class="prettyprint ms-0">npx create-react-app project</pre> ile yeni bir proje oluşturduğumuzda ilk test dosyamız src/App.test.js olarak hazır gelir. terminale <pre class="prettyprint ms-0">npm test</pre> yazarak çalıştırılır.
            </p>
            <p>
              Test dosyaları KompanentAdi.test.js olarak yazılır.
            </p>
            <p>
              App.test.js <br>
              <pre class="prettyprint ms-0">
import { render, screen } from '@testing-library/react'; 
import App from './App'; //  test edilecek kompanent import edildi. 

test('renders learn react link', () => {
  render(&lt;App />); // App kompanentini render ederken
  const linkElement = screen.getByText(/learn react/i); // Ekranda "learn react" yazısını arar. ve linkElement değişkenine atar.
  expect(linkElement).toBeInTheDocument(); // linkElement değişkenini döküman içinde olma durumunu değerlendirir. True dönerse test olumlu döner.
});

              </pre>
            </p>
          </div>
          <div class="row" id="reactTestingLibrary1">
            <h1>React Testing Library Örnek 1</h1>
            <p>
              src/components/Counter dosyası içinde:
            </p>
            <p>
              index.js: <br>
              <pre class="prettyprint ms-0">
import React, { useState } from "react"; 

function Counter() { 
  const [count, setCount] = useState(0);
  return (
    &lt;div>
      &lt;h1>{count}&lt;/h1>
      &lt;button onClick={() => setCount(count + 1)}>Increase&lt;/button>
      &lt;button onClick={() => setCount(count - 1)}>Decrease&lt;/button>
    &lt;/div>
  );
  }
  
export default Counter;

              </pre><br>
              ile test edilecek kompanent yazıldı ve App.js içinde kullanıldı.
            </p>
            <p>
              Aynı klasör içide Counter.test.js: <br>
              <pre class="prettyprint ms-0">
import { render, screen } from "@testing-library/react"; //  "render" kompanent render eder. "screen" DOM üzerindeki nesneyi yakalar. 

import userEvent from "@testing-library/user-event"; 
import { act } from "react-dom/test-utils"; 
import Counter from ".";

describe("Counter Test", ()=>{  // Her testte ortak olan işlemler için testler bu yapı içine alınır. 

    let increaseBtn, decreaseBtn, count // ile ortak kullanılacak değişkenler tanımlanır. 
    
    beforeEach(()=>{  //  Test ifadesi başlamadan önce gereken işlemler burada yazılabilir. Her testten önce çalışır. 
        render(<Counter/>);  //  ile counter render edildi 
    
        count = screen.getByText("0");
        increaseBtn = screen.getByText("Increase");  //  ile içinde "Increase" yazan kompanent bulundu 
        decreaseBtn = screen.getByText("Decrease");  //  ile içinde "Decrease" yazan kompanent bulundu. 
        console.log("her testten önce çalışırım");

    })

    beforeAll(()=>{  //  Bu ifade beforeEach den farklı olarak her testten önce tekrar çalışma için değil test sırasında testlerden önce bir kere çalışma için kullanılır. 
        console.log("en başta bir kere çalışırım"); 
    }) 

    afterEach(()=>{ 
        console.log("Her testten sonra çalışırım"); 
    }) 

    afterAll(()=>{
        console.log("en sonda bir kere çalışırım");
    })

    it('increase btn', ()=>{  //  test satırı "it" (veya "test") ile başlar. hemen arkasından açıklaması gelir. sonra callback ile test yazılır. 
    
        act(()=>{
            userEvent.click(increaseBtn);  //  ile butona tıklandı 
        })
        expect(count).toHaveTextContent("1") //  ile butona tıklandığında beklenen aksiyon yazıldı. 
    }) 
    it('decrease btn', ()=>{
        
        act(()=>{
            userEvent.click(decreaseBtn);
        })
        expect(count).toHaveTextContent("-1")
    })
})

              </pre>
            </p>
          </div>
          <div class="row" id="reactTestingLibrary2">
            <h1>React Testing Library Örnek 2</h1>
            <p>
              src/components/Todo dosyası içinde: 
            </p>
            <p>
              index.js: <br>
              <pre class="prettyprint ms-0">
import React, { useState } from 'react' 
const defaultItems = [ // ile default değerler atanır.
    {
        name: "Item A",
    },
    {
        name: "Item B",
    },
    {
        name: "Item C",
    },
]

function Todo() {
    const [text, setText] = useState("");
    const [items, setItems] = useState(defaultItems);
    const addItem = () => {
        setItems((prevState) => [...prevState, {name: text}]);
        setText("")
    }
  return (
    &lt;div>
        &lt;label htmlFor='input'>Input&lt;/label>
        &lt;input id="input" value={text} onChange={(e)=> setText(e.target.value)}/>
        &lt;button onClick={addItem}>Add&lt;/button>
        &lt;br />&lt;br />
        {
            items.map((item, key)=>(
                &lt;div key={key}>{item.name}&lt;/div>
            ))
        }
    &lt;/div>
  )
}

export default Todo
              </pre>
            </p>
            <p>
              Todo.test.js içinde: <br>
              <pre class="prettyprint ms-0">
import { render, screen } from "@testing-library/react"; 
import userEvent from "@testing-library/user-event";
import { act } from "react-dom/test-utils";

import Todo from "."; //  ile test edilecek kompanent import edilir.

describe("Todo testleri", () => { 
  let button, input;
  beforeEach(() => {
    render(&lt;Todo />);
    button = screen.getByText("Add");
    input = screen.getByLabelText("Input");
  }); //  ile testlerde gerekecek tanımlar hazırlanır. 

  test("Varsyılanları listele", () => {
    const items = screen.getAllByText(/Item/i); // Ekranda Item ile başlayan metinleri bul. 

    expect(items.length).toEqual(3); //  Sorgula: bulunan itemlerden oluşan array 3 elemanlı mı?  
  });

  test("input ve buton dökümanda bulunmalı", () => {
    expect(button).toBeInTheDocument();
    expect(input).toBeInTheDocument(); //  button ve input değişkenine tanımlanmış elemanlar sayfada var mı? 
  });

  test("inputa string girilip butona basılınca listeye eklemeli.",()=>{
    const name = "Murat" //  forma yazılacak değişken 
    act(()=>{
        userEvent.type(input, name);  //  input değişkenine atadığımız html varlığına name değişkenini yaz. 
        userEvent.click(button); //  ile butona tıkla 
    })

    expect(screen.getByText(name)).toBeInTheDocument() //  Sorgula: name değişkeni dökümanda var mı? 
  })
});

              </pre>
            </p>
          </div>
          <div class="row" id="createReactLibrary">
            <h1>create-react-library</h1>
            <p>
              Yaptığımız kütüphaneyi npmjs.com üzerinden paylaşmayı öğreneceğiz.
            </p>
            <p>
              Yazacağımız kütüphanenin adı unique olmak zorunda. Bunu da <a href="https://remarkablemark.org/npm-package-name-checker/">buradan</a> kontrol edebiliriz.
            </p>
            <p>
              terminale:
              <pre class="prettyprint ms-0">npx create-react-library</pre> 
              <p>veya</p>
              <pre class="prettyprint ms-0">npm install -g create-react-library</pre> ile global kurulur ve <br>
              <pre class="prettyprint ms-0">create-react-library</pre> ile çalıştırılır.
            </p>
            <p>
              Gelen form terminalde doldurulur.
            </p>
            <p>
              Kurulan yapının içinde iki adet çalıştırılacak kompanent var. Önce terminalden kök dizine girilip <code>npm start</code> yapılır. Sonra terminalden example klasörüne girilip <code>npm start</code> yapılır.
            </p>
            <p>
              node.js güncel versiyonda example içinde verilen komut kata veriyor. Bunu önlemek için example/package.json script alanında start keyinin valuesinin sonundaki start kelimesi <q>--openssl-legacy-provider start</q> ile değiştirilir.
            </p>
            <p>
              Oluşturduğumuz kütüphanenin denemesi example içinde import edilmiş olarak verilir. Biz de bunların üzerinde çalışacağız.
            </p>
          </div>
          <div class="row" id="publishislemleri">
            <h1>Publish İşlemleri</h1>
            <p>
              npmjs.org üzerinden paylaşmak için bir önceki konuda oluşturduğumuz yapı üzerinden bir kompanent oluşturacağız.
            </p>
            <p>
              src/index.js içinde: <br>
              <pre class="prettyprint ms-0">
import React from 'react' 
import styles from './styles.module.css'

export const ExampleComponent = ({ text }) => {
  return &lt;div className={styles.test}>Example Component: {text}&lt;/div>
} // bu hazır gelen modül

export const Button = (props) => {
  return(
    &lt;button {...props}>{props.text}&lt;/button> {/* bu şekilde yazıldığında gönderilen tüm propları alır.  */}
  ) 
}
              </pre>
            </p>
            <p>
              example/src/App.js içinde: <br>
              <pre class="prettyprint ms-0">
import React from 'react'

import { ExampleComponent, Button } from 'ravenui-test'
import 'ravenui-test/dist/index.css'

const App = () => {
  return (
  &lt;>
    &lt;ExampleComponent text="Create React Library Example 😄" /> // hazır gelen modül.
    &lt;Button text="Click"/> // html button etiketinin alacağı özellikleri burada veremeyiz çünkü burada sadece tanımladığımız modülü kullanıyoruz. Bu özellikleri modül tanımı kısmında girerek kullanabiliriz veya prop olarak gönderip kullanabiliriz.
  &lt;/>
  )
}

export default App

              </pre>
            </p>
            <p>
              Yayınlamak için npmjs.org a üye oluyoruz.
            </p>
            <p>
              Terminale <br>
              <pre class="prettyprint ms-0">
npm login
              </pre> yazılıp gelen form doldurulur.
            </p>
            <p>
              terminale: <br>
              <pre class="prettyprint ms-0">
npm publish
              </pre> yazılarak oluşturduğumuz kütüphane upload edilir.
            </p>
            <p>
              Aynı isimde kütüphane var hatası alınırsa package.json dosyasından isim değiştirilebilir.
            </p>
          </div>
          <div class="row" id="sematicVersiyonlama">
            <h1>Semantic Versiyonlama</h1>
            <p>
              Versiyon numarası package.json üzerinden verilir. nokta ile ayrılan 3 sayıdan oluşur. <q>3.0.2</q> gibi.
            </p>
            <p>
              En sondaki sayı ufak hataları, patch işlemlerini vs yaptığımızda değiştirilir.
            </p>
            <p>
              Ortadaki sayı minör değişikliklerde arttırılır.
            </p>
            <p>
              En baştaki sayı major değişiklikleri gösterir. Sistemin tamamen değiştiğini gösterir.
            </p>
            <p>
              Versiyon değişikliği için terminale: <br>
              <pre class="prettyprint ms-0">
npm version patch --f
              </pre> yazılarak sondaki sayı 1 arttırılır. <br>
              <pre class="prettyprint ms-0">
npm version minor --f
              </pre> yazılarak ortadaki sayı 1 arttırılır. <br>
              <pre class="prettyprint ms-0">
npm version major --f
              </pre> yazılarak baştaki sayı 1 arttırılır. <br>
            </p>
            <p>
              soldaki sayı arttığında sağdakiler sıfırlanır.
            </p>
            <p>
              terminale <br>
              <pre class="prettyprint ms-0">
npm publish 
              </pre> ile güncelleme gönderilir.
            </p>
            <p>
              Kütüphanemizi kullanan kullanıcının kendi versiyonunu güncellemesi için terminale: <br>
              <pre class="prettyprint ms-0">
npm upgrade ravenui
              </pre> yazılır.
            </p>
            <p>
              Kullanıcının sistemi güncellemeyi kabul etmezse <br>
              <pre class="prettyprint ms-0">
npm upgrade ravenui --force
              </pre> yazılır.
            </p>
          </div>
          <div class="row" id="surgeSh">
            <h1>Surge.sh</h1>
            <p>
              Demo gösterimleri için ideal. Yetenekleri sınırlı
            </p>
            <p>
              Önce surge.sh bilgisayara global olarak kurulur. Bunun için terminale: <br>
              <pre class="prettyprint ms-0">
npm install --global surge
              </pre>
              <p>
                Sonra deploy etmek istediğimiz dizine gelip terminale: <br>
                <pre class="prettyprint ms-0">
surge
                </pre> yazılır.
              </p>
              <p>
                Gelen ekrana email ve şifre girilir ve form doldurulur.
              </p>
              <p>
                react projesi deploy edilmeden önce build yapılır. Bunun için terminale: <br> 
                <pre class="prettyprint ms-0">
npm run build
                </pre> yazılır. <br>
                Daha sonra bu dizine girilip <code>surge</code> komutu çalıştırılır.
              </p>
              <p>
                Her güncelleme sonrası build işlemi tekrar yapılır ve ardından deploy edilir. Deploy sırasında yeni bir domain önerebilir. Biz eski domaini elle girerek mevcut siteyi güncelleyebiliriz.
              </p>
              <p>
                Yukarıdaki işlemi her seferinde tekrar yapmaktansa package.json dosyasına kısa yol girebiliriz. Bunun için package.json>scripts alanına: <br>
                <pre class="prettyprint ms-0">
"deploy": "npm run build && surge"
                </pre> eklenir. ve gerektiğinde <pre class="prettyprint ms-0">npm run deploy</pre> ile çalıştırılır.
              </p>
            </p>
          </div>
          <div class="row" id="netlify">
            <h1>Netlify</h1>
            <p>
              Daha kapsamlı. Küçük ve orat ölçekli projeler için ideal.
            </p>
            <p>
              Kayıt ol. giriş yap.
            </p>
            <p>
              github üzerindeki repodan projeyi çekiyor.
            </p>
            <p>
              React projesini yükleyebilmek için build işlemini netlify kendisi yapıyor.</b>
            </p>
            <p>
              sitede <q>add new site</q> yi tıklayarak ve oradaki yönergeleri takip ederek projemizi deploy edebiliriz.
            </p>
            <p>
              deploy sırasında aldığım bir hata ve çözümü için <a href="https://stackoverflow.com/questions/64468843/netlify-deployment-failed-during-stage-building-site-build-script-returned-n">tıklayınız</a>
            </p>

            <p>
              Bağlı olduğu git reposu güncellendiğinde netlify deploy işlemini tekrar yapar.
            </p>
            <p>
              netlfy üzerinde kullanılan react projelerinde anasayfa dışında sayfa yenilenirse sayfa hata verir. Bu hata sayfa linklerinin backend üzerinde değil client üzerinde var olmasıdır. Bunu düzeltmek için projenin public dizininde <b>_redirects</b> dosyası oluşturulur ve içine <br>
              <pre class="prettyprint ms-0">
/*    /index.html   200
              </pre> yazılır. Bu sayede tüm yönlendirmeler netlify tarafından algılanır.
            </p>

            <h2>Netlify'da Neler Yapabiliriz?</h2>

            <h3>Custom domain</h3>
            <p>site setting>domain management>add custom domain</p>

            <h3>Deploydan önce test kodunu çalıştırmak</h3>
            <p>
              site settings>Build & deploy> Continuous Deployment kısmındaki build command satırını "npm test && npm run build" olarak güncellersek önce testi çalıştırır. Testi geçerse deploy yapar
            </p>

            <h3>Deploy Notifications</h3>
            <p>
              site settings>Build & deploy>Deploy notifications
            </p>

            <h3>Ortam Değişkenini Netlify'de Kullanmak</h3>

            <p>
              Önce ortam değişkeni oluşturuyoruz. bunun için kök dizinde .env dosyası oluşturduk. İçine: <br>
              <pre class="prettyprint ms-0">
REACT_APP_API_ENDPOINT=https://api.openweathermap.org
              </pre> "REACT_APP" muhakkak yazmalı. 
            </p>
            <p>
              Bu şekilde oluşturulan ortam değişkeni proje içinde istenildiği yerde: <br>
              <pre class="prettyprint ms-0">
process.env.REACT_APP_API_ENDPOINT
              </pre> olarak kullanılır.
            </p>
            <p>
              deploy edildiğinde ortam değişkenlerini github a gönderilmez (.gitignore). Bu nedenle Netlify okuyamaz. Bu nedenle bu değişkenleri biz ekleriz.
            </p>
            <p>
              site settings>Build & deploy>Enviroment kısmında ortam değişkenleri eklenir ve proje tetrar deloy edilir.
            </p>

            <h3>Önceki Deployları Görmek</h3>
            <p>
              Deploys ekranında tıklayıp açtığımız deployda permalink veya preview butonu ile daha önceki deploy versiyonlarını görebiliriz.
            </p>
          </div>
          <div class="row" id="awsEc2Deploy">
            <h1>AWS EC2 Üzerine Deploy İşlemleri</h1>
            <p>
              AWS ye üye ol ve giriş yap. Arama ekranına ec2 yaz. Launch instance butonuna bas. Gelen listeden ubuntu server seç. free tier olanı seç.
            </p>
            <p>
              Network setting içinde Create security group kısmında ssh protokolüne bir de http ve https ekle. Her üçü için de "Source type: anywhere" seçilir. 
            </p>
            <p>
              Launch butonuna basılır. Gelen ekranda key-pair oluşturulup bilgisayara indirilir. Bu dosya bizim daha sonra oluşturduğumuz sanal makinaya ulaşmamızı sağlayacak.
            </p>
            <p>
              Instances içinden yeni sanal makinamzı bulup public IP address kopyalanır. Sonra key pairsin olduğu klasörde terminale: <br>
              <pre class="prettyprint ms-0">
ssh -i react-app.pem ubuntu@13.53.146.5
              </pre> yazılır ve gelen soruya <b>yes</b> yazılır.
            </p>
            <p>
              Bu işlem sırasında 
              <q>
                Warning: Permanently added "3.127. 945.215" (ECDSA) to the list of known hosts. <br>
                ubuntu@3.127.145.215: Permission denied (publickey).
              </q> <br>
              hatası alırsak terminale: <br>
              <pre class="prettyprint ms-0">
chmod 400 react-app.pem
              </pre> yazılarak dosyaya izin verilmiş olunur.
            </p> 
            <p>
              terminalde <pre class="prettyprint ms-0">ubuntu@ip-172-31-4-204:</pre> yazıyorsa oluşturduğumuz sanal makinaya bağlandığımızı gösterir.
            </p>
            <p>
              terminale <br>
              <pre class="prettyprint ms-0">
sudo apt-get update
              </pre> ile ubuntu paketleri güncellenir.
            </p>
            <p>
              node.js kurmak için terminale: <br>
              <pre class="prettyprint ms-0">
curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - &&\
sudo apt-get install -y nodejs
              </pre> komutunu yazdım. <br>
              Bu komutları node.js dökümantasyonundan bulduk. İhtiyaca uygun olanı oradan sağlayabiliriz.
            </p>
            <p>
              terminale: <br>
              <pre class="prettyprint ms-0">
sudo apg-get install ngnix
              </pre> yazarız. Bu aşamada public IP tarayıcıya yazılırsa bizi <q>Welcome to nginx!</q> sayfası karşılar.
            </p>
            <p>
              wiki: "Nginx; yüksek eş zamanlı çalışma kabiliyeti, yüksek performans ve düşük hafıza kullanımına odaklanılarak tasarlanmış bir Web sunucusudur. Aynı zamanda ters vekil sunucusu, yük dengeleyici ve HTTP ön belleği olarak da kullanılabilir."
            </p>
            <p>
              projeyi yüklemek için terminale: <br>
              <pre class="prettyprint ms-0">
git clone &lt;proje adresi>
              </pre>
            </p>
            <p>
              Klonlanma tamamlandıktan sonra terminale: <br>
              <pre class="prettyprint ms-0">
dir // yazarak mevcut dosya görüntülenir.
cd &lt;dosya_adı> // yazılarak içine girilir.
npm i // ile gerekli paketler kurulur.
              </pre> 
            </p>
            <p>
              <pre class="prettyprint ms-0">
npm run build
              </pre> ile build oluşturulur.
            </p>
            <p>
              terminale: <br>
              <pre class="prettyprint ms-0">
sudo vi /etc/nginx/sites-available/default
</pre> yazarak nginx ayar sayfası açıldı. <br>
sayfanın root kısmına build'imizin adresini yazıyoruz. <br>
<pre class="prettyprint ms-0">
root /home/ubuntu/weather2/build;
              </pre>
            </p>
            <p>
              <pre class="prettyprint ms-0">
service nginx reload
              </pre> yazılarak nginx terkrar başlatılır.
            </p>
            <p>
              Ortam değişkenlerini de servere yüklemek için terminale: <br>
              <pre class="prettyprint ms-0">
vi .env
              </pre> ile env dosyası oluşturulur. içine <br>
              <pre class="prettyprint ms-0">
REACT_APP_API_ENDPOINT=https://api.openweathermap.org
              </pre> yazıp kaydedip kapatıyoruz (esc -> :wq)
            </p>
            <p>
              tekrar build oluşturuyoruz ve nginx terkrar başlatılır
            </p>
            <p>
              daha önce deploy ettiğimizde sayfa değiştirip yenile yaptığımızda hata alıyorduk. Bu hatayı almamak için: <br>
              <pre class="prettyprint ms-0">
sudo vi /etc/nginx/sites-available/default
              </pre> içindeki <br>
              <pre class="prettyprint ms-0">
try_files $uri $uri/ =404;
              </pre> kodunu <br>
              <pre class="prettyprint ms-0">
try_files $uri $uri/ =index.html;
              </pre> olarak güncellenir ve nginx tekrar başlatılır
            </p>
            <p>
              git reposu güncellendiğinde güncel hali almak için terminale: <br>
              <pre class="prettyprint ms-0">
sudo git pull
              </pre> sonra <br>
              <pre class="prettyprint ms-0">
npm run build
              </pre> ile build oluşturulur.
            </p>
          </div>
          <div class="row" id="tanitim">
            <h1>Uygulama Tanıtımı</h1>
            <p>
              Ürünlerin listelendiği ve sipariş edildiği bir e-ticaret sitesi taslağı yapacağız.
            </p>
            <p>
              Giriş yapılacak, sepete ürün eklenecek ve satın alınacak.
            </p>
            <p>
              Ürünün detay sayfası var.
            </p>
            <p>
              Listede aşağı inildikçe daha fazla seçenek açılacak.
            </p>
            <p>
              Sipariş verince admin tarafına düşecek ve orada yönetilecek.
            </p>
            <p>
              Kullanılacak teknoloji: React Router, React Query, Context, JWT (auth), Chakra (UI), Ant Design (UI), Formik, mongoDB, redis 
            </p>
          </div>
          <div class="row" id="backendeGenelBakis">
            <h1>Backend'e Genel Bakış</h1>
            <p>
              Backend hazır verildi. Terminalde backend dizinine girilip <br>
              <pre class="prettyprint ms-0">npm i</pre> ile gerekli modülleri kuruldu. <br>
              <pre class="prettyprint ms-0">npm i -D nodemon</pre> ile nodemon kuruldu <br>
              <pre class="prettyprint ms-0">npm dev</pre> ile başlatıldı.
            </p>
            <p>
              Backendin çalışması için mondoDB ve redis yüklü olmalı.
            </p>
            <p>
              redisin çalışması için terminale: <br>
              <pre class="prettyprint ms-0">server-redis</pre> yazıyoruz.
            </p>
            <p>
              src içine .env oluşturup içine: <br>
              <pre class="prettyprint ms-0">MONGO_URI=mongodb://localhost:27017</pre> tanımı girilir.
            </p>
            <p>
              mongoDB içinde test adında bir database oluşturulup orders, users ve products koleksiyonları oluşturulur ve hazır veriler buralara eklenir.
            </p>
            <p>
              Postman kullanılarak backend test edilebilir. Gönderilen işleme nasıl bir geri dönüş sağladığını görebiliyoruz.
            </p>
            <p>
              Login işlemi sırasında bir accessToken ve refreshToken oluşturuluyor. Bu veriler local storage üzerinde tutulabilir ve kullanıcı bir güncelleme yapmak istediğinde auth işlemi için kullanılabilir. accessToken'ın ömrü kısa. Bu ömür bittiğinde refreshToken üzerinden yenilenir. refreshToken da yoksa tekrar login ister. Bu kısmın düzgün çalışması için ortam değişkeni olarak .env dosyasına <br>
              <pre class="prettyprint ms-0">
JWT_SECRET=sdgkMKEVlm3v23kl_n423vGG3b_YVnm234xnv23
JWT_REFRESH_SECRET=rerv1jv15v1CVBnasd23jnv1j3123nvrqwr23
              </pre> eklenir. keyler aynı kalmak koşuluyla value istediğimiz gibi girilebilir.
            </p>
          </div>
          <div class="row" id="chakraUI">
            <h1>Chakra UI Kurulumu</h1>
            <p>
              <pre class="prettyprint ms-0">
npx create-react-app client
              </pre>
            </p>
            <p>
              <pre class="prettyprint ms-0">
npm install react-router-dom
              </pre> ile react router v6 kuruldu ve App.js içinde yerleştirildi.
            </p>
            <p>
            App.js içinde <br>
<pre class="prettyprint ms-0">
import "./App.css" 
import { BrowserRouter as Router, Link, Route, Routes } from "react-router-dom"; 
import Navbar from "./components/Navbar";

function App() {
  return (
    &lt;Router>
      &lt;h1>Welcome&lt;/h1>
      &lt;Navbar/>
      &lt;div id="content">
      &lt;Routes>
        &lt;Route path="/" element={&lt;Home />} />
      &lt;/Routes>
      &lt;/div>
    &lt;/Router>
  );
}

function Home() {
  return &lt;h2>Home&lt;/h2>
}

export default App;

              </pre>
            </p>
            <p>
              App.css içine aşağıdaki tanım girildi: <br>
              <pre class="prettyprint ms-0">
#content{
  padding: 15px;
}
              </pre>
            </p>
            <p>
              src/components/Navbar içine index.js ve styles.module.css dosyası oluşturuldu. <br>
              index.js içine: <br>
              <pre class="prettyprint ms-0">
import styles from "./styles.module.css";
import { Link } from "react-router-dom";

function Navbar() {
  return (
    &lt;div>
      &lt;nav className={styles.nav}>
        &lt;div className={styles.left}>
          &lt;div className="logo">
            &lt;Link to="/">eCommance&lt;/Link>
          &lt;/div>
          &lt;ul className={styles.menu}>
            &lt;li>
              &lt;Link>Products&lt;/Link>
            &lt;/li>
          &lt;/ul>
        &lt;/div>

        &lt;div className="right">right&lt;/div>
      &lt;/nav>
    &lt;/div>
  );
}

export default Navbar;

              </pre> <br>
              styles.module.css içine:
              <pre class="prettyprint ms-0">             
.nav{
  padding: 13px;
  display: flex;
  justify-content: space-between;
  border-bottom: solid 1px #e2e8f0;
  line-height: 2px;
  align-items: center; 
}

.nav .left{
  display: flex;
}

.nav .left .menu{
  display: flex;
  margin-left: 40px;
}

.nav .left .menu li a {
  color: #4a5568;
  text-decoration: none;
  font-size: 1.1rem;
  padding: 3px 16px;
  display: block;
  font-size: 16px;
}

.nav .left .menu li a:hover {
  color: black;
}
              </pre> sitil tanımları girilir.
            </p>
            <p>
              Default stil tanımlarından kurtulmak için <a href="https://meyerweb.com/eric/tools/css/reset/">reset css</a> içindeki tanımlar kök dizinde reset.css dosyasına eklenir. Bu dosya kök dizindeki index.js dosyasına en alttaki stil tanımı olacak şekilde eklenir.
            </p>
            
            <h2>Chakra UI</h2>
            <p>
              Terminale <br>
              <pre class="prettyprint ms-0">
npm i @chakra-ui/react @emotion/react @emotion/styled framer-motion
              </pre>
            </p>
            <p>
              Tüm kompanentleri <pre class="prettyprint ms-0">&lt;ChakraProvider>&lt;/ChakraProvider></pre> ile sarmalıyoruz. Bunu index.js veya App.js üzerinden yapabiliriz.
            </p>
            <p>
              Chakra UI için kullandığımzı yapılar için <a href="https://chakra-ui.com/getting-started">dökümantasyon sayfasını</a> kullanıyoruz.
            </p>
            <p>
              components/Navbar içine buton eklemek için önce butonu import ediyoruz. <br>
              <pre class="prettyprint ms-0">
import { Button, ButtonGroup } from "@chakra-ui/react"; // Sonra bu butonu Link etiketi ile sarmalayıp kullanıyoruz.
&lt;div className={styles.right}>
  &lt;Link to="/singup">
    &lt;Button colorScheme="pink">Register&lt;/Button>
  &lt;/Link>
  &lt;Link to="/singin">
    &lt;Button colorScheme="pink">Login&lt;/Button>
  &lt;/Link>
&lt;/div>
              </pre>
            </p>
            <p>
              Butonların bitişik olmaması için Navbar/styles.module.css dosyasına: <br>
              <pre class="prettyprint ms-0">
.nav .right a:first-child {
  margin-right: 5px;
}
              </pre> eklenir.
            </p>
            <p>
              Singin ve Singup kompanentlerinin şimdilik yerini tutmaları için components/pages/Auth klasörü içinde Singin ve Singup klasöründe index.js oluşturulup örnek kompanentler yapıldı. 
            </p>
            <p>
              Bu kompanentlere yönlendirme yapılması için App.js içinde yönlendirilecek kompanentler import edildi: <br>
              <pre class="prettyprint ms-0">
import Singin from "./pages/Auth/Singin";
import Singup from "./pages/Auth/Singup";
              </pre> <br>
              Routes etiketi içinde yönlendirmeler yapıldı. <br>
              <pre class="prettyprint ms-0">
&lt;Routes>
  &lt;Route path="/" element={&lt;Home />} />
  &lt;Route path="/singin" element={&lt;Singin/>} />
  &lt;Route path="/singup" element={&lt;Singup />} />
&lt;/Routes>
              </pre>  
            </p>
          </div>
          <div class="row" id="productEkrani">
            <h1>Products Ekranının Hazırlanması</h1>
            <p>
              App.js üzerinde Routes altında <pre class="prettyprint ms-0">&lt;Route path="/" element={&lt;Products />} /></pre> yönlendirmesi yapıldı.
            </p>
            <p>
              Components/Navbar içinde <pre class="prettyprint ms-0">&lt;Link to="/">Products&lt;/Link></pre> yönlendirmesi yapıldı.
            </p>
            <p>
              src/pages/Products klasöründe index.js oluşturuldu. İçinde kullanmak için components/Card klasörü içinde index.js oluşturuldu: <br>
              <pre class="prettyprint ms-0">
import { Box, Image, Button } from "@chakra-ui/react";
import { Link } from "react-router-dom";

function Card() {
  return (
    &lt;Box borderWidth="1px" borderRadius="lg" overflow="hidden" p="3"> // Box chakra-ui kompanentidir. Tüm yapı Box ile sarıldı.
      &lt;Link to="#/"> // Yapı link haline getirildi.
        &lt;Image src="https://picsum.photos/400/200" alt="product" />

        &lt;Box p="6">
          &lt;Box d="plex" alignItems="baseline">
            27/03/2023
          &lt;/Box>

          &lt;Box mt="1" fontWeight="semibold" as="h4" lineHeight="tight">
            MacBook Pro
          &lt;/Box>
          &lt;Box>100 TL&lt;/Box>
        &lt;/Box>
      &lt;/Link>

      &lt;Button colorScheme="pink">
        Add to basket
      &lt;/Button>
    &lt;/Box>
  );
}

export default Card;

              </pre> <br>
              Card taslağı Products/index.js içinde (şimdilik) yer tutucu olarak kullanıldı. <br>
              <pre class="prettyprint ms-0">
import { Grid } from "@chakra-ui/react"; 
import Card from "../../components/Card"; 

function Products() {
  return (
    &lt;div>
      &lt;Grid templateColumns="repeat(3, 1fr)" gap={4}> // Grid yapısı chakra-uı kompanentidir. gap boşluk miktarını repaet kaç kolon oduğunu verir. 
        &lt;Card />
        &lt;Card />
        &lt;Card />
        &lt;Card />
        &lt;Card />
      &lt;/Grid>
    &lt;/div>
  );
}

export default Products;

              </pre>
              ve Product App.js içine import edildi.
            </p>
          </div>
          <div class="row" id="reactQuery">
            <h1>React Query</h1>
            <p>
              State yönetim aracı. Dökümantasyon için <a href="https://tanstack.com/query/latest/docs/react/overview">tıklayınız</a>
            </p>
            <p>
              Terminale: <br>
              <pre class="prettyprint ms-0">
npm i @tanstack/react-query
              </pre>
            </p>
            <p>
              src/index.js içinde import edilir ve <br>
              <pre class="prettyprint ms-0">
import React from "react"; 
import ReactDOM from "react-dom/client";
import "./index.css";
import "./reset.css";

<u>import { QueryClient, QueryClientProvider } from "@tanstack/react-query";</u> // ile import edildi

import { ChakraProvider } from "@chakra-ui/react";
import App from "./App";
import reportWebVitals from "./reportWebVitals";

<u>const queryClient = new QueryClient();</u> // ile yeni sorgu istemcisi oluşturulur.  

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  &lt;React.StrictMode>
    &lt;QueryClientProvider client={queryClient}> // ile tüm kompanentleri QueryClientProvider ile sarıyoruz. istemci olarak da yukaarıda oluşturduğumuz sorgu istemcisini gösteriyoruz. 
      &lt;ChakraProvider>
        &lt;App />
      &lt;/ChakraProvider>
    &lt;/QueryClientProvider>
  &lt;/React.StrictMode>
);
              </pre>
            </p>
            <p>
              src/pages/Products/index.js içinde veriyi çekip map fonksiyonu ile kullanıyoruz. <br>
              <pre class="prettyprint ms-0">
import { Grid } from "@chakra-ui/react";
import { useQuery } from "@tanstack/react-query"; // ile react query içinden ihtiyaç duyduğumuz kısmı import ettik. 

import { fetchProductList } from "../../api"; // ile fetch işlemini başka bir dosyada yapıp import ettik. 
import Card from "../../components/Card";

function Products() {
  const { isLoading, error, data } = useQuery({
    queryKey: ['products'],  // daha sonra lazım olacak. 
    queryFn: fetchProductList, // fetch işlemi yapılan fonksiyon. Bu kısımda fonksiyonun kendisi de yazılabilirdi. 
  })

  if (isLoading) return 'Loading...' // yükleme devam ediyorsa çalışır. 

  if (error) return 'An error has occurred: ' + error.message // hata varsa çalışır. 
  return (
    &lt;div>
      &lt;Grid templateColumns="repeat(3, 1fr)" gap={4}>
        {
          data.map((item, key) => &lt;Card key={key} item={item}/>) // Card kompanentine prop olarak item gönderildi. 
        }
      &lt;/Grid>
    &lt;/div>
  );
}

export default Products;

              </pre>
            </p>
            <p>
              src/api.js içinde fetch işlemi yapıldı. Bunun için axios kullanıldı. <br>
              terminale: <br>
              <pre class="prettyprint ms-0">
npm i axios
              </pre><br>
              api.js içine: <br>
              <pre class="prettyprint ms-0">
import axios from "axios";
export const fetchProductList = async() =>{
    const {data} = await axios.get("http://localhost:4000/product")

    return data
}
              </pre>
            </p>

            <p>
              Prop olarak Products dosyasından gelen veri Card kompanentinde ilgili yerlere yerleştirildi. Tarih bilgisinin formatını ayarlamak için moment paketi kullanıldı. <br>
              terminale: <br>
              <pre class="prettyprint ms-0">
npm i moment
              </pre><br>
              Card/index.js dosyasına: <br>
              <pre class="prettyprint ms-0">
import { Box, Image, Button } from "@chakra-ui/react";
import moment from "moment";
import { Link } from "react-router-dom";

function Card({item}) {
  return (
    &lt;Box borderWidth="1px" borderRadius="lg" overflow="hidden" p="3">
      &lt;Link to="#/">
        &lt;Image src={item.photos[0]} alt="product" />

        &lt;Box p="6">
          &lt;Box d="plex" alignItems="baseline">
            {moment(item.createdAt).format("DD/MM/YYYY")} // moment ile tarih istenilen formatta yazıldı.
          &lt;/Box>

          &lt;Box mt="1" fontWeight="semibold" as="h4" lineHeight="tight">
            {item.title}
          &lt;/Box>
          &lt;Box>{item.price} TL&lt;/Box>
        &lt;/Box>
      &lt;/Link>

      &lt;Button colorScheme="pink">
        Add to basket
      &lt;/Button>
    &lt;/Box>
  );
}

export default Card;

              </pre>
            </p>
            
          </div>
          <div class="row" id="reactQueryDevTools">
            <h1>React Query Dev Tools</h1>
            <p>
              React Query nin geliştirme aşamasında bize yardımcı olması için verdiği bir geliştirme aracı.
            </p>
            <p>
              Eski sürümlerde React Query içindeymiş. Şimdi haricen yükleniyor. <br>
              terminale <br>
              <pre class="prettyprint ms-0">
npm i @tanstack/react-query-devtools
              </pre>
            </p>
            <p>
              QueryClientProvider yapısını kurduğumuz kısımda (örneğimizde kök dizindeki index.js) QueryClientProvider yapısının kapanış parantezinin hemen üstüne eklenerek çaıştırılır. <br>
              <pre class="prettyprint ms-0">
... 
  &lt;ReactQueryDevtools initialIsOpen={false} />
&lt;/QueryClientProvider>
              </pre>
            </p>
            <p>
              Bunun sonucunda web sayfası sol altta bir logo belirir ve tıklandığında geliştirme aracını açar.
            </p>
            <p>
              pages/Products/index.js içinde Product fonksiyonunda kullandığımız <pre class="prettyprint ms-0">queryKey: ['products']</pre> ifadesi bu geliştirme aracı için gereklidir.
            </p>
          </div>
          <div class="row" id="urunDetay">
            <h1>Ürün Detay Sayfasının Geliştirilmesi</h1>
            <p>
              App.js içinde yönlendirme yapılır: <br>
              <pre class="prettyprint ms-0">
&lt;Route path="/product/:product_id" element={&lt;ProductDetail />} />
              </pre> <br>
              Yönlendirmenin yapıldığı ProductDetail kompanenti import edilir.
            </p>
            <p>
              Product sayfasında kullanılan Card kompanentindeki link düzenlenir: <br>
              <pre class="prettyprint ms-0">
&lt;Link to={`product/${item._id}`}>
              </pre>
            </p>
            <p>
              ProductDetail kompanenti için resim galerisi paketi kuruldu.
            </p>
            <p>
              Terminale: <br>
              <pre class="prettyprint ms-0">
npm i react-image-gallery
              </pre>
            </p>
            <p>
              ProductDetail/index.js içine: <br>
              <pre class="prettyprint ms-0">
import { useQuery } from "@tanstack/react-query";
import { useParams } from "react-router-dom";
import { fetchProduct } from "../../api";
import { Box, Text, Button } from "@chakra-ui/react";
import moment from "moment";
import ImageGallery from 'react-image-gallery';

function ProductDetail() {
  const { product_id } = useParams(); // alınan veri router üzerinde gönderilen ad (product_id) ile alınır.

  const { isLoading, isError, data } = useQuery(["product", product_id], () => 
    fetchProduct(product_id) 
  ); // Products sayfasındaki işlemin farklı yazılmışı.

  if (isLoading) { 
    return &lt;div>Loading...&lt;/div>; 
  }

  if (isError) {
    return &lt;div>Error!&lt;/div>;
  }

  const images = data.photos.map((url) => ({ original: url})) // array olarak verilen veri array içinde object olarak düzenlendi 
  
  return &lt;div>
    &lt;Button colorScheme="pink">
      Add to basket
    &lt;/Button>
    &lt;Text as="h2" fontSize="2xl">
      {data.title}
    &lt;/Text>
    &lt;Text>
      {moment(data.createdAt).format("DD/MM/YYYY")}
    &lt;/Text>
    &lt;p>
      {data.description}
    &lt;/p>

    &lt;Box margin="10">
      &lt;ImageGallery items={images} />
    &lt;/Box>
  &lt;/div>;
}

export default ProductDetail;

              </pre>
            </p>
            <p>
              ImageGallery kompanentinin düzgün çalışması için herhangi index.css içine <pre class="prettyprint ms-0">@import "~react-image-gallery/styles/css/image-gallery.css";</pre> girilir.
            </p>
            <p>
              api.js içindeki fertch işlemleri için client kök dizinindeki .env dosyasına: <pre class="prettyprint ms-0">REACT_APP_BASE_ENDPOINT=http://localhost:4000 </pre> lokal değişkeni tanımlandı.
            </p>
            <p>
              api.js içinde ProductDetail içine kullanılacak fetch işlemi eklendi. <br>
              <pre class="prettyprint ms-0">
export const fetchProduct = async(product_id) =>{ 
  const {data} = await axios.get(`${process.env.REACT_APP_BASE_ENDPOINT}/product/${product_id}`)

  return data
}
              </pre>
            </p>
          </div>
          <div class="row" id="useInfiniteQuery">
            <h1>useInfiniteQuery</h1>
            <p>
              Bu kısımda sayfanın en altına buton koyup daha fazla ürün getirme işlemini yapacağız.
            </p>
            <p>
              api.js üzerindeki fetchProductList fonksiyonu düzenlendi: <br>
              <pre class="prettyprint ms-0">
export const fetchProductList = async ({ pageParam = 1 }) => { 
  const { data } = await axios.get( 
    `${process.env.REACT_APP_BASE_ENDPOINT}/product?page=${pageParam}` 
  );

  return data;
};
              </pre>
            </p>
            <p>
              pages/Products/index.js aşağıdaki gibi tekrar düzenlendi. <br>
              <pre class="prettyprint ms-0">
import { Box, Grid, Flex, Button } from "@chakra-ui/react";
import { useInfiniteQuery } from "@tanstack/react-query";
import React from "react";

import { fetchProductList } from "../../api";
import Card from "../../components/Card";

function Products() {
  const { // Bu kısımdaki tanımlar useInfiniteQuery fonkisyonunda tanımlı. 
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery(["products"], fetchProductList,
    {
    getNextPageParam: (lastGroup, allGroup) => {
      const morePagesExist = lastGroup?.length === 12; // son getirilen grup var mı? eleman sayısı 12 mi? Buradaki 12 sayısı backend tarafında bir sayfada görünecek maksimum ürün sayısına atıftır. 
      if (!morePagesExist) {
        return;
      }

      return allGroup.length + 1; // allGroup.length 1 olarak başlar. morePagesExist true döndüğü her seferinde 1 arttırılır. 
    },
  }
  );

  if (status === "loading") return "Loading...";

  if (status === "error") return "An error has occurred: " + error.message;

  return (
    &lt;div>
      &lt;Grid templateColumns="repeat(3, 1fr)" gap={4}>
        {
          data.pages.map((group, i) => (
            &lt;React.Fragment key={i}>
              {
                group.map((item) => (
                  &lt;Box w="100" key={item._id}>
                    &lt;Card item={item} />
                  &lt;/Box>
                ))
              }
            &lt;/React.Fragment>
          ))
        }

      &lt;/Grid>

      &lt;Flex mt="10" justifyContent="center">
        &lt;Button
          onClick={() => fetchNextPage()}
          isLoading={isFetchingNextPage}
          disabled={!hasNextPage || isFetchingNextPage}
        >
          {isFetchingNextPage
            ? "Loading more..."
            : hasNextPage
            ? "Load More"
            : "Nothing more to load"}
        &lt;/Button>
        &lt;div>{isFetching && !isFetchingNextPage ? "Fetching..." : null}&lt;/div>
      &lt;/Flex>
    &lt;/div>
  );
}

export default Products;

              </pre>
            </p>
            <p>
              Kurulan yapı useInfiniteQuery fonkisyonuna özgüdür. Kalıp olarak kullanıldığından fazla bir açıklama yer almamaktadır.
            </p>
          </div>
          <div class="row" id="userRegister">
            <h1>Kullanıcı Kayıt İşlemleri</h1>
            <p>
              Formik ve yup'u kuracağız. <br>
              <pre class="prettyprint ms-0">
npm i formik yup
              </pre>
            </p>
            <p>
              api.js dosyası içinde register işlemi için gereken fetch işlemi tanımlanır. <br>
              <pre class="prettyprint ms-0">
export const fetchRegister = async (input) => { 
  const { data } = await axios.post(
    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/register`,
    input
  );

  return data;
};
              </pre>
            </p>
            <p>
              src/pages/Auth/Singup/index.js dosyası aşağıdaki şekilde düzenlenir. <br>
              <pre class="prettyprint ms-0">
import React from "react";
import {
  Flex,
  Box,
  Heading,
  FormControl,
  FormLabel,
  Input,
  Button,
  Alert,
} from "@chakra-ui/react";
import { useFormik } from "formik";
import validations from "./validation"; // validation.js içindeki validations tanımı import edilir ve kullanılır. Bu tanımlar aşağıda verildi. 
import { fetchRegister } from "../../../api";  // ile yukarıda tanımlanan fetch işlemi import edildi. 

function Singup() {
  const formik = useFormik({
    initialValues: {
      email: "",
      password: "",
      passwordConfirm: "",
    },
    onSubmit: async (values, bag) => { // values: formdaki datalar, bag: formda yapılabilecek bir takım işlemler (formu resetlemek gibi). biz yeni hata mesajı oluşturmak için kullandık. 
      try {
        const registerResponse = await fetchRegister({
          email: values.email,
          password: values.password,
        }); // passwordComfirm backend tarafında yok. Bunu göndermemek için values'in tamamı değil backend tarafından beklenen kısmı gönderilir.
      } catch (e) {
        bag.setErrors({ general: e.response.data.message === "This e-mail already using." ? "Bu mail zaten kullanılıyor": e.response.data.message });
      }
    },
    validationSchema: validations, // import edilen validasyon tanımları kullanıldı. 
  });
  return (
    &lt;div>
      &lt;Flex align="center" justifyContent="center" width="full">
        &lt;Box pt={10}>
          &lt;Box textAlign="center">
            &lt;Heading>Sing Up&lt;/Heading>
          &lt;/Box>
          &lt;Box my={5}>
            {formik.errors.general && (
              &lt;Alert status="error">{formik.errors.general}&lt;/Alert>
            )}
          &lt;/Box>
          &lt;Box my={5} textAlign="left">
            &lt;form onSubmit={formik.handleSubmit}>
              &lt;FormControl>
                &lt;FormLabel>E-mail&lt;/FormLabel>
                &lt;Input
                  name="email"
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  value={formik.values.email}
                  isInvalid={formik.touched.email && formik.errors.email} // true olduğunda yapı geçersiz demektir ve input farklı renk alır.
                />
                {formik.errors.email && formik.touched.email && (
                  &lt;div>
                    &lt;br />
                    &lt;Alert status="error">{formik.errors.email}&lt;/Alert>
                  &lt;/div>
                )}
              &lt;/FormControl>
              &lt;FormControl mt={4}>
                &lt;FormLabel>Password&lt;/FormLabel>
                &lt;Input
                  name="password"
                  type="password"
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  value={formik.values.password}
                  isInvalid={formik.errors.password && formik.touched.password}
                />
                {formik.errors.password && formik.touched.password && (
                  &lt;div>
                    &lt;br />
                    &lt;Alert status="error">{formik.errors.password}&lt;/Alert>
                  &lt;/div>
                )}
              &lt;/FormControl>
              &lt;FormControl mt={4}>
                &lt;FormLabel>Password Confirm&lt;/FormLabel>
                &lt;Input
                  name="passwordConfirm"
                  type="password"
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  value={formik.values.passwordConfirm}
                  isInvalid={
                    formik.errors.passwordConfirm &&
                    formik.touched.passwordConfirm
                  }
                />
                {formik.errors.passwordConfirm &&
                  formik.touched.passwordConfirm && (
                    &lt;div>
                      &lt;br />
                      &lt;Alert status="error">{formik.errors.passwordConfirm}&lt;/Alert>
                    &lt;/div>
                  )}
              &lt;/FormControl>

              &lt;Button mt={4} width="full" type="submit">
                Sing Up
              &lt;/Button>
            &lt;/form>
          &lt;/Box>
        &lt;/Box>
      &lt;/Flex>
    &lt;/div>
  );
}

export default Singup;

              </pre>
            </p>
            <p>
              Validasyon tanımı için Singup/validation.js içine: <br>
              <pre class="prettyprint ms-0">
import * as yup from "yup";

const validations = yup.object().shape({
  email: yup.string().email("Geçerli bir email girin").required("Zorunlu alan"),
  password: yup
    .string()
    .min(5, "Parolanız en az 5 karakter olmalıdır")
    .required("Zorunlu alan"),
  passwordConfirm: yup
    .string()
    .oneOf([yup.ref("password")], "Parolalar uyuşmuyor")
    .required("Zorunlu alan"),
});

export default validations;

              </pre>
            </p>
            <h2>Giriş Yapıldığı Verisinin Sayfada Kullanılması</h2>
            <p>
              Giriş sırasında bilginin tutulması için src/context/AuthContext.js dosyası oluşturuldu: <br>
              <pre class="prettyprint ms-0">
import { useState, createContext, useEffect, useContext } from "react"; 

const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loggedIn, setLoggedIn] = useState(false);

  const login = (data) => {
    setLoggedIn(true);
    setUser(data.user);
  };

  const values = {
    loggedIn,
    user,
    login,
  };
  return &lt;AuthContext.Provider value={values}>{children}&lt;/AuthContext.Provider>;
};

const useAuth = () => useContext(AuthContext);

export { AuthProvider, useAuth };

              </pre>
            </p>
            <p>
              Kök dizinde AuthProvider import edildi ve &lt;App /> kompanentini sarmak için kullanıldı. <br>
              <pre class="prettyprint ms-0">
import { AuthProvider } from "./contexts/AuthContext";
...
...
  &lt;AuthProvider>
    &lt;App />
  &lt;/AuthProvider>
...
              </pre>
            </p>
            <p>
              Singup/index.js içinde useAuth() fonksiyonu import edildi ve kullanıldı. <br>
              <pre class="prettyprint ms-0">
...
import { useAuth } from "../../../contexts/AuthContext";
...
function Singup() {
  const { login } = useAuth();
  ...
  try {
    const registerResponse = await fetchRegister({
      email: values.email,
      password: values.password,
    });
    login(registerResponse)
    ...
              </pre>
            </p>
            <p>
              Navbar/index.js içinde useAuth() fonksiyonu import edildi ve kullanıldı. <br>
              <pre class="prettyprint ms-0">
import { useAuth } from "../../contexts/AuthContext";
function Navbar() {
  const { loggedIn } = useAuth();
  ...
  &lt;div className={styles.right}>
    {!loggedIn && (
      &lt;>
        &lt;Link to="/singup">
          &lt;Button colorScheme="pink">Register&lt;/Button>
        &lt;/Link>
        &lt;Link to="/singin">
          &lt;Button colorScheme="pink">Login&lt;/Button>
        &lt;/Link>
      &lt;/>
    )}
    {
      loggedIn && (
        &lt;>
        &lt;Link to="/profile">
          &lt;Button>Profile&lt;/Button>
        &lt;/Link>
      &lt;/>
      )
    }

  &lt;/div>
  ...
              </pre>
            </p>

            <h2>Login Durumunun Sayfa Yenilendikten Sonra Korunması</h2>
            <p>
              Bu durum backend tarafında korunur ancak şu anki hali ile client tarafı bu veriyi alamaz. Alması için fetch işlemi yapağız. Bunun için de header ile access-token göndermemiz gerekiyor. Bu işlemi bazı sorgularımızda yapacağız. İşlemi otomatikleştirmek için axios paketinin bir fonksiyonu var. Onu api.js dosyasının baş kısmına giriyoruz. <br>
              <pre class="prettyprint ms-0">
// Add a request interceptor 
axios.interceptors.request.use(
  function (config) {
    // Do something before request is sent
    const { origin } = new URL(config.url);

    const allowedOrigin = [process.env.REACT_APP_BASE_ENDPOINT]; // hangi endpointlere istek yapılırken bu düzenlemenin geçerli olduğunu belirttik.
    const token = localStorage.getItem("access-token")

    if(allowedOrigin.includes(origin)){
      config.headers.authorization = token
    }

    return config;
  },
  function (error) {
    // Do something with request error
    return Promise.reject(error);
  }
);
              </pre> <br>
              Detaylı okuma için <a href="https://axios-http.com/docs/interceptors">tıklayınız.</a>
            </p>
            <p>
              Backendden gelecek profil bilgisi için api.js içinde fetch işlemi yapılır. <br>
              <pre class="prettyprint ms-0">
export const fetchMe = async () => {
  const { data } = await axios.get(
    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/me`
  );

  return data;
};
              </pre>
            </p>
            <p>
              fetch ile gelen veri contexts/AuthContext.js içinde yakalanır ve kullanılır. <br>
              <pre class="prettyprint ms-0">
import { useState, createContext, useEffect, useContext } from "react";
import { fetchMe } from "../api"; //  fetchMe fonksiyonu import edildi. 
import { Flex, Spinner } from "@chakra-ui/react"; //  veri alınana kadar gelen loading kısmı için gereklidir.

const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loggedIn, setLoggedIn] = useState(false);
  const [loading, setLoading] = useState(true); //  başlangıçta true alır. fetchMe fonksiyonu ile veri alnınca false a döner. Veri alınırlen çıkan loading yapısını kullanmayı sağlar. 
  useEffect(() => {
    (async () => { //  işlemlerin asenkron olabilmesi için bir fonksiyonla tanımlanması gerekiyor. Bu fonksiyonun okunur okunmaz çalışması için anonim fonksiyon yapısı kullanıldı. 
      try {
        const me = await fetchMe(); // fetchMe fonksiyonundan veri gelene kadar bekler. 
        setLoggedIn(true);
        setUser(me);
        setLoading(false);
        console.log("me", me);
      } catch (e) {
        setLoading(false);
      }
    })();
  }, []);

  const login = (data) => {
    setLoggedIn(true);
    setUser(data.user);

    localStorage.setItem("access-token", data.accessToken);
    localStorage.setItem("refresh-token", data.refreshToken); //  login işlemi sırasında access-token ve refresh-token ibarelerini localStorage üzerine kaydeder. 
  };

  const values = {
    loggedIn,
    user,
    login,
  };

  if (loading) {  // Loading true iken görülecek olan spiner.
    return (
      &lt;Flex justifyContent="center" alignItems="center" height="100vh">
        &lt;Spinner
          thickness="4px"
          speed="0.65s"
          emptyColor="gray.200"
          size="xl"
          color="red.500"
        />
      &lt;/Flex>
    );
  }

  return &lt;AuthContext.Provider value={values}>{children}&lt;/AuthContext.Provider>;
};

const useAuth = () => useContext(AuthContext);

export { AuthProvider, useAuth };

              </pre>
            </p>
            <p>
              Giriş işlemi olduktan sonra ortaya çıkan Profile butonuna yer tutucu bir kompanent hazırlandı ve App.js üzerinden yönlendirmesi yapıldı.
            </p>
          </div>
          <div class="row" id="userLogout">
            <h1>Çıkış İşlemleri</h1>
            <p>
              api.js içinde logout için fetch işlemi tanımlanır. <br>
              <pre class="prettyprint ms-0">
export const fetchLogout = async () => {
  const { data } = await axios.post(
    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/logout`,
    {
      refresh_token: localStorage.getItem("refresh-token"),
    }
  );

  return data;
};
              </pre>
            </p>
            <p>
              AuthContext.js içinde logout fonksiyonu tanımlanır ve values ile gönderilir. <br>
              <pre class="prettyprint ms-0">
const logout = async(cb) => {
  setLoggedIn(false);
  setUser(null);

  await fetchLogout()
  
  localStorage.removeItem("access-token")
  localStorage.removeItem("refresh-token")

  cb() // parametre olarak alınan cb çalıştırılır. Tanımı logout fonksiyonunun kullanıldığı yerde yapıldı.
}

const values = {
  loggedIn,
  user,
  login,
  logout,
};
              </pre>
            </p>
            <p>
              Profile/index.js içinde logout butonu konuldu. <br>
              <pre class="prettyprint ms-0">
import { useAuth } from "../../contexts/AuthContext";
import { useNavigate } from "react-router-dom";

import { Text, Button } from "@chakra-ui/react";

function Profile() {
  const { user, <u>logout</u> } = useAuth();

  let navigate = useNavigate();  //react-router-dom içinden alınan useNavigate() tanımı değişkene atandı. 
  const handleLogout = async () => {
    logout(() => {
      navigate("../"); // tanımlanan değişken sayfa yönlendirmek için kullanılır.  
    });
  };

  return (
    &lt;div>
      &lt;code>
        &lt;Text fontSize={22}>Profile&lt;/Text>
        {JSON.stringify(user)}
        &lt;br />
        &lt;br />
        &lt;Button colorScheme="pink" variant="solid" onClick={handleLogout}>
          Logout
        &lt;/Button>
      &lt;/code>
    &lt;/div>
  );
}

export default Profile;

              </pre>
            </p>
          </div>
          <div class="row" id="protectedRoutes">
            <h1>Protected Routes</h1>
            <p>
              Derste react-router-dom v5 üzerinden anlatılıyor. v6 için <a href="https://medium.com/@dennisivy/creating-protected-routes-with-react-router-v6-2c4bbaf7bc1c">tıklayın.</a>
            </p>
            <p>
              pages/ProtectedRoute.js dosyası oluşturuldu ve içine <br>
              <pre class="prettyprint ms-0">
import {Navigate, Outlet} from 'react-router-dom'

import { useAuth } from '../contexts/AuthContext'

function ProtectedRoute() {
    const {loggedIn} = useAuth()
  return (
    loggedIn ? &lt;Outlet/> : &lt;Navigate to ='/'/>
  )
}

export default ProtectedRoute
              </pre>
            </p>
            <p>
              ProtectedRoute kompanenti app.js içine import edildi ve Routes>Route olarak kullanıldı. Korunmak istenen link de Outlet olarak yazıldı. <br>
              <pre class="prettyprint ms-0">
&lt;Routes>
  &lt;Route path="/" element={&lt;Products />} />
  &lt;Route path="/product/:product_id" element={&lt;ProductDetail />} />
  &lt;Route path="/singin" element={&lt;Singin />} />
  &lt;Route path="/singup" element={&lt;Singup />} />
  <u>
    &lt;Route element={&lt;ProtectedRoute/>}>
      &lt;Route path="/profile" element={&lt;Profile />} />
    &lt;/Route>
  </u>
&lt;/Routes>
              </pre>
            </p>
          </div>
          <div class="row" id="userLogin">
            <h1>Login İşlemleri</h1>
            <p>
              api.js içinde login işlemi için gereken fetch işlemi tanımlanır. <br>
              <pre class="prettyprint ms-0">
export const fetchLogin = async (input) => {
  const { data } = await axios.post(
    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/login`,
    input
  );

  return data;
};
              </pre>
            </p>
            <p>
              Auth/Singin/index.js dosyası Singup/index.js dosyası referans alınarak oluşturuldu ve  modifiye edildi. <br>
              <pre class="prettyprint ms-0">
import React from "react";
import {
  Flex,
  Box,
  Heading,
  FormControl,
  FormLabel,
  Input,
  Button,
  Alert,
} from "@chakra-ui/react";
import { useFormik } from "formik";
import validations from "./validation";
import { fetchLogin } from "../../../api";
import { useNavigate } from "react-router-dom";

import { useAuth } from "../../../contexts/AuthContext";

function <u>Singin()</u> {
  const { login } = useAuth();

  const navigate = useNavigate();

  const formik = useFormik({
    initialValues: {
      email: "",
      password: "",
    },
    onSubmit: async (values, bag) => {
      console.log(values);
      try {
        const loginResponse = await <u>fetchLogin</u>({
          email: values.email,
          password: values.password,
        });
        login(loginResponse);

        navigate("../profile");
        console.log("res", loginResponse);
      } catch (e) {
        bag.setErrors({
          general:
            <u>e.response.data.message === "email or password not correct"
              ? "email veya parola hatalı"
              : e.response.data.message === "The email address was not found."
              ? "email bulunamadı"
              : e.response.data.message,</u>
        });
      }
    },
    validationSchema: validations,
  });
  return (
    &lt;div>
      &lt;Flex align="center" justifyContent="center" width="full">
        &lt;Box pt={10}>
          &lt;Box textAlign="center">
            &lt;Heading>Sing In&lt;/Heading>
          &lt;/Box>
          &lt;Box my={5}>
            {formik.errors.general && (
              &lt;Alert status="error">{formik.errors.general}&lt;/Alert>
            )}
          &lt;/Box>
          &lt;Box my={5} textAlign="left">
            &lt;form onSubmit={formik.handleSubmit}>
              &lt;FormControl>
                &lt;FormLabel>E-mail&lt;/FormLabel>
                &lt;Input
                  name="email"
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  value={formik.values.email}
                  isInvalid={formik.touched.email && formik.errors.email}
                />
                {formik.errors.email && formik.touched.email && (
                  &lt;div>
                    &lt;br />
                    &lt;Alert status="error">{formik.errors.email}&lt;/Alert>
                  &lt;/div>
                )}
              &lt;/FormControl>
              &lt;FormControl mt={4}>
                &lt;FormLabel>Password&lt;/FormLabel>
                &lt;Input
                  name="password"
                  type="password"
                  onChange={formik.handleChange}
                  onBlur={formik.handleBlur}
                  value={formik.values.password}
                  isInvalid={formik.errors.password && formik.touched.password}
                />
                {formik.errors.password && formik.touched.password && (
                  &lt;div>
                    &lt;br />
                    &lt;Alert status="error">{formik.errors.password}&lt;/Alert>
                  &lt;/div>
                )}
              &lt;/FormControl>

              &lt;Button mt={4} width="full" type="submit">
                <u>Sing In</u>
              &lt;/Button>
            &lt;/form>
          &lt;/Box>
        &lt;/Box>
      &lt;/Flex>
    &lt;/div>
  );
}

export default Singin;

              </pre>
            </p>
          </div>
          <div class="row" id="addToBasket">
            <h1>Sepete Atma İşlemleri</h1>
            <p>
              contexts/BasketContext.js dosyası oluşturuldu ve içine <br>
              <pre class="prettyprint ms-0">
import { useState, createContext, useContext, useEffect } from "react";

const BasketContext = createContext();

const BasketProvider = ({ children }) => {
  const [items, setItems] = useState([]);

  const addToBasket = (data, findBasketItem) => { //  data ile ürün verisi, findBasketItem ile de ürünün sepette olma durumu alınır.
    if (!findBasketItem) {
      return setItems((prev) => [...prev, data]);
    }
    const filtered = items.filter((item) => item._id !== findBasketItem._id);
    setItems(filtered);
  };

  const values = {
    items,
    setItems,
    addToBasket,
  };
  return (
    &lt;BasketContext.Provider value={values}>{children}&lt;/BasketContext.Provider>
  );
};

const useBasket = () => useContext(BasketContext);

export { BasketProvider, useBasket };

              </pre>
            </p>
            <p>
              Bu contexti kullanabilmek için kök dizindeki index.js içindeki App kompanenti BasketProvider ile sarmalanır.
            </p>
            <p>
              Navbar/index.js içinde giriş yapıldıya se sepette ürün varsa Basket adında bir buton görünmesi ve bu butonda sepetteki ürün sayısının da yazılması sağlanır. <br>
              <pre class="prettyprint ms-0">
&lt;div className={styles.right}>
  {!loggedIn && (
    &lt;>
      &lt;Link to="/singup">
        &lt;Button colorScheme="pink">Register&lt;/Button>
      &lt;/Link>
      &lt;Link to="/singin">
        &lt;Button colorScheme="pink">Login&lt;/Button>
      &lt;/Link>
    &lt;/>
  )}
  {loggedIn && (
    &lt;>
    <u>
      {
        items.length > 0 && (
          &lt;Link to="/basket">
            &lt;Button colorScheme="pink" variant="outline">
              Basket ({items.length})
            &lt;/Button>
          &lt;/Link>
        )
      }
    </u>
      &lt;Link to="/profile">
        &lt;Button>Profile&lt;/Button>
      &lt;/Link>
    &lt;/>
  )}
&lt;/div>
              </pre>
            </p>
            <p>
              pages/ProductDetail/index.js dosyasındaki Add to basket butonu için gerekli düzenleme yapıldı. <br>
              <pre class="prettyprint ms-0">
... 
<u>import { useBasket } from "../../contexts/BasketContext";</u>
...
function ProductDetail() {
  const { product_id } = useParams();
  <u>const { addToBasket, items } = useBasket();</u>
  ...
  <u>const findBasketItem = items.find((item) => item._id === product_id);</u>

  return (
    &lt;div>
      <u>
        &lt;Button colorScheme={findBasketItem ? "pink": "green"} onClick={() => addToBasket(data, findBasketItem)}>
        {findBasketItem ? "Remove to basket" : "Add to basket"}
      &lt;/Button>
      </u>
      &lt;Text as="h2" fontSize="2xl">
        ...
              </pre>
            </p>
            <p>
              Product sayfasındaki ürünlerin altındaki Add to basket butonunu aktifleştirmek için ykarıdakine benzer bir işlem uygulanır: <br>
              <pre class="prettyprint ms-0">
import { useBasket } from "../../contexts/BasketContext"; 
...
function Card({ item }) {
  const { addToBasket, items } = useBasket();

  const findBasketItem = items.find(
    (basket_item) => basket_item._id === item._id
  );
  return (
    ...
    &lt;Button
    colorScheme={findBasketItem ? "pink" : "green"}
    variant="solid"
    onClick={() => addToBasket(item, findBasketItem)}
  >
    {findBasketItem ? "Remove from basket" : "Add to basket"}
  &lt;/Button>
  ...
              </pre>
            </p>
            <p>
              Sepete alınan ürünlerin görüntüleneceği ve işlenebileceği Basket sayfası pages/Basket/index.js içinde oluşturulur.
              <pre class="prettyprint ms-0">
import React from "react";
import { useBasket } from "../../contexts/BasketContext";
import { Alert, Box, Button, Image, Text } from "@chakra-ui/react";
import { Link } from "react-router-dom";

function Basket() {
  const { items, removeToBasket } = useBasket(); // burada çağırılan removeToBasket fonksiyonu aşağıda anlatılacak.

  const total = items.reduce((acc, obj) => acc + obj.price, 0); // acc o anki toplam. obj items içindeki nesne. 0 da başlangıç değeri.
  return (
    &lt;Box padding={5}>
      {items.length &lt; 1 && (
        &lt;Alert status="warning">You have not any items in your basket!&lt;/Alert>
      )}
      {items.length > 0 && (
        &lt;>
          &lt;ul style={{listStyleType: "decimal"}}>
            {items.map((item) => (
              &lt;li key={item._id} style={{ marginBottom: 15 }}>
                &lt;Link to={`/product/${item._id}`}>
                  &lt;Text fontSize={18}>
                  {item.title} - {item.price} TL
                  &lt;/Text>
                  &lt;Image
                    htmlWidth={200}
                    src={item.photos[0]}
                    loading="lazy"
                    alt="basket item"
                  />
                &lt;/Link>
                &lt;Button
                  mt={2}
                  size="sm"
                  colorScheme="pink"
                  onClick={() => removeToBasket(item._id)}
                >
                  Remove from basket
                &lt;/Button>
              &lt;/li>
            ))}
          &lt;/ul>
          &lt;Box mt={10}>
            &lt;Text fontSize={22}>Total: {total} TL&lt;/Text>
          &lt;/Box>
        &lt;/>
      )}
    &lt;/Box>
  );
}

export default Basket;

              </pre>
            </p>
            <p>
              contexts/BasketContext.js içinde <q>removeToBasket</q> fonksiyonu tanımlanır ve value olarak gönderilir. <br>
              <pre class="prettyprint ms-0">
const removeToBasket = (item_id) => {
  const filtered = items.filter((item) => item._id !== item_id);
  setItems(filtered);
};
const values = {
  items,
  setItems,
  addToBasket,
  removeToBasket,
};
              </pre>
            </p>
            <p>
              Sayfa yönlendirmesi için app.js Routes içinde <q>ProtectedRoute</q> altına <q>Basket</q> elementi yerleştirilir. <br>
              <pre class="prettyprint ms-0">
&lt;Routes>
  &lt;Route path="/" element={&lt;Products />} />
  &lt;Route path="/product/:product_id" element={&lt;ProductDetail />} />
  &lt;Route path="/singin" element={&lt;Singin />} />
  &lt;Route path="/singup" element={&lt;Singup />} />
  &lt;Route element={&lt;ProtectedRoute />}>
    &lt;Route path="/profile" element={&lt;Profile />} />
    <u>&lt;Route path="/basket" element={&lt;Basket />} /></u>
  &lt;/Route>
  &lt;Route path="*" element={&lt;Error404 />} /> {/* path tanımı yukarıdakilerin hiçbirine uymuyorsa bu kısım devreye girer ve Error404 sayfasına yönlendirir. */}
&lt;/Routes>
              </pre> 
            </p>
            <p>
              <q>Error 404</q> sayfası için pages/Error404/index.js oluşturulur. İçine <br>
              <pre class="prettyprint ms-0">
import React from "react";
import {
  Alert,
  AlertIcon,
  AlertTitle,
  AlertDescription,
} from "@chakra-ui/react";

function Error404() {
  return (
    &lt;div>
      &lt;Alert status="error">
        &lt;AlertIcon />
        &lt;AlertTitle>Error 404&lt;/AlertTitle>
        &lt;AlertDescription>
          This page was not found
        &lt;/AlertDescription>
      &lt;/Alert>
    &lt;/div>
  );
}

export default Error404;

              </pre>
            </p>
          </div>
          <div class="row" id="createOrder">
            <h1>Sipariş Oluşturma İşlemleri</h1>
            <p>
              pages/Basket/index.js içinde bir modal yerleştirildi ve siparişlerin database e gönderilmesinde kullanıldı. <br>
              <pre class="prettyprint ms-0">
import React, { useState } from "react"; <br>
import { useBasket } from "../../contexts/BasketContext";
import {
  Alert,
  Box,
  Button,
  Image,
  Text,
  Modal, 
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  useDisclosure,
  FormControl,
  FormLabel,
  Textarea, // modal ve içindeki bileşenler için gereken parçalar chakraUI üzerinden çekildi. 
} from "@chakra-ui/react";
import { Link } from "react-router-dom";
import { postOrder } from "../../api";  //api.js içinde gereken işlem tanımlandı ve import edildi. İşlem detayı aşağıda. 

function Basket() {
  const [address, setAddress] = useState("");

  const { isOpen, onOpen, onClose } = useDisclosure();
  const initialRef = React.useRef(null);  // Bu iki tanım chakraUI modal tanımında kullanılıyor. 

  const { items, removeToBasket, emptyBasket } = useBasket(); // emptybasket BasketContext içinde, sepeti işlem sonunda boşaltmak için oluşturuldu. Detayı aşağıda. 
  const total = items.reduce((acc, obj) => acc + obj.price, 0);

  const handleSubmitForm = async () => {  // Modal içindeki formu göndermek için tanımlanan fonksiyon. 
    const itemIds = items.map((item) => item._id);

    const input = { //api.js üzerinden database e gönderilecek veri. 
      address,
      items: JSON.stringify(itemIds),
    };

    await postOrder(input);
    emptyBasket();
    onClose();  // modalı işlemin sonunda kapatan fonksiyon. 
  };
  return (
    &lt;Box padding={5}>
      {items.length &lt; 1 && (
        &lt;Alert status="warning">You have not any items in your basket!&lt;/Alert>
      )}
      {items.length > 0 && (
        &lt;>
          &lt;ul style={{ listStyleType: "decimal" }}>
            {items.map((item) => (
              &lt;li key={item._id} style={{ marginBottom: 15 }}>
                &lt;Link to={`/product/${item._id}`}>
                  &lt;Text fontSize={18}>
                    {item.title} - {item.price} TL
                  &lt;/Text>
                  &lt;Image
                    htmlWidth={200}
                    src={item.photos[0]}
                    loading="lazy"
                    alt="basket item"
                  />
                &lt;/Link>
                &lt;Button
                  mt={2}
                  size="sm"
                  colorScheme="pink"
                  onClick={() => removeToBasket(item._id)}
                >
                  Remove from basket
                &lt;/Button>
              &lt;/li>
            ))}
          &lt;/ul>
          &lt;Box mt={10}>
            &lt;Text fontSize={22}>Total: {total} TL&lt;/Text>
          &lt;/Box>

          &lt;Button mt={2} size="sm" colorScheme="green" onClick={onOpen}>
            Order 
          &lt;/Button>  {/* modalı açan buton. */}
          &lt;Modal initialFocusRef={initialRef} isOpen={isOpen} onClose={onClose}> //Modalın başlangıcı 
            &lt;ModalOverlay />
            &lt;ModalContent>
              &lt;ModalHeader>Order&lt;/ModalHeader>
              &lt;ModalCloseButton />
              &lt;ModalBody pb={6}>
                &lt;FormControl>
                  &lt;FormLabel>Address&lt;/FormLabel>
                  &lt;Textarea
                    ref={initialRef}
                    placeholder="Address"
                    value={address}
                    onChange={(e) => setAddress(e.target.value)}
                  />
                &lt;/FormControl>
              &lt;/ModalBody>

              &lt;ModalFooter>
                &lt;Button colorScheme="blue" mr={3} onClick={handleSubmitForm}> // Formu gönderme işlemi yapan buton. 
                  Save
                &lt;/Button>
                &lt;Button onClick={onClose}>Cancel&lt;/Button>
              &lt;/ModalFooter>
            &lt;/ModalContent>
          &lt;/Modal>
        &lt;/>
      )}
    &lt;/Box>
  );
}

export default Basket;

              </pre>
            </p>
            <p>
              api.js içinde gerekli fetch işlemi yapıldı ve import edildi. <br>
              <pre class="prettyprint ms-0">
export const postOrder = async (input) => {
  const { data } = await axios.post(
    `${process.env.REACT_APP_BASE_ENDPOINT}/order`,
    input
  );

  return data;
};
              </pre>
            </p>
            <p>
              BasketContext/index.js içinde emptyBasket fonksiyonu tanımlandı ve value olarak gönderildi. <br>
              <pre class="prettyprint ms-0">
const emptyBasket = () => setItems([]);
              </pre>
            </p>
          </div>
          <div class="row" id="adminRouting">
            <h1>Admin: Routing İşlemleri</h1>
            <p>
              Önce bir kullanıcın rolünü database üzerinden admin yapıyoruz. Hoca dersi react-router-dom v5 üzerinden anlatmış. Biz v6 ya göre düzenledik.
            </p>
            <p>
              Navbar kompanentine kullanıcı admin ise görülecek bir buton yerleştirildi. Navbar/index.js <br>
              <pre class="prettyprint ms-0">
...
return (
  ...
  {loggedIn && (
    <>
    ...

    {
      user?.role === "admin" && (
        &lt;Link to="/admin">
          &lt;Button colorScheme="pink" variant="ghost">Admin&lt;/Button>
        &lt;/Link>
      )
    }
    ...
              </pre>
            </p>
            <p>
              pages/Admin/index.js dosyası oluşturuldu ve içine: <br>
              <pre class="prettyprint ms-0">
import React from "react";
import { Link, Outlet } from "react-router-dom";
import styles from "./styles.module.css";
import { Box } from "@chakra-ui/react";

function Admin() {
  return (
    &lt;div>
      &lt;nav>
        &lt;ul className={styles.adminMenu}>
          &lt;li>
            &lt;Link to="/admin">Home&lt;/Link>
          &lt;/li>
          &lt;li>
            &lt;Link to="/admin/orders">Orders&lt;/Link>
          &lt;/li>
          &lt;li>
            &lt;Link to="/admin/products">Products&lt;/Link>
          &lt;/li>
        &lt;/ul>
      &lt;/nav>

      &lt;Box mt={10}>
        &lt;Outlet />
      &lt;/Box>
    &lt;/div>
  );
}

export default Admin;

              </pre>
            </p>
            <p>
              Admin/styles.module.css içine stil tanımları yapıldı. <br>
              <pre class="prettyprint ms-0">
.adminMenu{
  display: flex;
  padding: 0;
  margin: 0;
}

.adminMenu li{
  padding: 0 10px;
}
              </pre>
            </p>
            <p>
              Admin olmayan kullanıcıların admin alanına ulaşamamalı için link korumalı olarak yazılmalı. Bunun için pages/ProtectedAdmin.js dosyası oluşturuldu. içine:<br>
              <pre class="prettyprint ms-0">
import { Navigate, Outlet } from "react-router-dom";

import { useAuth } from "../contexts/AuthContext";

function ProtectedAdmin() {
  const { loggedIn, user } = useAuth();
  return loggedIn && user.role === "admin" ? &lt;Outlet /> : &lt;Navigate to="/" />;
}

export default ProtectedAdmin;

              </pre>
            </p>
            <p>
              Oluşturulan ProtectedAdmin kompanenti Add.js Routes alanında kullanıldı. <br>
              <pre class="prettyprint ms-0">
&lt;Routes>
  ...
  &lt;Route element={&lt;ProtectedAdmin />}>
    &lt;Route path="/admin" element={&lt;Admin />}>
      &lt;Route path="" element={&lt;Home />} />
      &lt;Route path="orders" element={&lt;Orders />} />
      &lt;Route path="products" element={&lt;AdminProducts />} />
    &lt;/Route>
  &lt;/Route>
  ...
&lt;/Routes>
              </pre>
            </p>
            <p>
              Routes alanında admin pathi içinde de nest yapısı kuruldu. Burası için linkler pages/Admin/index.js içinde verilmişti. Elementlerin <q>Outlet</q> yapısı da aynı sayfada.
            </p>
            <p>
              admin altında yuvalanmış linkler için gereken kompanentler Admin klasöründe oluşturuldu. İçeriği daha sonra düzenlenecek.
            </p>
          </div>
          <div class="row" id="adminOrder">
            <h1>Admin: Order Sayfası</h1>
            <p>
              api.js içinde gerekli fetch fonksiyonu tanımlanır. <br>
              <pre class="prettyprint ms-0">
export const fetchOrders = async () => {
  const { data } = await axios.get(
    `${process.env.REACT_APP_BASE_ENDPOINT}/order`
  );

  return data;
};
              </pre>
            </p>
            <p>
              Alınan veri reactQuery yapısı ve chakraUI tablo görselleri ile pages/Admin/Orders.index.js dosyasında kullanılır. (Order detail kısmını modal olarak ben tasarladım :D )<br>
              <pre class="prettyprint ms-0">
import React, { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import {
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  TableCaption,
  Text,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalHeader,
  ModalFooter,
  ModalBody,
  ModalCloseButton,
  useDisclosure,
  Button,
} from "@chakra-ui/react";

import { fetchOrders } from "../../../api";
import { Link } from "react-router-dom";

function Orders() {
  const [order, setOrder] = useState([]); // modal içinde gönderilecek verinin statei 
  const total = order.reduce((acc, obj) => acc + obj.price, 0); // modal içinde kullanılacak verinin toplama işlemi 
  const { isOpen, onOpen, onClose } = useDisclosure(); // modal için gereken tanımlar. 
  const getDetail = (orderData) => {
    onOpen();
    setOrder(orderData);
  };

  const { isLoading, isError, data, error } = useQuery(
    ["admin:orders"],
    fetchOrders
  );

  if (isLoading) {
    return &lt;div>Loading...&lt;/div>;
  }

  if (isError) {
    return &lt;div>Error {error.message}&lt;/div>;
  }

  console.log("data", data);
  return (
    &lt;div>
      &lt;Text fontSize="2xl" padding={5}>
        Orders
      &lt;/Text>

      &lt;Table variant="simple">
        &lt;TableCaption>Order Page - Total order(s) = {data.length}&lt;/TableCaption>
        &lt;Thead>
          &lt;Tr>
            &lt;Th>User&lt;/Th>
            &lt;Th>Address&lt;/Th>
            &lt;Th isNumeric>Items&lt;/Th>
            &lt;Th>&lt;/Th>
          &lt;/Tr>
        &lt;/Thead>
        &lt;Tbody>
          {data.map((item) => (
            &lt;Tr key={item._id}>
              &lt;Td>{item.user.email}&lt;/Td>
              &lt;Td>{item.adress}&lt;/Td>
              &lt;Td isNumeric>{item.items.length}&lt;/Td>
              &lt;Td>
                &lt;Button onClick={() => getDetail(item.items)}>Detail&lt;/Button>
              &lt;/Td>
            &lt;/Tr>
          ))}
        &lt;/Tbody>
      &lt;/Table>

      &lt;Modal isOpen={isOpen} onClose={onClose}> // Buradan itibaren benim tasarladığım modal başlıyor. 
        &lt;ModalOverlay />
        &lt;ModalContent>
          &lt;ModalHeader>Modal Title&lt;/ModalHeader>
          &lt;ModalCloseButton />
          &lt;ModalBody>
            Order Detail: {order.length} &lt;br />v
            &lt;Table variant="simple">
              &lt;TableCaption>Order Total Price = {total}&lt;/TableCaption>
              &lt;Thead>
                &lt;Tr>
                  &lt;Th>Item&lt;/Th>
                  &lt;Th isNumeric>Price&lt;/Th>
                  &lt;Th>&lt;/Th>
                &lt;/Tr>
              &lt;/Thead>
              &lt;Tbody>
                {order &&
                  order.map((item) => (
                      &lt;Tr key={item._id}>
                        &lt;Td>{item.title}&lt;/Td>
                        &lt;Td>{item.price} TL&lt;/Td>
                        &lt;Td>
                          &lt;Button>
                            &lt;Link to={`../../product/${item._id}`}>
                              item detail
                            &lt;/Link>
                          &lt;/Button>
                        &lt;/Td>
                      &lt;/Tr>
                  ))}
              &lt;/Tbody>
            &lt;/Table>
          &lt;/ModalBody>

          &lt;ModalFooter>
            &lt;Button colorScheme="blue" mr={3} onClick={onClose}>
              Close
            &lt;/Button>
            &lt;Button variant="ghost">Secondary Action&lt;/Button>
          &lt;/ModalFooter>
        &lt;/ModalContent>
      &lt;/Modal>
    &lt;/div>
  );
}

export default Orders;

              </pre>
            </p>
          </div>
          <div class="row" id="adminProducts">
            <h1>Admin: Products Sayfası</h1>
            <p>
              Bu kısımda UI aracı olarak <a href="https://ant.design/">ant design</a> kullanılacak. Terminale: <br>
              <pre class="prettyprint ms-0">
npm install antd
              </pre>
            </p>
            <p>
              Yorumlarda material UI önerilmiş. İncelemekte fayda var.
            </p>
            <p>
              Delete işlemi için gereken fetch işlemi api.js üzerinde tanımlandı. <br>
              <pre class="prettyprint ms-0">
export const deleteProduct = async (product_id) => {
  const { data } = await axios.delete(
    `${process.env.REACT_APP_BASE_ENDPOINT}/product/${product_id}`
  );

  return data;
};
              </pre>
            </p>
            <p>
              Admin/AdminProducts/index.js içinde ant design üzerindeki tablo yapısı ile veriler ve edit - delete butonları tanımlandı. Delete için api.js de yazılan fonksiyon kullanıldı. <br>
              <pre class="prettyprint ms-0">
import { useMemo } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"; // useMutation veri manupilasyonu için kullanılıyor.

import { fetchProductList, deleteProduct } from "../../../api";

import { Link } from "react-router-dom";
import { Text } from "@chakra-ui/react";
import { Table, Popconfirm } from "antd";

function Products() {
  const queryClient = useQueryClient();  // kök dizindeki index.js içindeki queryClient yapısına ulaşmayı sağlar.

  const { isLoading, isError, data, error } = useQuery(
    ["admin:products"],
    fetchProductList
  );

  const deleteMutation = useMutation(deleteProduct, {
    onSuccess: () => queryClient.invalidateQueries("admin:products"), // useQuery kullanırken tanımlanan "admin:products" bileşeninin queryClient içinde verilen tanımdan muaf olması sağlanır.
  });  // ilk parametrede işlem için gereken fetch fonksiyonu, ikinci parametrede options(işlemden önce, sonra yapılacak işlemler, tekrardan refetch yapılacak mı vs) girilir. 

  const columns = useMemo(() => {  // kolonların her seferinde refetch olmaması için useMemo() kullanıldı. 
    return [
      {
        title: "Title",
        dataIndex: "title",
        key: "title",
      },
      {
        title: "Price",
        dataIndex: "price",
        key: "price",
      },
      {
        title: "Created At",
        dataIndex: "createdAt",
        key: "createdAt",
      },
      {
        title: "Action",
        key: "action",
        render: (text, record) => ( // record o satıra denk gelen veriyi temsil eder
          &lt;>
            &lt;Link to={`/admin/products/${record._id}`}>Edit&lt;/Link>

            &lt;Popconfirm  // ant design içindeki popconfirm kullanıldı. 
              title="Are you sure?"
              onConfirm={() => {  // onaylanması durumunda çalışacak fonksiyon. 
                deleteMutation.mutate(record._id, {
                  onSuccess: () => {  // onay işlemini başarılı olması durumunda çalışacak fonksiyon. 
                    console.log("success");
                  },
                });
              }}
              onCancel={() => console.log("iptal edildi")} // işlemi kullanıcının onaylamaması durumunda çalışacak fonksiyon. 
              okText="Yes"
              cancelText="No"
              placement="left" // popconfirm yerleşim şekli. 
            >
              &lt;Link style={{marginLeft: 10}}>Delete&lt;/Link>
            &lt;/Popconfirm>
          &lt;/>
        ),
      },
    ];
  }, []);

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (isError) {
    return <div>Error {error.message}</div>;
  }
  
  return (
    &lt;div>
      &lt;Text fontSize="2xl" p="5">
        Products
      &lt;/Text>
      &lt;Table dataSource={data} columns={columns} rowKey="_id" />; // yukarıda tanımlanan tablonun yerleşimi. Return edilen datayı ve tanımlanan kolon yapısını kullanır. 
    &lt;/div>
  );
}

export default Products;

              </pre>
            </p>
          </div>
          <div class="row" id="adminProductUpdate">
            <h1>Admin: Product Update İşlemleri</h1>
            <p>
              App.js içinde admin/product sayfasındaki edit butonunda verilen bağlantı için routing yapıldı: <br>
              <pre class="prettyprint ms-0">
&lt;Routes> 
  ...
  &lt;Route element={&lt;ProtectedAdmin />}>
    &lt;Route path="/admin" element={&lt;Admin />}>
      ...
      <u>&lt;Route path="products/:product_id" element={&lt;AdminProductDetail />} /></u>
    &lt;/Route>
  &lt;/Route>
  ...
&lt;/Routes>
              </pre>
            </p>
            <p>
              api.js içinde adminProductDetail içindeki düzenlemeyi databasee gönderecek fetch işlemi tanımlandı <br>
              <pre class="prettyprint ms-0">
export const updateProduct = async (input, product_id) => {
  const { data } = await axios.put(
    `${process.env.REACT_APP_BASE_ENDPOINT}/product/${product_id}`,
    input
  );

  return data;
};
              </pre>
            </p>
            <p>
              pages/Admin/AdminProductDetail/index.js içine <br>
              <pre class="prettyprint ms-0">
import React from "react";

import { useParams } from "react-router-dom";
import { fetchProduct, updateProduct } from "../../../api"; //  ürün detayını getiren ve yapılan güncellemeyi databasee iletecek fonksiyonlar import edildi. 
import { useQuery } from "@tanstack/react-query";
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Input,
  Text,
  Textarea,
} from "@chakra-ui/react"; //  Form bileşenlerinin görsel tasarımları için chakra-ui kullanıldı.
import { message } from "antd"; //  form submit edildiğinde çıkan spiner için ant-design kullanıldı. 
import { Formik, FieldArray } from "formik"; //  client tarafında arrayi düzenlemek için FieldArray import edildi. 
import validationSchema from "./validations"; // validasyon işlemleri: aşağıda taımlandı.

function AdminProductDetail() {
  const { product_id } = useParams();
  const { isLoading, isError, data, error } = useQuery(
    ["admin:product", product_id],
    () => fetchProduct(product_id)
  );
  if (isLoading) {
    return &lt;div>Loading...&lt;/div>;
  }

  if (isError) {
    return &lt;div>Error {error.message}&lt;/div>;
  }

  const handleSubmit = async (values, bag) => { //  form tarafında submit için kullanılacak fonksiyon. 
    console.log("submitted");
    message.loading({ content: "Loading...", key: "product_update" });  //  ant-design tarafında çekilen spinner tanımı. 

    try {
      await updateProduct(values, product_id);
      message.success({ // işlemin başarılması durumunda spinner durumunda yapılacak güncelleme
        content: "The product successfully updated.",
        key: "product_update",
        duration: 2,
      });
    } catch (e) {
      message.error({ // işlemin başarısız olma durumunda spinner durumunda yapılan güncelleme
        content: "The product does not updated!",
        key: "product_update",
      });
    }
  };

  return (
    &lt;div>
      &lt;Text fontSize="2xl">Edit&lt;/Text>

      &lt;Formik
        initialValues={{
          title: data.title,
          description: data.description,
          price: data.price,
          photos: data.photos,
        }}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
      >
        {({
          handleSubmit, // formik içinde kullanılan tanımlar.
          errors,
          touched,
          handleChange,
          handleBlur,
          values,
          isSubmitting,
        }) => (
          &lt;>
            &lt;Box>
              &lt;Box my={5} textAlign="left">
                &lt;form onSubmit={handleSubmit}>
                  &lt;FormControl>
                    &lt;FormLabel>Title&lt;/FormLabel>
                    &lt;Input
                      name="title"
                      onChange={handleChange}
                      onBlur={handleBlur}
                      value={values.title}
                      disabled={isSubmitting}
                      isInvalid={touched.title && errors.title}
                    />
                    {touched.title && errors.title && (
                      &lt;Text color="red">{errors.title}&lt;/Text>
                    )}
                  &lt;/FormControl>
                  &lt;FormControl mt={4}>
                    &lt;FormLabel>Description&lt;/FormLabel>
                    &lt;Textarea
                      name="description"
                      onChange={handleChange}
                      onBlur={handleBlur}
                      value={values.description}
                      disabled={isSubmitting}
                      isInvalid={touched.description && errors.description}
                    />
                    {touched.description && errors.description && (
                      &lt;Text color="red">{errors.description}&lt;/Text>
                    )}
                  &lt;/FormControl>
                  &lt;FormControl mt={4}>
                    &lt;FormLabel>Price&lt;/FormLabel>
                    &lt;Input
                      name="price"
                      onChange={handleChange}
                      onBlur={handleBlur}
                      value={values.price}
                      disabled={isSubmitting}
                      isInvalid={touched.price && errors.price}
                    />
                    {touched.price && errors.price && (
                      &lt;Text color="red">{errors.price}&lt;/Text>
                    )}
                  &lt;/FormControl>

                  &lt;FormControl mt={4}>
                    &lt;FormLabel>Photos&lt;/FormLabel>
                    &lt;FieldArray
                      name="photos"  //  initualValues üzerinden gelen tanım
                      render={(arrayHelpers) => (
                        &lt;div>
                          {values.photos &&
                            values.photos.map((photo, index) => (
                              &lt;div key={index}>
                                &lt;Input
                                  name={`photos.${index}`}
                                  value={photo}
                                  disabled={isSubmitting}
                                  onChange={handleChange}
                                  width="3xl"
                                />

                                &lt;Button
                                  ml={4}
                                  type="button"
                                  colorScheme="red"
                                  onClick={() => arrayHelpers.remove(index)} // FieldArray>arrayHelpers yardımıyla remove işlemi yapıldı.
                                  isLoading={isSubmitting}
                                >
                                  Remove
                                &lt;/Button>
                              &lt;/div>
                            ))}

                          &lt;Button
                            mt={5}
                            onClick={() => arrayHelpers.push("")} // FieldArray>arrayHelpers yardımıyla boş element ekleme işlemi yapıldı.
                            isLoading={isSubmitting}
                          >
                            Add a photo
                          &lt;/Button>
                        &lt;/div>
                      )}
                    />
                  &lt;/FormControl>
                  &lt;Button
                    mt={4}
                    width="full"
                    type="submit" // formikin mevcut değişiklikle submit etmesi sağlanır.
                    isLoading={isSubmitting}
                  >
                    Update
                  &lt;/Button>
                &lt;/form>
              &lt;/Box>
            &lt;/Box>
          &lt;/>
        )}
      &lt;/Formik>
    &lt;/div>
  );
}

export default AdminProductDetail;

              </pre>
            </p>
            <p>
              pages/Admin/AdminProductDetail/validations.js içine validasyon tanımları yapıldı.<br>
              <pre class="prettyprint ms-0">
import * as yup from "yup";

const editScheme = yup.object().shape({
    title: yup.string().required(),
    description: yup.string().min(5).required(),
    price: yup.number().required(),
})

export default editScheme;
              </pre>
            </p>
          </div>
          <div class="row" id="adminNewProduct">
            <h1>Admin: Yeni Ürün Eklemek</h1>
            <p>
              App.js içinde gerekli routing yapıldı. <br>
              <pre class="prettyprint ms-0">
&lt;Routes>
  ...
  &lt;Route element={&lt;ProtectedAdmin />}>
    &lt;Route path="/admin" element={&lt;Admin />}>
      ...
      &lt;Route path="products" element={&lt;AdminProducts />} />
      &lt;Route path="products/new" element={&lt;NewProduct />} />
      ...
    &lt;/Route>
  &lt;/Route>
  ...
&lt;/Routes>
              </pre>
            </p>
            <p>
              api.js içinde gereken fetch fonksiyonu tanımlanır. <br>
              <pre class="prettyprint ms-0">
export const postProduct = async (input) => {
  const { data } = await axios.post(
    `${process.env.REACT_APP_BASE_ENDPOINT}/product/`,
    input
  );

  return data;
};
              </pre>
            </p>
            <p>
              pages/Admin/AdminProducts/index.js içinde <q>New Product</q> butonu yerleştirilir. <br>
              <pre class="prettyprint ms-0">
...
return (
      &lt;div>
        &lt;Flex justifyContent="space-between" alignItems="center">
          &lt;Text fontSize="2xl" p="5">
            Products
          &lt;/Text>

          <u>
          &lt;Link to={"/admin/products/new"}>
          &lt;Button>New Product&lt;/Button>
        &lt;/Link>
          </u>
        &lt;/Flex>
        &lt;Table dataSource={data} columns={columns} rowKey="_id" />;
      &lt;/div>
    );
  }
  ...
              </pre>
            </p>
            <p>
              pages/Admin/AdminProducts/new.js dosyası oluşturulur. İçindeki çoğu eleman pages/Admin/AdminProductDetail/index.js ve pages/Admin/AdminProducts/index.js dosyasından kopyalandı. <br>
              <pre class="prettyprint ms-0">
import React from "react";

import { postProduct } from "../../../api";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Input,
  Text,
  Textarea,
} from "@chakra-ui/react";
import { message } from "antd";
import { Formik, FieldArray } from "formik";
import validationSchema from "./validations";

function NewProduct() {
  const queryClient = useQueryClient();

  const newProductMutation = useMutation(postProduct, { // ile fetch fonksiyonu yerleştirilir ve kullanılır.
    onSuccess: () => queryClient.invalidateQueries("admin:products"),
  });

  const handleSubmit = async (values, bag) => {
    console.log(values);
    message.loading({ content: "Loading...", key: "product_update" });

    const newValues = { // photos arrayi databasee stringfy edilerek gönderiliyor
      ...values, // tüm değerleri alır.
      photos: JSON.stringify(values.photos), // photos değerini stingfy şekliyle değiştirir.
    };

    newProductMutation.mutate(newValues, {
      onSuccess: () => {
        console.log("success");

        message.success({
          content: "The product successfully updated.",
          key: "product_update",
          duration: 2,
        });
      },
    });
  };
  
  return (
    &lt;div>
      &lt;Text fontSize="2xl">New Product&lt;/Text>

      &lt;Formik
        initialValues={{
          title: "",
          description: "",
          price: "",
          photos: [],
        }}
        validationSchema={validationSchema}
        onSubmit={handleSubmit}
      >
        {({
          handleSubmit,
          errors,
          touched,
          handleChange,
          handleBlur,
          values,
          isSubmitting,
        }) => (
          &lt;>
            &lt;Box> // Form yapısı AdminProductDetail/index.js nin aynısı
              &lt;Box my={5} textAlign="left">
                &lt;form onSubmit={handleSubmit}>
                  &lt;FormControl>
                    &lt;FormLabel>Title&lt;/FormLabel>
                    &lt;Input
                      name="title"
                      onChange={handleChange}
                      onBlur={handleBlur}
                      value={values.title}
                      disabled={isSubmitting}
                      isInvalid={touched.title && errors.title}
                    />
                    {touched.title && errors.title && (
                      &lt;Text color="red">{errors.title}&lt;/Text>
                    )}
                  &lt;/FormControl>
                  &lt;FormControl mt={4}>
                    &lt;FormLabel>Description&lt;/FormLabel>
                    &lt;Textarea
                      name="description"
                      onChange={handleChange}
                      onBlur={handleBlur}
                      value={values.description}
                      disabled={isSubmitting}
                      isInvalid={touched.description && errors.description}
                    />
                    {touched.description && errors.description && (
                      &lt;Text color="red">{errors.description}&lt;/Text>
                    )}
                  &lt;/FormControl>
                  &lt;FormControl mt={4}>
                    &lt;FormLabel>Price&lt;/FormLabel>
                    &lt;Input
                      name="price"
                      onChange={handleChange}
                      onBlur={handleBlur}
                      value={values.price}
                      disabled={isSubmitting}
                      isInvalid={touched.price && errors.price}
                    />
                    {touched.price && errors.price && (
                      &lt;Text color="red">{errors.price}&lt;/Text>
                    )}
                  &lt;/FormControl>

                  &lt;FormControl mt={4}>
                    &lt;FormLabel>Photos&lt;/FormLabel>
                    &lt;FieldArray
                      name="photos"
                      render={(arrayHelpers) => (
                        &lt;div>
                          {values.photos &&
                            values.photos.map((photo, index) => (
                              &lt;div key={index}>
                                &lt;Input
                                  name={`photos.${index}`}
                                  value={photo}
                                  disabled={isSubmitting}
                                  onChange={handleChange}
                                  width="3xl"
                                />

                                &lt;Button
                                  ml={4}
                                  type="button"
                                  colorScheme="red"
                                  onClick={() => arrayHelpers.remove(index)}
                                  isLoading={isSubmitting}
                                >
                                  Remove
                                &lt;/Button>
                              &lt;/div>
                            ))}

                          &lt;Button
                            mt={5}
                            onClick={() => arrayHelpers.push("")}
                            isLoading={isSubmitting}
                          >
                            Add a photo
                          &lt;/Button>
                        &lt;/div>
                      )}
                    />
                  &lt;/FormControl>
                  &lt;Button
                    mt={4}
                    width="full"
                    type="submit"
                    isLoading={isSubmitting}
                  >
                    Save
                  &lt;/Button>
                &lt;/form>
              &lt;/Box>
            &lt;/Box>
          &lt;/>
        )}
      &lt;/Formik>
    &lt;/div>
  );
}

export default NewProduct;

              </pre>
            </p>
            <p>
              validasyon dosyası Admin/AdminProductDetail/validations.js içinden kopyalanarak düzenlendi. <br>
              <pre class="prettyprint ms-0">
import * as yup from "yup";

const NewProductScheme = yup.object().shape({
    title: yup.string().required(),
    description: yup.string().min(5).required(),
    price: yup.number().required(),
})

export default NewProductScheme;
              </pre>
            </p>
          </div>
          <div class="row" id="MyModif">
            <h1>Projeye Benim Katkım</h1>
            <p>
              Admin/Product sayfasında sadece 12 ürün görünüyor. Tüm ürünleri göstermek için backend tarafına müdahale ettim. routes/index sayfasında yeni bir yönlendirme yazıldı. <br>
              <pre class="prettyprint ms-0">
router.use('/product-all', productAll);
              </pre>
              <p>
                Bu yönlendirmeyi almak için routes/productAll.js dosyası oluşturuldu. <br>
                <pre class="prettyprint ms-0">
import express from "express";
import ProductAll from "../controllers/productAll";

const router = express.Router();

router.get("/", ProductAll.GetList);

export default router;
                </pre>
              </p>
              <p>
                Bu yönlendirmeye response oluşturması için controllers/productAll/index.js dosyası oluşturuldu ve içine <br>
                <pre class="prettyprint ms-0">
import Product from "../../models/product";

const GetList = async (req, res, next) => {
  try {
    const products = await Product.find({}).sort({ createdAt: -1 });

    res.json(products);
  } catch (e) {
    next(e);
  }
};

export default {
  GetList,
};

                </pre>
              </p>
              <p>
                buradan gelen yönlendirme client tarafında api.js içinde yakalandı. <br>
                <pre class="prettyprint ms-0">
export const fetchProductAllList = async ({ pageParam = 0 }) => {
  const { data } = await axios.get(
    `${process.env.REACT_APP_BASE_ENDPOINT}/product-all`
  );

  return data;
};
                </pre>
              </p>
              <p>
                Bu fonksiyon pages\Admin\AdminProducts\index.js içinde import edilip fetchProductList yerine kullanıldı.
              </p>
              <p>
                Admin/Home sayfası düzenlendi.
              </p>
            </p>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js?lang=js&lang=html&lang=js&skin=sunburst"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>