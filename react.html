<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React</title>
    <link rel="stylesheet" href="css/sql.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Zenh87qX5JnK2Jl0vWa8Ck2rdkQ2Bzep5IDxbcnCeuOxjzrPF/et3URy9Bv1WTRi" crossorigin="anonymous">
    <style>
        .menu ul{
            list-style-position: inside;
            list-style: none;
        }
        li a{
            color: black;
            text-decoration: none;
        }
        li:hover{
            background-color: rgba(0, 0, 0, 0.103);
        }
        h1{
            border-bottom: 1px solid black;
        }
        h3{
            margin-top: 4px;
            margin-bottom: -3px;
            font-size: normal;
        }
        ul{
          list-style-position: inside;
        }
        table, th ,td{
          border: 1px black solid;
          border-collapse: collapse;
          text-align: center;
        }
    </style>
</head>
<body>
    <div class="nav bg-light">
        <div class="container">
            <nav class="navbar navbar-expand-lg">
                <div class="container-fluid">
                  <a class="navbar-brand" href="#">React</a>
                  <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                  </button>
                  <div class="collapse navbar-collapse" id="navbarNavDropdown">
                    <ul class="navbar-nav ms-auto">
                      <li class="nav-item">
                        <a class="nav-link" aria-current="page" href="index.html">Ana Sayfa</a>
                      </li>
                      <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                          Eğitim Notları
                        </a>
                        <ul class="dropdown-menu">
                          <li><a class="dropdown-item" href="html_notları.html" target="_blank">HTML Notları</a></li>
                          <li><a class="dropdown-item" href="CSS.html" target="_blank">CSS Notları</a></li>
                          <li><a class="dropdown-item" href="bootstrap.html" target="_blank">Bootstrap Notları</a></li>
                          <li><a class="dropdown-item" href="js.html" target="_blank">JavaScript Notları</a></li>
                          <li><a class="dropdown-item" href="git.html" target="_blank">git notları</a></li>
                          <li><a class="dropdown-item" href="sql.html" target="_blank">SQL notları</a></li>
                          <li><a class="dropdown-item" href="nodejs.html" target="_blank">NodeJS notları</a></li>
                          <li><a class="dropdown-item" href="restAPI.html" target="_blank">Rest Api notları</a></li>
                          </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </nav>
        </div>
    </div>
    <!-- Navbar End -->
    <!-- İçerik Start -->
    <div class="container">
      <div class="row">
        <div class="col-lg-3 mt-4 p-4 rounded-4 sticky-top menu d-none d-lg-block" style="height: fit-content;">
            <!-- style="height:fit-content => yükseklik belirtmediğinde kolon en alta kadar indiğinden .sticky-top görünür bir etki yaratmıyor -->
            <h2 class="text-center">Konu Listesi </h2>
            <ul style="max-height: 400px; overflow: auto;">
                <div class="giris">
                  <h3>Giriş</h3>
                  <li><a href="#giris">React Giriş</a></li>
                  <li><a href="#ES6">ES6 Modül Sistemi</a></li>
                  <li><a href="#callback">Callback Functions / async-await</a></li>
                  <li><a href="#promises">Promises</a></li>               
                  <li><a href="#arrayFunctions">Array Functions</a></li>
                </div>                   
                <div class="components">
                  <h3>Components</h3>
                  <li><a href="#createReactProject">Bir React Projesini Ayağa Kaldırmak (create-react-app)</a></li>
                  <li><a href="#component">Component Nedir?</a></li>
                  <li><a href="#crateComponet">Component Oluşturmak/Kullanmak</a></li>
                  <li><a href="#jsx">JSX ve Temel Kuralları</a></li>
                </div>
                <div class="props">
                  <h3>Props</h3>
                  <li><a href="#propsNedir">Props Nedir? Nasıl Kullanılır?</a></li>
                  <li><a href="#keyProp">Döngülerde "key" Prop'u</a></li>
                  <li><a href="#reactDeveloperTool">React Developer Tools</a></li>
                  <li><a href="#propTypes">Prop Types</a></li>
                  <li><a href="#defaultProps">Default Props</a></li>
                </div>
                <div id="states">
                  <h3>States</h3>
                  <li><a href="#stateNedir">State Nedir? Nasıl Oluşturulur?</a></li>
                  <li><a href="#arrayState">Array States</a></li>
                  <li><a href="#objectState">Object States</a></li>
                  <li><a href="#ornekCount">Sayaç Uygulaması</a></li>
                  <li><a href="#inputState">Input için State Tanımı Yapmak</a></li>
                </div>
                <div id="lifecycle">
                  <h3>Lifecycle</h3>
                  <li><a href="#useEffect">useEffect</a></li>
                  <li><a href="#componentUnmont">Component Unmount</a></li>
                </div>
                <div id="contactsApp">
                  <h3>Contacts App</h3>
                  <li><a href="#contactsApp">Contacts App</a></li>
                  <li><a href="#contactsForm">Form Component'inin Geliştirilmesi</a></li>
                  <li><a href="#contactsList">Kayıtların Listelenmesi</a></li>
                  <li><a href="#contactsFilter">Filtreleme İşlemi</a></li>
                  <li><a href="#contactsStil">Stil Tanımlarının Yapılması</a></li>
                </div>
                <div id="Stil">
                  <h3>Stillendirme Temelleri</h3>
                  <li><a href="#stilTanimi">Stil Tanımı Yapmak</a></li>
                  <li><a href="#moduleCss">Module CSS</a></li> 
                </div>
                <div id="Fetching">
                  <h3>Fetching</h3>
                  <li><a href="#nativeFetch">Native Fetch</a></li>
                  <li><a href="#axios">Axios</a></li>
                </div>
                <div id="Routing">
                  <h3>Routing</h3>
                  <li><a href="#routingKurulum">Kurulum</a></li>
                  <li><a href="#exactProp">Exact Prop</a></li>
                  <li><a href="#urlParameters">URL Parameters</a></li>
                  <li><a href="#nesting">Nesting</a></li>
                  <li><a href="#navlink">NavLink</a></li>
                  <li><a href="#noMatch">No Match (404)</a></li>
                </div>
                <div id="formik">
                  <h3>Formik ile Form Yönetimi</h3>
                  <li><a href="#formikKurulum">Kurulum</a></li>
                  <li><a href="#handleSubmitHandleChange">handleSubmit & handleChange</a></li>
                  <li><a href="#radioCheckboxDropdown">Radio / Checkbox / Dropdown</a></li>
                  <li><a href="#useFormik">useFormik</a></li>
                  <li><a href="#formValidasyon">Form Validasyonları (yup)</a></li>
                </div>
                <div id="memo">
                  <h3>Memoization</h3>
                  <li><a href="#reactMemo">React.memo</a></li>
                  <li><a href="#useMemo">useMemo</a></li>
                  <li><a href="#useCallback">useCallback</a></li>                  
                </div>
                <div id="contextApi">
                  <h3>Context API</h3>
                  <li><a href="#contextNedir">Context Nedir?</a></li>
                  <li><a href="#contextOlusturmak">Context Oluşturmak</a></li>
                  <li><a href="#contextProvider">Context Provider</a></li>
                  <li><a href="#themeSwitcher">Theme Switcher Yapımı</a></li>
                  <li><a href="#contextProviderSideEffects">Context Provider Side Effects</a></li>
                  <li><a href="#multiContext">Multi Context</a></li>
                  <li><a href="#customContextHook">Custom Context Hook</a></li>
                  <li><a href="#contextOdev">Ödev Notları</a></li>
                </div>
                <div id="realTime">
                  <h3>Real Time Çalışan Uygulamalar Geliştirmek</h3>
                  <li><a href="#arayuz">Arayüzün Hazırlanması</a></li>
                  <li><a href="#connectSocketServer">Socket Server'a Bağlanmak</a></li>
                  <li><a href="#backendVeri">Backend'e Veri İletmek</a></li>
                  <li><a href="#KanalAbone">Bir Kanala Abone Olmak</a></li>
                  <li><a href="#aboutSocket">Socket Io hakkında</a></li>
                </div>
                <div id="chatApp">
                  <h3>Chat App</h3>
                  <li><a href="#chatAppGiris">Giriş</a></li>
                  <li><a href="#chatContext">Chat Context</a></li>
                  <li><a href="#chatBilesenler">Temel Bileşenlerin Geliştirilmesi</a></li>
                  <li><a href="#backendBaglanti">Backend Bağlantısı</a></li>
                  <li><a href="#sendMessages">Mesajların İletilmesi</a></li>
                  <li><a href="#listMessages">Mesajların Listelenmesi</a></li>
                  <li><a href="#feedScroll">Feed Scroll</a></li>
                </div>
                <div id="localization">
                  <h3>Localization</h3>
                  <li><a href="#reactIntl">React Intl - Kurulum</a></li>
                  <li><a href="#defaultLocale">Default Locale</a></li>
                  <li><a href="#parametreGecmek">Parametre Geçmek</a></li>
                </div>
                <div id="testing">
                  <h3>Testing</h3>
                  <li><a href="#nedenTest">Neden Test Yazarız?</a></li>
                  <li><a href="#reactTestingLibrary1">React Testing Library Örnek 1</a></li>
                  <li><a href="#reactTestingLibrary2">React Testing Library Örnek 2</a></li>
                </div>
                <div id="testing">
                  <h3>Publishing</h3>
                  <li><a href="#createReactLibrary">create-react-library</a></li>
                  <li><a href="#publishislemleri">Publish İşlemleri</a></li>
                  <li><a href="#sematicVersiyonlama">Semantic Versiyonlama</a></li>
                </div>
                <div id="deploy">
                  <h3>Deploy</h3>
                  <li><a href="#surgeSh">Surge.sh</a></li>
                  <li><a href="#netlify">Netlify</a></li>
                  <li><a href="#awsEc2Deploy">AWS EC2 Üzerine Deploy İşlemleri</a></li>
                </div>
                <div id="eCommerceApp">
                  <h3>E-Commerce App (Örnek Proje)</h3>
                  <li><a href="#tanitim">Uygulama Tanıtımı</a></li>
                  <li><a href="#backendeGenelBakis">Backend'e Genel Bakış</a></li>
                  <li><a href="#chakraUI">Chakra UI Kurulumu</a></li>
                  <li><a href="#productEkrani">Products Ekranının Hazırlanması</a></li>
                  <li><a href="#reactQuery">React Query</a></li>
                  <li><a href="#reactQueryDevTools">React Query Dev Tools</a></li>
                  <li><a href="#urunDetay">Ürün Detay Sayfasının Geliştirilmesi</a></li>
                  <li><a href="#useInfiniteQuery">useInfiniteQuery</a></li>
                  <li><a href="#userRegister">Kullanıcı Kayıt İşlemleri</a></li>
                  <li><a href="#userLogout">Çıkış İşlemleri</a></li>
                  <li><a href="#protectedRoutes">Protected Routes</a></li>
                  <li><a href="#userLogin">Login İşlemleri</a></li>
                  <li><a href="#addToBasket">Sepete Atma İşlemleri</a></li>
                  <li><a href="#createOrder">Sipariş Oluşturma İşlemleri</a></li>
                  <li><a href="#adminRouting">Admin: Routing İşlemleri</a></li>
                  <li><a href="#adminOrder">Admin: Order Sayfası</a></li>
                  <li><a href="#adminProducts">Admin: Products Sayfası</a></li>
                  <li><a href="#adminProductUpdate">Admin: Product Update İşlemleri</a></li>
                  <li><a href="#adminNewProduct">Admin: Yeni Ürün Eklemek</a></li>
                  <li><a href="#MyModif">Projeye Benim Katkım</a></li>
                </div>
            </ul>
        </div>
        <div class="col-sm-9">
          <div class="row" id="giris">
            <h1>React Nedir? Ne Zaman İhtiyaç Duyarız?</h1>
            <p>
              User interfaces oluşturmak için JS kütüphanesi
            </p>
            <p>
              React düzenli DOM manuplasyonu yapılan sitelerde kullanılır. Bütün sayfa render edilmeden sadece ilgili alan render edilir.
            </p>
            <h2>Real DOM</h2>
            <p>
              Web sayfasını oluşturan html etiketlerinin tamamı Real DOM'u oluşturur.
            </p>

            <h2>Vitrual DOM</h2>
            <p>
              real DOM yapısının js üzerinde obje olarak tutulan kopyası.
            </p>
            <p>
              Veri güncellendiğinde react vitrual DOM ve real DOM'u karşılaştırır. Fark var ise sadece fark olan yer real DOM üzerinde değiştirilir. Bu sayede tüm sayfa render edilmemiş olur.
            </p>
          </div>
          <div class="row" id="ES6">
            <h1>ES6 Modül Sistemi</h1>
            <p>
              Modül sistemini çalışması için package.json içine "type": "module" verisi girilmeli. <br>
              Bunu yazdıktan sonra daha önce require ile çağırdığımız modülleri artık farklı bir şekilde import edeceğiz. <br>
              <strong>Her iki import şekli aynı anda çalışmaz. Modül aktif edildiğinde require hata verir.</strong>
            </p>
            <p>
              <code>
                const slugify = require('suligify'); 
              </code>
              yerine <br>
              <code>
                import slugify from "slugify"
              </code> kullanılır.
            </p>
            <p>
              Modülü export ederken de iki sistem arasında yazım farkları mevcut. <br>
              <strong>Modüle aktif değilken:</strong> <br>
              <code>
                exports.topla = (a, b) => {console.log(a + b);}; <br>
                exports.hello = () => {console.log("hello")}; <br>
              </code> kullanılır. import için de <br>
              <code>const {hello, topla} = require("../js/myModule")</code> kullanılır.
               <br><br>
              <strong>Modüle aktifken:</strong> <br>
              <code>
                export const topla = (a, b) => {console.log(a + b);}; <br>
                export const hello = () => {console.log("hello")}; <br>
              </code> veya <br>
              <code>
                const topla = (a, b) => {console.log(a + b);}; <br>
                const hello = () => {console.log("hello")}; <br>
                export {topla, hello}
              </code> kullanılır. <br>
              import için de: <br>
              <code>
                import {topla, hello} from "../js/myModule"
              </code> kullanılır.
            </p>
            <p>
              modül kullanımında tek bir fonksiyon default olarak dışa aktarılabilir. <br>
              <code>
                export const topla = (a, b) => {console.log(a + b);}; <br>
                export const hello = () => {console.log("hello")}; <br>
                const cikar = (a, b) => {console.log(a - b);}; <br>
                export default hello;
              </code> default olarak gönderilen fonksiyon çağırılırken süslü paranteze konmaz. <br>
              <code>
                import cikar, {topla, hello} from "../js/myModule"
              </code> <br>
              default fonksiyon çağırılırken oluşturulan ismi dışında bir isimle de çağırılabilir. <br>
              <code>
                import app, {topla, hello} from "../js/myModule"
              </code> bu yazımda cikar fonksiyonu çağırıldığı yerde app adı ile kullanılır.
            </p>
            <p>
              her iki import yapısıyla da fonksiyon dışında diğer değişkenler (sting, array, object vs) de import-export edilebilir.
            </p>
          </div>
          <div class="row" id="callback">
            <h1>Callback Functions / async-await</h1>
            
            <h2>İşimize yarayacak fonksiyonlar.</h2>
            <p>
              <b>setTimeout()</b> belirli bir süre sonunda içine tanımlanan fonksiyonun gerçekleşmesini sağlar. 2 parametre alır. ilk parametreye fonksiyon ikinciye milisaniye cinsinden süre yazılır. <br>
              <b>setInterval()</b> belirli bir sürede tanımlanan fonksiyonun tekrar tekrar gerçekleşmesini sağlar. 2 parametre alır. ilk parametreye fonksiyon ikinciye milisaniye cinsinden süre yazılır. <br>
              <b>fetch()</b> herhangi bir veri kaynağına bağlanıp aldığı veriyi bize getirir.
            </p>
            <p>
              <b>Callback</b>: başka bir kod parçasına argüman olarak iletilen yürütülebilir koda yapılan herhangi bir başvurudur. Bir fonksiyon çalışmasını tamamladıktan sonra başka bir fonksiyonun çalışmasını sağlayan fonksiyonlara callback fonksiyon denir. 
            </p>
            <p>
              js yapısı gereği fonksiyonlar birbirinin tamamlanmasını beklemeden devreye girerler. Bunu olmasını engellemek istediğimiz fonksiyonlar ya .then yapılarıyla yada async-await ile yazılır.
            </p>
            <p>
              <b>.then örneği:</b> <br>
              <code>
                fetch("https://jsonplaceholder.typicode.com/users/1") <br>
                .then((data) => data.json()) <br>
                .then((users) => { <br>
                  console.log("users yüklendi", users); <br>

                  fetch("https://jsonplaceholder.typicode.com/posts/1") <br>
                    .then((data) => data.json()) <br>
                    .then((posts) => console.log("post yüklendi", posts)); br
                });
              </code> Bu yapıda her .then() kendinden önceki fonksiyonu bekler ve ondan gelen veriyi alır.
            </p>
            <p>
              <b>async-await örneği</b> <br>
              <code>
                async function getData() { <br>
                  const user = await ( <br>
                    await fetch("https://jsonplaceholder.typicode.com/users/1") <br>
                  ).json(); <br>
                
                  const post = await ( <br>
                    await fetch("https://jsonplaceholder.typicode.com/posts/1") <br>
                  ).json(); <br>
                
                  console.log("users yüklendi", user); <br>
                  console.log("post yüklendi", post); <br>
                } <br>
                
                getData(); <br>
              </code> Bu yapıda asenkron olması için fonksiyonun başına async eklenir. Tamamlanması beklenecek her fonksiyonun başına da await eklenir. Sonra da fonksiyon çağırılır.
            </p>
            <p>
              Fonksiyonu isimlendirmek ve ayrıca çağırmak istemediğimiz durumlarda anonim fonksiyon yapısı kullanılır. <br>
              (()=>{})();
              <b>Örnek:</b> <br>
              <code>
                (async()=>{ <br>
                  const user = await ( <br>
                      await fetch("https://jsonplaceholder.typicode.com/users/1") <br>
                    ).json(); <br>
                  
                    const post = await ( <br>
                      await fetch("https://jsonplaceholder.typicode.com/posts/1") <br>
                    ).json(); <br>
                  
                    console.log("users yüklendi", user); <br>
                    console.log("post yüklendi", post); <br>
                })();
              </code>

            </p>
            <p>
              hoca fetch işlevi için npm den node-fetch kurdurup fetch adıyla import edilir diyor ama paket indirmeden de fetch komutu çalışıyor. node versiyonu ile ilgili olabilir.
            </p>
            <p>
              axios kütüphanesi fetch'in yaptığı işi daha kolay yapmamızı sağlıyormuş. <br>
              kodun axios hali: <br>
              <code>
                (async()=>{ <br>
                  const {data: user} = await axios("https://jsonplaceholder.typicode.com/users/1") </code> {data: user} axios tarafından gelen data değişkeninin adını user yapar. <br> 
                  <code>             
                  const {data: post} = await axios("https://jsonplaceholder.typicode.com/posts/1") <br>

                    console.log("users yüklendi", user); <br>
                    console.log("post yüklendi", post); <br>
                })();
              </code>
            </p>
          </div>
          <div class="row" id="promises">
            <h1>Promises</h1>
            <p>
              .then() fonksiyonu ile data alınabilen fonksiyonlara <b>promise</b> denir. <br>
              <b>.then()</b> ile olumlu sonuç (resolve) yakalanır. <br>
              <b>.catch()</b> ile olumsuz sonuç (reject) yakalanır.
            </p>
            <p>
              <b>Örnek 1:</b> <br>
              <code>
                const getComment = (number) => { <br>
                  return new Promise((resolve, reject)=>{ </code> bu satırda bir promise başlatıyoruz. promise 2 parametre alır. <br>
              <code>
                      if(number === 1){ <br>
                          resolve('comments'); </code> Bu kısım .then() ile yakalanır. <br>
              <code>          
                      } <br>
                      reject('bir problem var') </code> Bu kısım .catch() ile yakalanır. <br>
              <code>
                  }) <br>
                } <br><br>
                
                getComment(1) <br>
                .then((data) => console.log(data)) <br>
                .catch((e)=> console.log(e))
              </code>
            </p>
            <p>
              <b>Örnek 2</b>
              <code>
                const getUser = (userId) => { <br>
                  return new Promise(async(resolve, reject)=>{ <br>
                      const user = await ( <br>
                              await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)) <br>
                              .json(); <br> 
                      resolve(user) <br>
                  })
                }
                
                getUser(2) <br>
                .then((data) => {console.log(data); return data.name}).then((data) => console.log(data)) <br>
                .catch((e)=> console.log(e))
              </code> <br>
              veya <br>
              <code>
                const getUser = (userId) => { <br>
                  return new Promise(async(resolve, reject)=>{ <br>
                      const user = await ( <br>
                              await fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)) <br>
                              .json(); <br> 
                      resolve(user) <br>
                  }) <br>
                } <br><br>
                
                (async () => { <br>
                  try { <br>
                    const user = await getUser(2); <br>
                    console.log(user); <br>
                  } catch (err) { <br>
                    console.log(err); <br>
                  } <br>
                })();
              </code> Burada kullanılan try-catch bloğu hata yakalamak için kullanılır.
            </p>
            <p>
              Birden fazla promise yapısında fonksiyonu çalıştırmak için <code>Promise.all()</code> içine array olarak çalışması istenen fonksiyonların adı yazılır. <br>
              <code>
                Promise.all([getUsers(), getPost(1)]) <br>
                .then(console.log) <br>
                .catch(console.log)
              </code>
            </p>
          </div>
          <div class="row" id="arrayFunctions">
            <h1>Array Fonksiyonları</h1>
            <p>
              push, map, find, filter, some, every, includes
            </p>
            
            <h2>push</h2>
            <p>
              Örnek<br>
              <code>
                const users = ["Mehmet", "Ahmet". "Murat"] <br>
                users.push("Ayşe") <br>
                console.log(users)
              </code> <br>
              çıktı: <br>
              <code>
                ["Mehmet", "Ahmet". "Murat", "Ayşe"]
              </code>
            </p>

            <h2>map</h2>
            <p>
              For döngüsü gibi array içindeki tüm değerlerde dönüyor.
            </p>
            <p>
              Örnek<br>
              <code>
                const users = ["Mehmet", "Ahmet". "Murat"] <br>
                users.map((x)=>{console.log(x)}) <br>
              </code> <br>
              çıktı: <br> 
              <code>
                Mehmet <br>
                Ahmet <br>
                Murat
              </code>
            </p>

            <h2>find</h2>
            <p>
              Array içinde arama yapar. Koşula uyan bir şey varsa ilk bulduğunu getirir. Yoksa undefined döner. Aramada mantık operatörleri kullanılabilir.
            </p>
            <p>
              Örnek: <br>
              <code>
                const users = [ <br>
                { 
                  name: "Mehmet",
                  age: 18
                }, <br>
                {
                  name: "Mehmet",
                  age: 25
                }, <br>
                {
                  name: "Murat",
                  age: 28
                }, <br>
                ] <br>
                const result = users.find((x)=> x.name === "Mehmet" && x.age > 20) <br>
                console.log(result)
              </code> <br>
              çıktı:<br>
              <code>
                { name: 'Mehmet', age: 25 }
              </code>
            </p>

            <h2>filter</h2>
            <p>
              Filtreleme yapar.
            </p>
            <p>
              Örnek: <br>
              <code>
                const users = [ <br>
                { 
                  name: "Mehmet",
                  age: 18
                }, <br>
                {
                  name: "Mehmet",
                  age: 25
                }, <br>
                {
                  name: "Murat",
                  age: 28
                }, <br>
                ] <br>
                const filtered = users.filter((x)=> x.name === "Mehmet" && x.age > 10) <br>
                console.log(filtered)
              </code> <br> veya <br>
              <code>
                const filtered = users.filter(({ name, age })=> name === "Mehmet" && age > 10) <br>
                console.log(filtered)
              </code> <br>
              Çıktı: <br>
              <code>
                [ <br>
                { name: 'Mehmet', age: 18 },<br> 
                { name: 'Mehmet', age: 25 } <br> 
                ]
              </code>
            </p>

            <h2>some</h2>
            <p>
              Array içindeki değerlerden biri koşula uyuyorsa true, hiçbiri uymuyorsa false döner
            </p>
            <p>
              Örnek: <br>
              <code>
                const users = [ <br>
                { 
                  name: "Mehmet",
                  age: 18
                }, <br>
                {
                  name: "Mehmet",
                  age: 25
                }, <br>
                {
                  name: "Murat",
                  age: 28
                }, <br>
                {
                  name: "Hasan",
                  age: 10
                }, <br>
                ] <br>
                const some = users.some((x)=> x.age = 10) <br>
                console.log(some)
              </code> <br>
              çıktı: <br>
              <code>
                true
              </code>
            </p>
            <h2>every</h2>
            <p>
              Array içindeki değerlerin hepsi uyuyorsa true, biri bile uymuyorsa false döner
            </p>
            <p>
              Örnek: <br>
              <code>
                const users = [ <br>
                { 
                  name: "Mehmet",
                  age: 18
                }, <br>
                {
                  name: "Mehmet",
                  age: 25
                }, <br>
                {
                  name: "Murat",
                  age: 28
                }, <br>
                {
                  name: "Hasan",
                  age: 10
                }, <br>
                ] <br>
                const every = users.every((x)=> x.age > 9) <br>
                console.log(every)
              </code> <br>
              çıktı: <br>
              <code>
                true
              </code>
            </p>

            <h2>includes</h2>
            <p>
              Arrayin içinde olma durumunu verir. Varsa true, yoksa false verir.
            </p>
            <p>
              Örnek: <br>
              <code>
                const meyveler = ["elma", "armut", "muz"]; <br>
                const isIncluded = meyveler.includes("muz"); <br>
                console.log(isIncluded)
              </code> <br>
              çıktı: <br>
              <code>
                true
              </code>
            </p>
          </div>
          <div class="row" id="createReactProject">
            <h1>Bir React Projesini Ayağa Kaldırmak (create-react-app)</h1>
            <p>
              create-react-app facebook'un hazırladığı ve paylaştığı hazır bir react geliştirme ortamı. <a href="https://github.com/facebook/create-react-app">github.com/facebook/create-react-app</a>
            </p>
            <p>
              crate-react-app için npx kurmak gerekiyor. Bu da node yüklenirken bilgisayara yüklenmiş oluyor. npx, npm de global olarak kurulup kullanılması gereken paketlerin kurulmadan kullanılmasına olanak sağlıyormuş.
            </p>
            <p>
              create-react-app kurulumu için terminale: <br>
              <code>
                npx create-react-app my-example-app
              </code> my-example-app yerine kendi projemizin adını yazıyoruz. Bunun sonucunda terminalin içinde olduğu dizine projemizin adında bir klasör oluşturuluyor. my-example-app yerine nokta (.) koyarsak bulunduğumuz dizinin içine kurar.
            </p>
            <p>
              projeyi açmak için terminale: <br>
              <code>
                cd my-example-app
              </code>
              (bizim klasörümüzün adı neyse o yazılacak) ile klasörün içine girip sonra: <br>
              <code>
                npm start
              </code> ile uygulama başlatılır. Açıldığında bizi http://localhost:3000/ adresinde karşılar. 3000 portu dolu ise başka bir portta açar. Açtığı portu terminalde gösterir. Hatta varsayılan tarayıcıda da açar.
            </p>
          </div>
          <div class="row" id="component">
            <h1>Component Nedir?</h1>
            <p>
              Web sayfasını meydana getiren bileşenlerdir. Bu companentler birleşerek başka kompanentleri ve sonunda web sayfamızı oluştururlar.
            </p>
          </div>
          <div class="row" id="crateComponet">
            <h1>Component Oluşturmak/Kullanmak</h1>
            <p>
              create-react-app işlemi sonrası bizim için kurulan dosyalar: <br>
              <b>node_modules:</b> bize react için gereken node modulleri <br>
              <b>public:</b> <br>
              <b>source:</b> bizim için asıl önemli kısım: <br>
              <ul>
                <li><b>App.js</b> bundan sonra yazacağımız bütün kompanentleri bu app kompanentinde birleştirerek ilerleyeceğiz.</li>
              </ul>
            </p>
            <p>
              Companent oluşturmak için companentin adında bir fonksiyon oluşturmak ve return ile istediğimiz companent htmlsini yazmamız yeterli
            </p>
            <p>
              public/index.html içinde id si root olan bir div mevcut. <br> 
              src/index.js içinde 'react' ve 'react-dom' import edilmiş. './index.css' imort edilmiş. App modülü ve reportWebVitals modülü de import edilmiş. devamında <br>
              <code>
                const root = ReactDOM.createRoot(document.getElementById('root'));
              </code> ile index.html içinde id='root' olan elemente ulaşıyor. <br>
              <code>
                root.render(
                  &lt;React.StrictMode>
                    &lt;App />
                  &lt;/React.StrictMode>
                );
              </code> bu elemente app companentini yerleştiriyor.
            </p>
            <p>
              App.js içindeki kompanenti değiştirdiğimizde sayfada görünen kısım da değişiyor.
            </p>
            <p>
              Kendi kompanentimizi yazmak: <br>
              src içine components/Header.js oluşturuldu. içine: <br>
              <code>
                function Header(){ <br>
                  return( <br>
                    &lt;div> <br>
                        Merhaba Ben Header Bileşeniyim. <br>
                    &lt;/div> <br>
                  ); <br>
                } <br>
                import default Header; <br>
              </code> yazıldı. <br>
              App.js içine import edildi ve kullanıldı. <br>
              <code>
                import './App.css'; <br>
                import Header, {  } from "./components/Header"; <br>

                function App(){ <br>
                  return ( <br>
                    &lt;div> <br>
                     <u> &lt;Header /></u> <br>
                    &lt;/div> <br>
                  ); <br>
                } <br>

                export default App; <br>

              </code>
            </p>
          </div>
          <div class="row" id="jsx">
            <h1>JSX ve Temel Kuralları</h1>
            <p>
              JavaScript’in bir söz dizimi uzantısıdır. Bu olmadan da react yazılabilir ama kod çok karmaşıklaşır. JSX sayesinde html yazar gibi js kodları yazabiliyoruz.
            </p>

            <h2>JSX kuralları</h2>
            <p>
              Kompanent belirtilen fonksiyon adının büyük harf olmasına dikkat edelim. Bu sayede html etiketleri ile karışmazlar. Küçük harfle başlarsa react yorumlarken kompanenti html etiketi olarak yorumlar.
            </p>
            <p>
              Her kompanent eklenirken bir kapsayıcı etiket içine dahil edilir. <br>
              <b>&lt;div>&lt;/div></b> veya <b>boş etiket "&lt;>  &lt;/>" </b>kullanılabilir.
            </p>
            <p>
              JS için özel tanımlı keywordler kullanılmaz. <br>
              <b>class</b> ifadesi js içinözel tanımlı. yerine <b>classname</b> kullanılır. <br>
              <b>for</b> yerine <b>htmlFor</b> kullanılır. vs<br>
              Bu kullanım sayedinde js'de de anlamı olan keywordler jsx içinde kullanılmamış olut.
            </p>

            <h2>JSX içinde değişken kullanma:</h2>
            <p>İki şekilde yapılabilir.</p>
            <p>
              Değişken süslü parantez içine alınabilir. <br>
              <code>
                ... <br>
                &lt;h1>Benim Adım {name}&lt;/h1> <br>
                ... <br>
              </code> veya süslü parantez arasına backtick ile yazılabilir.<br>
              <code>
                ... <br>
                &lt;h1>{`Benim adım: ${name}`}&lt;/h1> <br>
                ... <br>
              </code>

              <h2>Koşullu Render</h2>
              <p>
                Koşulu sorgulama için isLoggedIn adında boolean değerli bir değişken oluşturduk. <br>
                <code>
                  ... <br>
                  &lt;h1>{isLoggedIn && `Benim adım: ${name}`}&lt;/h1> <br>
                  &lt;h1>{!isLoggedIn && `Giriş Yapmadınız`}&lt;/h1> <br>
                  ... <br>
                </code> veya <br>
                <code>
                  ... <br>
                  &lt;h1>{isLoggedIn ? `Benim adım: ${name}` : `Giriş Yapmadınız` }&lt;/h1> <br>
                  ... <br>
                </code>
              </p>
            </p>
          </div>
          <div class="row" id="propsNedir">
            <h1>Props Nedir? Nasıl Kullanılır?</h1>
            <p>
              Props (properties) kompanent içinde parametre geçebileceğimiz bir yapı. html etiketlerindeki Attribute-value gruplarına benzer şekilde veri App.js üzerinde kullanılan componente girilerek componentin işlemesi sağlanır. 
            </p>
            <p>
              App.js içinde: <br>
              <code>
                &lt;div> <br>
                  &lt;User name="Murat" surname="Gökduman" isLoggedIn={false}/> <br>
                &lt;/div> <br>
              </code>
              ile props olarak bilgiler gönderilir. props gönderildiği yerde işlenir ve User componenti olarak kullanılır.
            </p>
            <p>
              User.js içinde: <br>
              <code>
                function User(props){ <br>
                  return( <br>
                      &lt;div> <br>
                          {props.isLoggedIn ? `${props.name} ${props.surname}`: "Giriş Yapmadınız"}  <br>          
                      &lt;/div> <br>
                  ) 
              } <br>
              
              export default User <br>
              </code> kuralına uygun olarak veri işlenir ve gönderilir. Bu kodda props obje yapısında olduğundan: <br>
              <code>
                function User(<u>{name, surname, isLoggedIn}</u>){ <br>
                  return( <br>
                      &lt;div> <br>
                          {<u>isLoggedIn</u> ? `<u>${name} ${surname}</u>`: "Giriş Yapmadınız"}  <br>          
                      &lt;/div> <br>
                  ) 
              } <br>
              
              export default User <br> 
              </code> olarak da yazılabilir.
            </p>
            <p>
              props gönderme ve alma sırası önemli değil.
            </p>
          </div>
          <div class="row" id="keyProp">
            <h1>Döngülerde "key" Prop'u</h1>
            <p>
              Kompanente prop olarak bir array ekleyip görüntüleyeceğiz.
            </p>
            <p>
              Array listelenen durumlarda her elemanını üstündeki etikette unique bir key değeri belirtilmeli. Bunun için array map metodundan alınan index değeri kullanılabilir.
            </p>
            <p>
              ket değeri reactın performansı için gerekli. Yzılmazsa konsola uyarı verir.
            </p>
            <p>
              Daha önceki örnekte kullandığımız User kompanentine App.js içinde bir array prop olarak girildi: <br>
              <code>
                friends={["Ahmet", "Tayfun", "Gökhan", "Ayşe", "Fatma"]}
              </code> <br>
              User.js içinde .map() metodu ile tek tek çağırıldı. <br>
              <code>
                {friends.map((friend, index) => ( <br>
                  &lt;div key={index}> <br>
                      {index} - {friend} <br>
                  &lt;/div> <br>
              ))} 
              </code> key olarak index kullanıldı.
            </p>
            <p>
              Kullandığımız array obje yapısındaysa ve unique bir id değeri varsa bu değer de kullanılabilir.
            </p>
            <p>

              örn: <br>
              App.js içinde: <br>
              <code>
                const friends = [{name: "Ahmet", id: 1}, {name: "Tayfun", id: 2} , {name: "Gökhan", id: 3} , {name: "Ayşe", id: 4}, {name: "Fatma", id: 5}] <br>
                ... <br>
                friends={friends} <br>
                ... <br>
              </code>
              User.js içinde:
              <code>
                {friends.map((friend) => ( <br>
                  &lt;div key={friend.id}> <br>
                  {friend.id} - {friend.name} <br>
                  &lt;/div> <br>
                  ))} <br>
                </code> veya <br>
                <code>
                  {friends.map((friend) => { <br>
                    return (&lt;div key={friend.id}> <br>
                    {friend.id} - {friend.name} <br>
                    &lt;/div>) <br> 
                  })}
                </code> Bu yapı özellikle fonksiyon içinde başka bir işlem de yapılacaksa faydalıdır.
              </p>
          </div>
          <div class="row" id="reactDeveloperTool">
            <h1>React Developer Tools</h1>
            <p>
              chrome extansion: <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React Developer Tools</a>
            </p>
            <p>
              Sayfayı sağ tıklayıp incele dediğimizde çıkan menüye Components sekmesi ekler. Bu sayede companentleri ve propslarını sayfamızda ayırdedebiliriz. Hiyerarşik olarak gösterir. Anlık olarak değiştirip değişikliğin sonucunu da deneyebiliriz.
            </p>
          </div>
          <div class="row" id="propTypes">
            <h1>Prop Types</h1>
            <p>
              Kompanentin hangi prop tiplerini kabul edeceğini ayarlamak için kullandığımız bir araç.
            </p>
            <p>
              User kompanenti için User.js içine: <br>
              <code>
                import PropTypes from "prop-types";
              </code> ile "prop-types" import edilir. <br>
              <code>
                User.propTypes = { <br>
                  name: PropTypes.string, <br>
                  surname: PropTypes.string, <br>
                  isLoggedIn: PropTypes.bool, <br>
                  friends: PropTypes.array <br>
                  age: PropTypes.number <br>
              }
              </code> ile prop tipleri belirtilir.
            </p>

            <h2>isRequired</h2>
            <p>
              Gönderilecek propun zorunlu olduğunu belirtmek için: <br>
              <code>
                ... <br>
                name: PropTypes.string.isRequired, <br>
                ... <br>
              </code>
            </p>

            <h2>oneOfType</h2>
            <p>
              Bir prop için birden fazla veri tipi kabul etmek için: <br>
              <code>
                ... <br>
                age: PropTypes.<u>oneOfType</u>([ <br>
                PropTypes.number, <br>
                PropTypes.string <br>
                ]), <br>
                ... <br>
              </code>
            </p>

            <h2>shape</h2>
            <p>
              Obje olarak gönderilen prop için kullanılabilir. <br>
              <code>
                ... <br>
                adress: PropTypes.<u>shape</u>({ <br>
                  title: PropTypes.string, <br>
                  zip: PropTypes.number, <br>
              }) <br>
              ... <br>
              </code>
            </p>
          </div>
          <div class="row" id="defaultProps">
            <h1>Default Props</h1>
            <p>
              İlgili kompanent içinde özellikle prop değeri belirtilmemiş proplar için de default prop değeri atanabilir. <br>
              <code>
                User.defaultProps = { <br>
                  isLoggedIn: false, <br>
                } <br>
              </code>
              Prop olarak değer gelirse gelen değeri, gelmezse default değeri kullanır.
            </p>
          </div>
          <div class="row" id="stateNedir">
            <h1>State Nedir? Nasıl Oluşturulur?</h1>
            <p>
              State kompanentler üzerinde değerinin değişme potansiyeli olan bütün değerleri tutan JS objesidir. State değişince ilgili kompanentdeki değişim ekrana render edilir. 
            </p>
            <p> 
              <code>
                import { useState } from "react";
              </code>
              useState yapısı react içinden import edilir. <br>
              <code>
                function App(){ <br>
                  const [name, setName] = useState("Murat")
              </code>
              fonksiyon içine ilgili state tanımlanır. useState içindeki değer default değerdir.<br> 
              <code>
                return ( <br>
                &lt;div> <br>
                    &lt;h1>Hello {name}&lt;/h1>
              </code> 
              return içinde değişken gibi kullanılır. <br>
              <code>
                &lt;button onClick={() => setName("Ahmet")}>Click&lt;/button>
              </code> setname fonksiyonu ile değer değiştirilir. değiştirilmesini sağlayan bir işlem sonrası yeni hali render edilir. <br>
              <code>
                  &lt;/div> <br>
                  ); 
                } <br>   
                export default App;
              </code>
            </p>
            <p>
              state değeri js içinde kullanılacak tüm değişkenleri içerebilir.
            </p>
            <p>
              Herhangi bir state güncellendiği anda render işlemi baştan yapılır.
            </p>
          </div>
          <div class="row" id="arrayState">
            <h1>Array States</h1>
            <p>
              App.js App fonksiyonunda daha önceki stateleri eklediğimiz yere: <br>
              <code>
                const [friends, setFriends] = useState(['Ahmet', 'Murat']);
              </code> ile array yapıda state eklenir. <br>
              App fonksiyonunun return parantezinin içindeki kapsayıcı div etiketinin içine: <br>
              <code>
                &lt;h2>Friends&lt;/h2> <br>
                  { <br>
                    friends.map((friend, i) => ( <br>
                      &lt;div key={i}>{friend}&lt;/div> <br>
                    )) <br>
                  }
              </code> ile arrayin render edileceği fonksiyon yazılır. <br>
              <code>
                  &lt;button onClick={() => setFriends([...friends, 'Ayşe'])}>add new friend&lt;/button>
              </code> setFriends içindeki yapı ilk tanımdaki gibi array olmalıdır. Buna dikkat edilmezse arrayi yansıtırken kullanılacak kodlarda hata alırız.
            </p>
            <p>
              array içindeki <code>...friends</code> ifadesi mevcut arrayin korunmasını sağlar. Yeni ifade bunun sonuna yazılırsa sonuna, öncesine yazılırsa başına eklenir. 
            </p>
            <p>
              Mevcut ifadeyi korumanın bir başka yolu: <br>
              <code>
                setFriends((prevState) => [...prevState, 'Ayşe'])
              </code> ile önceden eklenen kısım çağırılıp dizine eklenebilir.
            </p>
          </div>
          <div class="row" id="objectState">
            <h1>Object States</h1>
            <p>
              App.js App fonksiyonunda daha önceki stateleri eklediğimiz yere: <br>
              <code>
                const [address, setAddress] = useState({ title: 'ev', zip: 34765, city: 'Ankara' });
              </code> ile object yapıda state eklenir. <br>
              App fonksiyonunun return parantezinin içindeki kapsayıcı div etiketinin içine: <br>
              <code>
                &lt;h2>Address&lt;/h2> <br>
                &lt;div>{address.title} {address.zip} {address.city}&lt;/div>
              </code> ile objenin render edileceği fonksiyon yazılır. <br>
              <code>
                &lt;button onClick={() => setAddress({...address, title: 'iş', zip: 34344})}>Change Address&lt;/button>
              </code> setAddress içindeki yapı ilk tanımdaki gibi object olmalıdır. Buna dikkat edilmezse objeyi yansıtırken kullanılacak kodlarda hata alırız. <br>
            </p>
            <p>
              obje içindeki <code>...address</code> ifadesi mevcut address bilgilerinin default olmasını sağlar. Bu sayede yeni tanımlanmayan değerler ilk tanıma bağlı kalır. <code>...address</code> olmazsa value değeri alamayan keyler silinir.
            </p>
            <p>
              Mevcut ifadeyi korumanın bir başka yolu: <br>
              <code>
                setAddress((prevState) => {...prevState, title: 'iş', zip: 34344})
              </code> ile önceden eklenen kısım çağırılıp dizine eklenebilir.
            </p>
          </div>
          <div class="row" id="ornekCount">
            <h1>Sayaç Uygulaması</h1>
            <p>
              src/components içinde Counter.js dosyası oluşturulur. İçine: <br>
              <code>
                import React, { useState } from 'react'
              </code> ile useState import edilir. <br>
              <code>
                function Counter() { <br>
                  const [count, setCount] = useState(0)
              </code> ile state oluşturulur. <br>
              <code>
                return ( <br>
                  &lt;div> <br>
                      &lt;h1>{count}&lt;/h1>
              </code> ile state yerleştirilir. <br>
              <code>
                      &lt;button onClick={() => setCount(count+1)}>Decrease&lt;/button> <br>
                      &lt;button onClick={() => setCount(count-1)}>Increase&lt;/button>
              </code> ile butonlara setCount fonksiyonu verilir. <br>
              <code>
                  &lt;/div> <br>
                )
              } <br>
              
              export default Counter
              </code> ile export edilir.
            </p>
            <p>
              App.js içinde veya doğrudan index.js içinde import edilerek kullanılır.
            </p>
            <p>
              onClick fonksiyonlar başka yerde tanımlanıp daha sonra onClick içinde kullanılabilir. <br>
              <code>
                function Counter() { <br>
                  const [count, setCount] = useState(0) <br>
              
                  const increase = () => {
                      setCount(count-1)
                  } <br>
              
                  const decrease = () => {
                      setCount(count+1)
                  } <br>
                return ( <br>
                  &lt;div> <br>
                      &lt;h1>{count}&lt;/h1> <br>
                      &lt;button onClick={decrease}>Decrease&lt;/button> <br>
                      &lt;button onClick={increase}>Increase&lt;/button> <br>
                  &lt;/div> <br>
                )
              }
              </code>
            </p>
          </div>
          <div class="row" id="inputState">
            <h1>Input için State Tanımı Yapmak</h1>
            <p>
              src/components içine InputExample.js oluşturulud. içine: <br>
              <code>
                import { useState } from "react" <br>

                function InputExample() { <br>
                    const [name, setName] = useState('test') br
                    return( <br>
                        &lt;div> <br>
                            Please enter a name: &lt;br /> <br>
                            &lt;input value={name} onChange={(event)=>setName(event.target.value)}/>
              </code> ile formda değişiklik yapıldığında setName işlemi çağırılır. Forma yazılan value event.target.value yakalanır. <br>
              <code>
                            &lt;br /> <br>
                            {name} <br>
                        &lt;/div> <br>
                    ) <br>
                } <br>

                export default InputExample <br>
              </code>
            </p>

            <p>
              onchange içindeki fonksiyonu dışa taşımak için: <br>
              <code>
                import { useState } from "react" <br>

                function InputExample() { <br>
                    const [name, setName] = useState('test') <br>
                    const nameChange = (event)=>setName(event.target.value)
              </code> fonksiyon buraya tanımlanır ve içeride kullanılır. <br>
              <code>
                    return( <br>
                        &lt;div> <br>
                            Please enter a name: &lt;br /> <br>
                            &lt;input value={name} onChange={nameChange}/> <br>

                            &lt;br /> <br>
                            {name} <br>
                        &lt;/div> <br>
                    ) <br>
                } <br>

                export default InputExample <br>
              </code>
            </p>
            <p>
              Birden fazla veri alıcak formlarda state'i object olarak vermek daha kullanışlı olacaktır. Bu sayede tek fonksiyon ile tüm formlarda onChange'den veri alınabilir.
              <code>
                import { useState } from "react" <br>

                function InputExample() { <br>
                    const [form, setForm] = useState({name:'', surname:''})
              </code> ile form statei içine name ve surname keyleri boş value ile atanır. <br>
              <code>
                    const formChange = (event)=> setForm({...form, [event.target.name]: event.target.value})
              </code> ile formdaki değişiklikleri takip edecek fonksiyon yazılır. state objenin key değeri formdaki name değeri ile aynı olmalıdır. <br>
              <code>
                    return( <br> 
                        &lt;div> <br>
                            Please enter a name: &lt;br /> <br>
                            &lt;input name='name' value={form.name} onChange={formChange}/> <br>
                            &lt;br /> <br>
                            Please enter a surnamename: &lt;br /> <br>
                            &lt;input name='surname' value={form.surname} onChange={formChange}/> <br>

                            &lt;br /> <br>
                            {form.name} {form.surname} <br>
                        &lt;/div> <br>
                    )
                } <br>

                export default InputExample <br>
              </code>
            </p>
          </div>
          <div class="row" id="useEffect">
            <h1>useEffect</h1>
            <p>
              kompanenetler DOM'a mount olduğu anda, state değiştiğinde, prop değiştiğinde veya unmount olduğunda bu durmları yakalayıp işlem yaptırabiliyoruz.
            </p>
            <p>
              kompanent içinde herhangi bir ifade değiştiğinde useEffect() çalışır.
            </p>
            <p class="alert alert-warning">
              useState(), useEffect() gibi hooklar kompanentin en başında olmalı ve herhangi bir koşul yapısıda olmamalı.
            </p>
            <p>
              <code>
                import { useState, useEffect } from "react";
              </code> ile useState ve useEffect import edilir. <br>
              <code>
                function App(){ <br>
  
                  const [age, setAge] = useState(33); <br>
                  const [name, setName] = useState('Murat'); <br>
                  
                  useEffect(()=>{ <br>
                    console.log('state güncellendi') <br>
                  })
              </code> herhangi bir state güncellendiğinde çalışır. <br>
              <code>
                useEffect(()=>{ <br>
                  console.log('Component mounted') <br>
                }, []);
              </code> [] bu şekilde boş ise komponentin mount edildiği anda çalışır. <br>
              <code>
                useEffect(()=>{ <br>
                  console.log('Age component update') <br>
                }, [age]);
              </code> age komponenti güncellendiği anda çalışır. <br>
              <code>
                useEffect(()=>{ <br>
                  console.log('Age veya name component update') <br>
                }, [age, name]); 
              </code> age veya name komponenti güncellendiği anda çalışır. <br>
              <code>
                return ( <br>
                    &lt;div> <br>
                        
                        &lt;h1> <br>
                        Age: {age} &lt;br /> <br>
                        &lt;button onClick={() => setAge(age + 1)}>+&lt;/button> <br>
                        &lt;button onClick={() => setAge(age - 1)}>-&lt;/button> <br>
                        &lt;/h1> <br>
                        &lt;h1> <br>
                        Name: {name} &lt;br /> <br>
                        &lt;button onClick={() => setName('Ahmet')}>değiş&lt;/button> <br>
                        &lt;/h1> <br>
                        
                    &lt;/div> <br>
                  );
                } <br>

                export default App;
              </code>
            </p>
          </div>
          <div class="row" id="componentUnmont">
            <h1>Component Unmount</h1>
            <p>
              src/components içinde Counter.js adında yeni dir dosya oluşturuyoruz ve useEffect ve useState fonksiyonunu import ediyoruz. 
            </p>
            <p>
              <code>
                function Counter() { <br>
                  const [count, setCount] = useState(0) <br>
              
                  useEffect(()=>{ <br>
                    console.log('count state update') <br>
                  },[count]) <br>
                  useEffect(()=>{ <br>
                    console.log('componet mounted') <br>
                     const interval = setInterval(()=>{ <br>
                      setCount((n) => n+1 <br>
                      )}, 1000);
              </code> bu kısım component mount edildiğinde çalışmaya başlar. <br>
              <code>
                    return () => clearInterval(interval)
              </code> useEffect içindeki returndan sonraki kısım component unmount edildiğinde çalışır. Bizim örneğimizde unmount olduğunda intervali durdurur. <br>
              <code>
                  },[]) <br>
              
                  const increase = () => {
                      setCount(count-1) 
                  } <br>
              
                  const decrease = () => {
                      setCount(count+1)
                  } <br>
                return ( <br>
                  &lt;div> <br>
                      &lt;h1>{count}&lt;/h1> <br>
                      &lt;button onClick={decrease}>Decrease&lt;/button> <br>
                      &lt;button onClick={increase}>Increase&lt;/button> <br>
                  &lt;/div> <br>
                  ) 
                } <br>
                
                export default Counter <br>
              </code>
            </p>
            <p>
              useState ve yeni oluşturduğumuz Counter kompanenti App.js içine import edilir ve sonra: <br>
              <code>
                function App() { <br>
                  const [isVisible, setIsVisible] = useState(true) <br>
                  return ( <br>
                    &lt;div> <br>
                      {isVisible && &lt;Counter />} <br>
                      &lt;button onClick={() => setIsVisible(!isVisible)}>change visible&lt;/button>
              </code> ile butona her basıldığında isVisible değeri değişir. Buna bağlı olarak da Counter mount veya unmount edilir. <br>
              <code>
                    &lt;/div> <br> 
                  ); 
                } <br>
                
                export default App; <br>
              </code>
            </p>
          </div>
          <div class="row" id="contactsApp">
            <h1>Contacts App</h1>
            <p>
              terminale <code>npx create-react-app contacts-app</code> ile yeni bir proje başlattık.
            </p>
            <p>
              src/components/Contacts dosyası oluşturuldu. içine index.js oluşturuldu.
            </p>
            <p>
              .../Contacts/Form ve .../Contacts/List dosyaları oluşturuldu ve her birinin içine index.js oluşturuldu. her iki index.js içinde de birer component tanımlandı ve bunlar .../Contacts/index.js içine import edildi.
            </p>
            <p>
              .../Contacts/index.js içinde bir component oluşturuldu ve içinde import edilen diğer iki component kullanıldı. Oluşan bu component de App.js içinde import edilip kullanıldı.
            </p>
            <p>
              Bu noktaya kadar yazılan componentlerin içine sadece temsili bilgiler girildi.
            </p>
          </div>
          <div class="row" id="contactsForm">
            <h1>Form Component'inin Geliştirilmesi</h1>  
            <p>
              Form/index.js içindeki kompanenetin return kısmında bir form içinde iki tane input bir tane de buton oluşturduk.
            </p>
            <p>
              kompanentin içinde bir form adında obje özellikli bir state oluşturduk. Bu objedeki keyler ile input name değerleri aynı adı taşıyor. 
            </p>
            <p>
              inputlardan gelen event.target.value değerini setForm ile alması için bir fonksiyon yazıp input onChange özelliğine dahil ettik.
            </p>
            <p>
              Contacts/index.js içinde contacts adında array bir state oluşturup hem kendisini hem de değiştirme fonksiyonunu props olarak Form/index.js deki fonksiyona gönderdik.
            </p>
            <p>
              Gelen değiştirme fonksiyonunu form submit sırasında kullanılacak bir fonksiyona dahil ettik. Bu sayede formdan gelen bilgiyi contacts içine ekledik.
            </p>
            <p>
              submit sonrası formu temizlemek için setForm fonksiyonunu kullandık. Bunu ister submt içinde ister useEffect içinde kullanabiliriz.
            </p>
            <p>
              Form/index.js son hali: <br>
              <code>
                import { useEffect, useState } from "react"; <br>

                function Form({ addContacts, contacts }) {
              </code> ile props olarak gelen state karşılanır. <br>
              <code>
                  const [form, setForm] = useState({ fullname: "", phone_number: "" }); <br>
              
                  useEffect(()=>{ <br>
                    setForm({ fullname: "", phone_number: "" }) <br>
                  },[contacts])
              </code> ile form içeriği sıfırlanır. <br>
              <code>
                  const onChangeInput = (e) => { <br>
                    setForm({ ...form, [e.target.name]: e.target.value }); <br>
                  };
              </code> inputa değer girildiğinde form statine dahil eden fonksiyon. input içinde onChange ile kullanılıyor. <br>
              <code>
                  const onSubmit = (e) => {
              </code> form submit edildiğinde kullanılan fonksiyon. <br>
              <code>
                    e.preventDefault();
              </code> formun submit sırasında kullandığı default işlemi engeller. Bu olmazsa submit işlemi adres çubuğunda query ile sonlanır.<br>
              <code>
                    if(form.fullname === ''|| form.phone_number ===''){ <br>
                      return false; <br>
                    }
              </code> formda boş kalan yer varsa işlemi sonlandırır. <br>
              <code>
                    addContacts([...contacts, form]) <br>
                    console.log(form); <br>
                    // setForm({ fullname: "", phone_number: "" })
              </code> işi biten formu sıfırlama işlemi burada da yapılabilir. <br>
              <code>
                  }; <br>

                  return ( <br>
                    &lt;form onSubmit={onSubmit}>
              </code> onSubmit fonksiyonu burada kullanıır. <br>
              <code>
                      &lt;div> <br>
                        &lt;input
                          name="fullname"
                          placeholder="Full Name"
                          value={form.fullname}
                          onChange={onChangeInput}
                        /> <br>
                      &lt;/div> <br>
                      &lt;div> <br>
                        &lt;input
                          name="phone_number"
                          placeholder="Phone Number"
                          value={form.phone_number}
                          onChange={onChangeInput}
                        /> <br>
                      &lt;/div> <br>
                      &lt;div> <br>
                        &lt;button>Add&lt;/button> <br>
                      &lt;/div> <br>
                    &lt;/form> <br>
                  );
                } <br>

                export default Form;

              </code>
            </p>
            <p>
              Contacts/index.js son hali: <br>
              <code>
                import {useState, useEffect} from 'react' <br>

                import List from "./List"; <br>
                import Form from "./Form"; <br>

                function Contacts() { <br>
                  const [contacts, setContacts] = useState([]); <br>

                  useEffect(()=>{ <br>
                    console.log(contacts) <br>
                  },[contacts]) <br>
                  return ( <br>
                    &lt;div>contacts <br>
                        &lt;List /> <br>
                        &lt;Form addContacts={setContacts} contacts={contacts}/> <br>
                    &lt;/div> <br>
                  )
                } <br>
                export default Contacts
              </code>
            </p>
            <p>
              contacts statei daha sonra listeleme işleminde de kullanılacak. Bu nedenle üst companenette oluşturulup props olarak alt companente göndeildi.
            </p>
          </div>
          <div class="row" id="contactsList">
            <h1>Kayıtların Listelenmesi</h1>
            <p>
              Contacts/index.js içinde contacts statei List companentine prop olarak gönderildi. <br>
              <code>
                &lt;List contacts={contacts}/>
              </code>
            </p>
            <p>
              List/index.js içinde gönderilen prop kullanıldı. <br>
              <code>
                import {useState} from 'react' <br>

                function List({ contacts }) { <br>
                  return ( <br>
                    &lt;div> <br>
                      &lt;ul> <br>
                        { <br>
                          contacts.map((contact, i)=>( <br>
                            &lt;li key={i}>{contact.fullname}&lt;/li> <br>
                          )) <br>
                        } <br>
                      &lt;/ul> <br>
                    &lt;/div> <br>
                  )
                } <br>

                export default List
              </code>
            </p>
          </div>
          <div class="row" id="contactsFilter">
            <h1>Filtreleme İşlemi</h1>
            <p>
              İşlemi rahat takip edebilmek için Contacts/index.js içinde contacts stateine default değerler atandı.
            </p>
            <p>
              List/index.js içinde filterText statei oluşturuldu. 
            </p>
            <p>
              Filter inputu oluşturuldu. value olarak filterText onChange fonksiyonu olarak da setFilterText atandı. Bu sayede input değeri filterText stateine atanmış oldu.
            </p>
            <p>
              filtered adında bir değişkene contacts üzerinden filter() metodu ile filtreleme yapıldı.
            </p>
            <p>
              return içindeki contents.map() işlemi filtered.map() olarak güncellendi. 
            </p>
            <p>
              List/index.js List companetinin güncel hali: <br>
              <code>
                function List({ contacts }) { <br>
                  const [filterText, setFilterText] = useState(""); <br>
                  const filtered = contacts.filter((item) => {
              </code> filter() fonksiyonu array içindeki her bir item için döner. item ile bu itemler yakalanır. Fonksiyon sonunda true dönenler filtered değişkenine atanır.<br>
              <code>
                    return Object.keys(item).some((key) => (
              </code> yakalanan itemler obje yapısındadır. Object.keys(item) ile her bir key yakalanır. some() içindeki değerlerden biri true ise true döner. <br>
              <code> 
                      item[key]
              </code> ile value yakalanır. <br>
              <code>
                      .toString()
              </code> ile stringe çevirilir. <br>
              <code>
                      .toLowerCase()
              </code>ile tamamı küçük harfe çevrilir. aynı işlem karşılaştırılacağı değere de yapılır. Bu sayede büyük-küçük harf duyarlılığı yaşanmaz. <br>
              <code>
                      .includes(filterText.toLowerCase()) <br>
                    )); <br>
                  }); <br>
                  
                  return ( <br>
                    &lt;div> <br>
                      &lt;input <br>
                        placeholder="Filter contact" <br>
                        value={filterText} <br>
                        onChange={(e) => setFilterText(e.target.value)} <br>
                      /> <br>
                
                      &lt;ul> <br>
                        {filtered.map((contact, i) => (
              </code> ile filtrelenen değerler yazdırılır. <br>
              <code>
                          &lt;li key={i}>{contact.fullname}&lt;/li> <br> 
                        ))} <br>
                      &lt;/ul> <br>
                    &lt;/div> <br>
                  );
                }
              </code>
            </p>
          </div>
          <div class="row" id="contactsStil">
            <h1>Stil Tanımlarının Yapılması</h1>
            <p>
              css dosyası oluşturup kullanacağımız kompanentin yazıldığı js dosyasına import etmemiz gerekiyor. <br>
              <code>
                import './App.css';
              </code> gibi.
            </p>
            <p>
              Bundan sonraki kısım bildiğiniz css. Css kodlarının çalışması için companent içinde ilgili kısımlara class ve id atıyoruz. <br>
              örnek: <br>
              <code>
                &lt;div className="btn"> <br>
                &lt;ul className="list"> <br>
                &lt;div id='container'>
              </code>
            </p>
          </div>
          <div class="row" id="stilTanimi">
            <h1>Stil Tanımı Yapmak</h1>
            <p>
              Css dosyasını <code>import "./App.css";</code> şeklinde import edebiliriz.
            </p>
            <p>
              Return içinde (JSX) inline style tanımlarını süslü parantez içine obje olarak verebiliriz. <br>
              <code>
                &lt;div style={{ color: "red", backgroundColor: "white" }}>&lt;/div>
              </code> <br>
              js içerisinde tire (-) işareti tanımlamalarda kullanılmadığından stil etiketleri camelcase olarak yazılır. <br>
              background-color yerine <code>backgroundColor</code> <br>
              padding-top yerine <code>paddinTop</code> vs
            </p>
            <p>
              Bootstrap gibi dış kaynak eklemek için: index.html içinde head kısmına yerleştirilebilir.
            </p>
          </div>
          <div class="row" id="moduleCss">
            <h1>Module CSS</h1>
            <p>
              Aynı class ismine sahip farklı companenetler için stil dosyası özellikleri çakışması sonucu stil bilgisi düzgün çalışmıyor. Her birinin kendi style.css dosyasına da tanım girilse react hepsini tek yerde topladığı için, çakışma sorunu çözülmüyor.
            </p>
            <p>
              Burada çözüm olarak module.css kavramı devreye giriyor. <br>
              <table>
                <tr>
                  <th></th>
                  <th>css</th>
                  <th>module.css</th>
                </tr>
                <tr>
                  <th>Dosya Adı</th>
                  <td>styles.css</td>
                  <td>styles.module.css</td>
                </tr>
                <tr>
                  <th>Import</th>
                  <td>import "./styles.css"</td>
                  <td>import styles from "./styles.module.css"</td>
                </tr>
                <tr>
                  <th>className</th>
                  <td>className="title"</td>
                  <td>className={styles.title}</td>
                </tr>
              </table>
            </p>
          </div>
          <div class="row" id="nativeFetch">
            <h1>Native Fetch</h1>
            <p>
              Başka bir kaynaktaki veriyi alıp sayfamızda gösterme işlemi. Bunun için veriyi <a href="https://jsonplaceholder.typicode.com/">https://jsonplaceholder.typicode.com/</a> adresinden alacağız.
            </p>
            <p>
              Önce src/components içine Users.js dosyası oluşturuldu.
            </p>
            <p>
              içine users statei oluşturuldu. fetch işlemi ile yakalanan veri setUsers ile yakalandı ve return içinde kullanıldı.
            </p>
            <p>
              Yükleme tamamlanana kadar loading... yazması için isLoading statei oluşturuldu ve default değer true atandı. 
            </p>
            <p>
              Koşul olarak isLoading true iken çalışacak şekilde return içinde "Loading..." yazısı eklendi. 
            </p>
            <p>
              fetch işleminin sonuna setIsLoading(false) yerleştirilerek fetch sonrası "Loading..." yazısının kalkması sağlandı.
            </p>
            <p>
              kompanent App.js içine import edilir.
            </p>
            <p>
              Users.js içindeki kod: <br>
              <code>
                import { useEffect, useState } from 'react' <br>

                function Users() { <br>
                  const [users, setUsers] = useState([]); <br>
                  const [isLoading, setIsLoading] = useState(true) <br>

                  useEffect(()=>{ 
              </code> component mount edilirken fetch işlemi başlasın <br>
              <code>
                    fetch("https://jsonplaceholder.typicode.com/users")
              </code> ile veri alınır. <br>
              <code>
                    .then(res => res.json())
              </code> ile kullanılabilir hale getirilir. <br>
              <code>
                    .then(data => setUsers(data))
              </code> ile users stateine set edilir. <br>
              <code>
                    .catch((e) => console.log(e)) <br>
                    .finally(() => setIsLoading(false));
              </code> ile isLoading false değeri alır. <br>
              <code>
                  },[]) <br>

                  return ( <br>
                    &lt;div> <br>
                      &lt;h1>Users&lt;/h1> <br>

                      {isLoading && &lt;div>Loading...&lt;/div>}
              </code> isLoading true ise Loading... yazar. <br>
              <code>
                      {users.map((user)=>( <br>
                        &lt;p key={user.id}>{user.name}&lt;/p> <br>
                      ))} <br>
                    &lt;/div> <br>
                  )
                } <br>

                export default Users
              </code>
            </p>
          </div>
          <div class="row" id="axios">
            <h1>Axios</h1>
            <p>
              fetch işlemi için kullanılan bir diğer kütüphane. fetch ile farkları için: <a href="https://www.geeksforgeeks.org/difference-between-fetch-and-axios-js-for-making-http-requests/">tıklayınız</a>
            </p>
            <p>
              axiosda body obje olarak döner.
            </p>
            <p>
              terminale:
              <code>
                npm i axios
              </code> yazılır ve kompanente import edilir.
            </p>
            <p>
              yukarıda fetch ile yazılan kodun axios versiyonu: <br>
              <code>
                useEffect(()=>{ <br>
                  axios("https://jsonplaceholder.typicode.com/users") <br>
                  .then(res => setUsers(res.data)) 
              </code> gelen response içinde data bizim istediğimiz asıl veriyi verir. <br>
              <code>
                  .catch((e) => console.log(e)) <br>
                  .finally(() => setIsLoading(false)); <br>
                },[])
              </code>
            </p>
          </div>
          <div class="row" id="routingKurulum">
            <h1>React Router Kurulum</h1>
            <p>
              <a href="https://reactrouter.com/en/main">reactrouter.com</a> <br>
              <a href="https://v5.reactrouter.com/web/guides/quick-start">v5.reactrouter.com/web/guides/quick-start</a>
            </p>
            <p>
              terminale: <br>
              <code>
                npm i react-router-dom
              </code>
            </p>
            <p>
              video react-router-dom.v5 ile oluşturulmuş. Güncel versiyon react-router-dom.v6. Video ile birebir gidebilmek için terminale: <br>
              <code>
                npm install react-router-dom@5
              </code>
            </p>
            <p>
              Biz yeni versiyon ile devam edeceğiz. Bu <a href="https://reactrouter.com/en/v6.3.0/getting-started/installation">link</a> çok faydalı
              <ul>
                <li>İmport ederken Switch metodu yerine Routes metodu import edilecek</li>
                <li>Routes içindeki Route söz dizimi biraz daha farklı: <br> <code>&lt;Route path="/about">&lt;About />&lt;/Route></code> <br> yerine <br> <code>&lt;Route path="/about" element={&lt;About/>}/></code></li>
              </ul> 
            </p>
            <p>
              Sayfaları bu şekilde tanımladığımızda bütün sayfa değil sadece değişecek kısım re-render edilir.
            </p>
            <p>
              <ul>React router dom kullanabilmek için
                <li>en dışa: <b>Router</b> (BrowserRouter) etiketiyle yazılır.</li>
                <li> re-render edilecek kısmın linki <br>Link etiketiyle yazılır. Örn: <code>&lt;Link to="/">Home&lt;/Link></code></li>
                <li>render edilecek alan <b>Routes</b> etiketinin altına yazılır. (Daha önceki versiyonda Switch kullanılıyor.) Burada koşul belirtilir. Uygun koşula ait kısım render edilir.</li>
                <li> Routes içine koşullar <b>Route</b> etiketi ile yazılır. Örn: <code>&lt;Route path="/about" element={&lt;About/>}/></code> Bu örnekte çalıştırılan path "/about" ise &lt;About/> kompanenti render edilir.</li>
              </ul>
            </p>
          </div>
          <div class="row" id="exactProp">
            <h1>Exact Prop</h1>
            <p>
              v6 için gerekli değil.
            </p>
            <p>
              v5 te Switch etiketi içinde yazılan path yukarıdan aşağı doğru taranır. İlk eşleşmede değeri getirir. Bu nedenle path="/" üstteyse path="/..." olanlara geçmez. bunu engellemek için exact probu kullanılır.
            </p>
          </div>
          <div class="row" id="urlParameters">
            <h1>URL Parameters</h1>
            <p>
              Bütün fonksiyonlar companent/Rooting adında kendi .js dosyalarına taşındı ve App.js içine import edildi.
            </p>
            <p>
              User.js kompanenti oluşturuldu ve import edildi.
            </p>
            <p>
              App.js Routes alanına ilgili route yazıldı. <br>
              <code>
                &lt;Route path="/users/:id" element={&lt;User />} />
              </code> bu sayede id değişkeni olan durumlarda User kompanenti kullanılacak. Burayda id yerine yazılan değer de User kompanentinde yakalanacak.
            </p>
            <p>
              Users içinde fake api den alınan bilgi kullanıldı ve tekil User sayfaları için link oluşturuldu. <br>
              <code>
                import axios from "axios"; <br>
                import { useEffect, useState } from "react"; <br>
                import { Link } from "react-router-dom"; <br> <br>

                function Users() { <br>
                  const [users, setUsers] = useState([]); <br>
                  const [loading, setLoading] = useState(true);
              </code>Loading... yazısı için <br><br>
              <code>

                  useEffect(() => { <br>
                    axios("https://jsonplaceholder.typicode.com/users") <br>
                      .then((res) => setUsers(res.data)) <br>
                      .catch((e) => console.log(e)) <br>
                      .finally(() => setLoading(false)); <br>
                  }, []); <br><br>
                  return ( <br>
                    &lt;div> <br>
                      &lt;h1>Users&lt;/h1> <br>
                      {loading && &lt;div>Loading...&lt;/div>} <br>
                      &lt;ul> <br>
                        {users.map((user) => ( <br>
                          &lt;li key={user.id}> <br>
                            &lt;Link to={`/users/${user.id}`}>{user.name}&lt;/Link>
              </code> user.id params olarak gönderildi. User tekil sayfasında tutulup kullanılacak. <br>
              <code>
                          &lt;/li> <br>
                        ))} <br>
                      &lt;/ul> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default Users;

              </code>
            </p>
            <p>
              user içinde :id parametresi yakalandı ve axios içinde ilgili veriyi çekmek için kullanıldı.
            </p>
            <p>
              Her id değiştiğinde sayfanın useEffect çalıştırması için dependency array içine id eklendi.
            </p>
            <p>
              User.js <br>
              <code>
                import { useParams } from "react-router-dom"; <br>
                import { useState, useEffect } from "react"; <br>
                import axios from "axios"; <br>
                import Users from "./Users"; <br>
                import { Link } from "react-router-dom"; <br><br>

                function User() { <br>
                  const [user, setUser] = useState({}); <br>
                  const [loading, setLoading] = useState(true); <br><br>

                  const { id } = useParams();
              </code>Bağlantıdan gelen params yakalandı. <br><br>
              <code>

                  useEffect(() => { <br>
                    axios(`https://jsonplaceholder.typicode.com/users/${id}`) <br>
                      .then((res) => setUser(res.data)) <br>
                      .catch((e) => console.log(e)) <br>
                      .finally(() => setLoading(false)); <br>
                  }, [id]); 
              </code> dependency array alanına id girildi ki bu işlem her id değiştiğinde yenilensin. <br> <br>
              <code>
                  return ( <br>
                    &lt;div> <br>
                      {loading && &lt;div>Loading...&lt;/div>} <br>
                      &lt;h1>User Detail&lt;/h1> <br>
                      &lt;p>Name: {user.name}&lt;/p> <br>
                      &lt;p>Email: {user.email}&lt;/p> <br>
                      {!loading && &lt;code>{JSON.stringify(user)}&lt;/code>} <br>
                      &lt;p>id: {id}&lt;/p> <br>
                      &lt;Link to={`/users/${parseInt(id) + 1}`}> 
              </code> toplama işleminin yapılabilmesi için string yapıdaki id integer olarak değiştirildi. <br>
              <code>
                        Next User ({parseInt(id) + 1}) <br>
                      &lt;/Link> <br>
                    &lt;/div> <br>
                  );
                } <br>

                export default User;

              </code>
            </p>
          </div>
          <div class="row" id="nesting">
            <h1>Nesting</h1>
            <p>
              Mevcut kompanent açık kalırken ona bağlı başka bir kompanentin yüklenmesi işlemi.
            </p>
            <p>
              v6 ya göre yapımı için: <a href="https://ui.dev/react-router-nested-routes">tıklayın</a>
            </p>
            <p>
              İlk önce App.js içindeki Routes alanında child olan kompanenti ayarlıyoruz. <br>
              <code>
                &lt;Routes> <br>
                &ensp;&lt;Route path="/about" element={&lt;About/>}/> <br>
                &ensp;&lt;Route path="/" element={&lt;Home />} /> <br>
                &ensp;&lt;Route path="/users/*" element={&lt;Users/>}> <br>
                &emsp;&emsp;&lt;Route path=":id" element={&lt;User />} />
              </code> bu kısım child kompanente ait. path kısmına da parent kompanentin devamına gelecek kısım yazılır. <br>
              <code>
                &ensp;&lt;/Route> <br>
                &lt;/Routes> 
              </code>
            </p>
            <p>
              Daha sonra Users.js içine Outlet fonksiyonu "react-router-dom" üzerinden import edilir. <br>
              <code>
                import { Link, Outlet} from "react-router-dom";
              </code>
            </p>
            <p>
              Child kompanentin olmasını istediğimiz yere kompanent yazar gibi <code>&lt;Outlet/></code> eklenir. <br>
              <code>
                ... <br>
                return( <br>
                ... <br>
                &lt;Outlet/> <br>
                ...<br>
                )
              </code>
            </p>
          </div>
          <div class="row" id="navlink">
            <h1>NavLink</h1>
            <p>
              Link etiketinden farklı olarak aktif olma durumunu da veriyor. Buna göre de aktif olan link özelleştirilebiliyor.
            </p>
            <p>
              <code>
                aktif olduğunda kullanılacak stil verisi jsx yapısına uygun şekilde bir obje olarak bir değişkene atanır.
              </code>
              <code>
                &lt;NavLink style={({isActive}) => isActive ? activeStyle: undefined} to="/">Home&lt;/NavLink>
              </code> ile style içinde isActive durumu için koşul oluşturulur. Koşul doğru ise daha önceden hazırlanan activeStyle değişkenindeki değer kullanılır.
            </p>
            <p>
              Aynı işlem className için de yapılabilir.
            </p>
          </div>
          <div class="row" id="noMatch">
            <h1>No Match (404)</h1>
            <p>
              Varolan sayfaların dışında kalan tüm path değişkenleri için App.js Routes içine: <br>
              <code>
                &lt;Route path="*" element={&lt;Error404 />} />
              </code> eklenir. Error404 adlı kompanent yaratılır ve App.js içine import edilir. 
            </p>
          </div>
          <div class="row" id="formikKurulum">
            <h1>Formik Kurulum</h1>
            <p>
              Yeni bir react projesi oluşturduk. <br>
              <code>
                npx create-react-app formik
              </code>
            </p>
            <p>
              formik paketi projeye dahil edilir. <br>
              <code>
                npm i formik
              </code>
            </p>
            <p>
              formik dökümantasyonu için <a href="https://formik.org/docs/overview">tıklayınız</a>
            </p>
            <p>
              App.js içinde kullanılır. <br>
              <code>
                import React from 'react'; <br>
                import { Formik, Field, Form } from 'formik';
              </code> ile formik bileşenleri import edilir. <br>
              <code>
                import './App.css'; <br><br>

                function App() { <br>
                  return ( <br>
                    &lt;div className="App"> <br>
                      &lt;h1>Sign Up&lt;/h1> <br>
                    &lt;Formik
              </code> Formik yapıları bu etiketin arasına kurgulanır. Açılış etiketine de gerekli formüller yazılır. <br>
              <code>
                      initialValues={{
              </code> Bu alana state yapısındaki gibi alınacak verinin boş halini giriyoruz. <br>
              <code>
                        firstName: '', <br>
                        lastName: '', <br>
                        email: '', <br>
                      }} <br><br>
                      
                      onSubmit={(values) => {
              </code> input edilen değerlere ne yapılacağını belirleyen fonksiyon <br>
              <code>
                        console.log(values); <br>
                      }}
                    > <br><br>
                      
                      &lt;Form>
              </code> Formik yapısının Form oluşturma etiketi. <br>
              <code>
                        &lt;label htmlFor="firstName">First Name&lt;/label> <br>
                        &lt;Field id="firstName" name="firstName" placeholder="Jane" />
              </code> Field bize inpup yaratıyor. Field alanındaki name ile initialValues alanındaki key aynı olmalı. id önemli değil. <br>
              <code>
                        &lt;br />
                        &lt;br /> <br>

                        &lt;label htmlFor="lastName">Last Name&lt;/label> <br>
                        &lt;Field id="lastName" name="lastName" placeholder="Doe" /> <br>
                        &lt;br />
                        &lt;br /> <br>

                        &lt;label htmlFor="email">Email&lt;/label> <br>
                        &lt;Field
                          id="email"
                          name="email"
                          placeholder="jane@acme.com"
                          type="email"
                        /> <br>
                        &lt;br />
                        &lt;br /> <br>
                        &lt;button type="submit">Submit&lt;/button> <br>
                      &lt;/Form> <br>
                    &lt;/Formik> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default App;

              </code>
            </p>
          </div>
          <div class="row" id="handleSubmitHandleChange">
            <h1>handleSubmit & handleChange</h1>
            <p>
              Formik yapısındaki Form - Field yapısı yerine html yapısında kullanılan form-input yapısını kullanamabilmek için kullanılır.
            </p>
            <p>
              Bir önceki sayfada yazılan kodun handleSubmit ve handleChange ile düzenlenmişi:
              <code>
                import React from 'react'; <br>
                import { Formik } from 'formik';
              </code> Form ve Field kısnmına gerek kalmadı. <br>
              <code>
                import './App.css'; <br><br>

                function App() { <br>
                  return (br
                    &lt;div className="App"> <br>
                      &lt;h1>Sign Up&lt;/h1> <br>
                    &lt;Formik <br>
                      initialValues={{ <br>
                        firstName: '', <br>
                        lastName: '', <br>
                        email: '', <br>
                      }} <br><br>
                      
                      onSubmit={(values) => { <br>
                        console.log(values); <br>
                      }} 
                    > <br>
                      {({handleSubmit, handleChange }) => (
              </code> parametre olarak handleSubmit, handleChange kullanılan bir fonksiyon return edilir. Bu iki fonksiyon Formik modülünde tanımlıdır. <br>
              <code>
                        &lt;form onSubmit={handleSubmit}>
              </code> handleSubmit fonksiyonu onSubmit işlemine atanır. <br>
              <code>
                        &lt;label htmlFor="firstName">First Name&lt;/label> <br>
                        &lt;input name="firstName" onChange={handleChange}/> 
              </code> handleChange fonksiyonu onChange işlemine atanır. <br>
              <code>
                      
                        &lt;br />
                        &lt;br /> <br>

                        &lt;label htmlFor="lastName">Last Name&lt;/label> <br>
                        &lt;input name="lastName" onChange={handleChange}/> <br>
                        
                        &lt;br />
                        &lt;br /> <br>

                        &lt;label htmlFor="email">Email&lt;/label> <br>
                        &lt;input name="email" type="email" onChange={handleChange}/> <br>
                        &lt;br />
                        &lt;br /> <br>
                        &lt;button type="submit">Submit&lt;/button> <br>
                      &lt;/form> <br>
                      )} <br>
                      
                    &lt;/Formik> <br>
                    &lt;/div> <br>
                  ); 
                } <br><br>

                export default App;
              </code>
            </p>
          </div>
          <div class="row" id="radioCheckboxDropdown">
            <h1>Radio / Checkbox / Dropdown</h1>
            <p>
              forma eklenecek bilgilerin alınabilmesi için formda name keyine karşılık gelen value initialValues alanına eklenmeli. <br>
              <code>
                ... <br>
                &lt;Formik <br>
                  initialValues={{ <br>
                    firstName: "", <br>
                    lastName: "", <br>
                    email: "drmuratgokduman@gmail.com", 
              </code> formda varsayılan olarak gelmesini istediğimiz değer varsa bu şekilde yazabiliriz. bunu da value={values.email} ile formda yakalayabiliriz. <br>
              <code>
                    gender: "male", <br>
                    hobies: [], <br>
                    county: "tr", <br>
                  }} <br>
                  ... <br>
              </code>
            </p>
            <p>
              Formda yaptığımız değişiklerin etkisini görmek için: <br>
              <code>
                ... <br>
                          <u>&lt;code>{JSON.stringify(values)}&lt;/code></u> <br>
                    &lt;/form> <br>
                  )} <br>
                &lt;/Formik> <br>
                ... <br>
              </code>
            </p>
            
            <h2>Radio</h2>
            <p>
              <code>
                ... <br>
                &lt;span>Male&lt;/span> <br>
                &lt;input <br>
                  type={"radio"} <br>
                  name="gender" 
              </code> initialValues alanı ile eşleşecek. <br>
              <code>
                  value={"male"}
              </code> seçilirse forma gönderilecek veri <br>
              <code>
                  onChange={handleChange} <br>
                  checked={values.gender === "male"}
              </code> form varsayılanı olarak initialValues içinde girilen değerin form açıldığında seçili gelmesini sağlar. <br>
              <code>
                /> <br>
                &lt;span>Female&lt;/span> <br>
                &lt;input <br>
                  type={"radio"} <br>
                  name="gender" <br>
                  value={"female"} <br>
                  onChange={handleChange} <br>
                  checked={values.gender === "female"} <br>
                  ... <br>
              </code>
            </p>

            <h2>Checkbox</h2>
            <p>
              <code>
                &lt;div> <br>
                  &lt;input <br>
                    type="checkbox" <br>
                    name="hobies" <br>
                    value="Play Playstation" <br>
                    onChange={handleChange} <br>
                  /> <br>
                  Play Playstation <br>
                &lt;/div> <br><br>
                &lt;div> <br>
                  &lt;input <br>
                    type="checkbox" <br>
                    name="hobies" <br>
                    value="Read a Book" <br>
                    onChange={handleChange} <br>
                  /> <br>
                  Read a Book <br>
                &lt;/div> <br><br>
                &lt;div> <br>
                  &lt;input <br>
                    type="checkbox" <br>
                    name="hobies" <br>
                    value="Write Code" <br>
                    onChange={handleChange} <br>
                  /> <br>
                  Write Code <br>
                &lt;/div>
              </code>
            </p>

            <h2>Dropdown</h2>
            <p>
              <code>
                &lt;select name="coutry" value={values.county} onChange={handleChange}>
              </code> value={values.county} ile formda değişiklik yoksa default değer kullanılır. <br>
              <code>
                  &lt;option value="tr">Turkey&lt;/option> <br>
                  &lt;option value="en">England&lt;/option> <br>
                  &lt;option value="usa">USA&lt;/option> <br>
                &lt;/select>
              </code>
            </p>
          </div>
          <div class="row" id="useFormik">
            <h1>useFormik</h1>
            <p>
              Formu &lt;Formik> etiketi ile sarmalamadan formik yapısı kullanmak için useFormik hooku kullanılabilir. 
            </p>

            <p>
              returndan önceki tanımlama kısmına <br>
              <code>
                const Formik = useFormik({ <br>
                  initialValues: { <br>
                    firstName: "", <br>
                    ... <br>
                  } <br>
                  onSubmit: (values) => { <br>
                    console.log(values); <br>
                  }, <br>
                })
              </code> yazılır. form içinde kullanılan diğer hooklar <br>
              <code>
                <b>handleSubmit</b>: Formik.handleSubmit <br>
                <b>handleChange</b>: Formik.handleChange 
              </code> gibi kullanılabilir. <br>
              veya tanımda Formik yerine yazılarak daha önce kullanıldıkları halleri ile kullanılabilirler. <br>
              <code>
                const { handleSubmit, handleChange, values } = useFormik({ ...
              </code>
            </p>
            <p>
              Daha önceki konularda oluşturduğumuz formun useFormik ile yazılmış hali: <br>
              <code>
                import React from "react"; <br>
                import { useFormik } from "formik";
              </code>ile useFormik import edilir. <br>
              <code>
                import "./App.css"; <br><br>

                function App() { <br>
                  const { handleSubmit, handleChange, values } = useFormik({
              </code> ile tanımlamalar yapılır. <br>
              <code>
                    initialValues: { <br>
                      firstName: "", <br>
                      lastName: "", <br>
                      email: "drmuratgokduman@gmail.com", <br>
                      gender: "male", <br> 
                      hobies: [], <br>
                      county: "tr", <br>
                    }, <br>
                    onSubmit: (values) => { <br>
                      console.log(values); <br>
                    }, <br>
                  }); <br><br>

                  return ( <br>
                    &lt;div className="App">
              </code> Form &lt;Formik> etiketi kullanılmadan yazılır. <br>
              <code>
                      &lt;/div> <br>
                      &lt;h1>Sign Up&lt;/h1> <br>

                      &lt;form onSubmit={handleSubmit}> <br>
                        &lt;label htmlFor="firstName">First Name&lt;/label> <br>
                        &lt;input name="firstName" onChange={handleChange} /> <br>

                        &lt;br /> 
                        &lt;br /> <br>

                        &lt;label htmlFor="lastName">Last Name&lt;/label> <br>
                        &lt;input name="lastName" onChange={handleChange} /> <br>

                        &lt;br />
                        &lt;br /> <br>

                        &lt;label htmlFor="email">Email&lt;/label> <br>
                        &lt;input
                          name="email"
                          type="email"
                          value={values.email}
                          onChange={handleChange}
                        /> <br>
                        &lt;br />
                        &lt;br /> <br>

                        &lt;span>Male&lt;/span> <br>
                        &lt;input
                          type={"radio"}
                          name="gender"
                          value={"male"}
                          onChange={handleChange}
                          checked={values.gender === "male"}
                        /> <br>
                        &lt;span>Female&lt;/span> <br>
                        &lt;input
                          type={"radio"}
                          name="gender"
                          value={"female"}
                          onChange={handleChange}
                          checked={values.gender === "female"}
                        /> <br>
                        &lt;br />
                        &lt;br /> <br>

                        &lt;div> <br>
                          &lt;input
                            type="checkbox"
                            name="hobies"
                            value="Play Playstation"
                            onChange={handleChange}
                          /> <br>
                          Play Playstation <br>
                        &lt;/div> <br>
                        &lt;div> <br>
                          &lt;input
                            type="checkbox"
                            name="hobies"
                            value="Read a Book"
                            onChange={handleChange}
                          /> <br>
                          Read a Book <br>
                        &lt;/div> <br>
                        &lt;div> <br>
                          &lt;input
                            type="checkbox"
                            name="hobies"
                            value="Write Code"
                            onChange={handleChange}
                          /> <br>
                          Write Code <br>
                        &lt;/div> <br>

                        &lt;br />
                        &lt;br /> <br>

                        &lt;select name="coutry" value={values.county} onChange={handleChange}> <br>
                          &lt;option value="tr">Turkey&lt;/option> <br>
                          &lt;option value="en">England&lt;/option> <br>
                          &lt;option value="usa">USA&lt;/option> <br>
                        &lt;/select> <br>
                        &lt;br />
                        &lt;br /> <br>
                        &lt;button type="submit">Submit&lt;/button> <br>
                        &lt;br />
                        &lt;br /> <br>
                        &lt;code>{JSON.stringify(values)}&lt;/code> <br>
                      &lt;/form> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default App;

              </code>
            </p>

          </div>
          <div class="row" id="formValidasyon">
            <h1>Form Validasyonları (yup)</h1>
            <p>
              Validasyon çalışması için formumuzu email, password ve confirm password imputlarıyla ouşturduk. 
            </p>
            <p>
              Validasyon işlemini <q>yup</q> paketi ile yapacağız. Bunun için terminale:<br>
              <code>
                npm i yup
              </code>
            </p>
            <p>
              App.js içindeki kompanent src/components/Singup.js içine taşındı ve App.js içinde import edilerek kullanıldı.
            </p>
            <p>
              src/components/validations içinde validasyon işlemi tanımlandı ve export edildi. <br>
              <code>
                import * as yup from "yup"; <br><br>

                const validations = yup.object().shape({
              </code> validasyon kuralları yup içinde obje olarak tanımlanır. <br>
              <code>
                  email: 
              </code> buradaki key ler valide edilecek formun initialValues alanındakiler ile aynı olmalı. <br>
              <code>
                  yup.string()
              </code> string yapıda <br>
              <code>
                  .email()
              </code> email formatında <br>
              <code>
                  .required(),
              </code> ve zorunlu olarak doldurulacak. <br>
              <code>
                  password: <br> 
                  yup.string() <br>
                  .min(5)
              </code> en az 5 karakter. <br>
              <code>
                  .required(), <br>
                  passwordComfirm: <br>
                    yup.string() <br>
                    .oneOf([yup.ref("password")])
              </code> password alanındaki veriyle aynı olmalı. <br>
              <code>
                    .required(), <br>
                }); <br><br>

                export default validations;

              </code>
            </p>
            <p>
              validasyon kullanılacağı Singup.js içine import edilir ve formik yapısı içindeki validationSchema ile eşleştirilir. <br>
              <code>
                import React from "react"; <br>
                import { useFormik } from "formik"; <br>
                import validations from "./validation"; <br><br>

                function Singup() { <br>
                  const { handleSubmit, handleChange, values } = useFormik({ <br>
                    initialValues: { <br>
                      email: "", <br>
                      password: "", <br>
                      passwordComfirm: "", <br>
                    }, <br>
                    onSubmit: (values) => { <br>
                      console.log(values); <br>
                    }, <br>
                    validationSchema: validations
              </code> validations import edilirken validationSchema adıyla alınırsa bu eşleştirmeye gerek kalmadan sadece "validationSchema" yazılarak da kullanılabilir. <br>
              <code>
                  }); <br>
                  return ( <br>
                    &lt;div> <br>
                      &lt;h1>Sign Up&lt;/h1> <br>
                      &lt;form onSubmit={handleSubmit}> <br>
                        &lt;label>Email&lt;/label> <br>
                        &lt;input
                          name="email"
                          value={values.email}
                          onChange={handleChange}
                        />
                        &lt;br />
                        &lt;br /> <br>
                        &lt;label>Password&lt;/label> <br>
                        &lt;input
                          name="password"
                          value={values.password}
                          onChange={handleChange}
                        />
                        &lt;br />
                        &lt;br /> <br>
                        &lt;label>Password Comfirm&lt;/label> <br>
                        &lt;input 
                          name="passwordComfirm"
                          value={values.passwordComfirm}
                          onChange={handleChange}
                        /> 
                        &lt;br />
                        &lt;br /> <br>
                        &lt;button type="submit">Submit&lt;/button>
                        &lt;br />
                        &lt;br /> <br>
                        &lt;code>{JSON.stringify(values)}&lt;/code> <br>
                      &lt;/form> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default Singup;

              </code>
            </p>

            <h2>Hata Mesajlarının Gösterimi</h2>
            <p>
              Bunun için formik yapısına errors, touched ve handleBlur özellikleri import edilir. <br>
              <b>errors</b>: hata mesajlarını yakalar. hatanın olduğu kısım key, hata mesajı value olan bir object döner. <br>
              <b>touched</b>: yazıldığı kısma kullanıcı teması olma durumunu verir. <br>
              <b>handleBlur</b>: touched değerini günceller.
            </p>
            <p>
              Koşul cümlesi ile hata mesajı alınır. <br>
              <code>
                {errors.email && touched.email && &lt;div className="error">&lt;br/>{errors.email}&lt;/div>}
              </code> <br>
              <b>errors.email</b>: hata mesajı varsa <br>
              <b>touched.email</b>: email inputuna dokunulduysa <br>
              <b>&lt;div className="error">&lt;br/>{errors.email}&lt;/div>}</b> kodunu yerleştir.
            </p>
            <p>
              Örnek: <br>
              <code>
                ... <br>
                return( <br>
                ... <br>
                &lt;input
                  name="password"
                  value={values.password}
                  onChange={handleChange}
                  onBlur={handleBlur}
                /> <br>
                &lt;br /> <br>
                {errors.password && touched.password && &lt;div className="error">&lt;br/>{errors.password}&lt;/div>} <br>
                &lt;br /> <br>
                ... <br>
                )
              </code>
            </p>
            <p>
              Koşula göre verilen hata kodu default haliyle ingilizce açıklamalar verir. Bunu özelleştirebiliriz. Bunun için validation.js içinde: <br>
              <code>
                import * as yup from "yup"; <br><br>

                const validations = yup.object({ <br>
                  email: <br>
                  yup.string() <br>
                  .email('<u>Geçerli bir email girin</u>') <br>
                  .required('<u>Doldurulması zorunludur</u>'), <br>
                  password: <br>
                  yup.string() <br>
                  .min(5, '<u>Parolanız en az 5 karakter olmalıdır</u>') <br>
                  .required('<u>Doldurulması zorunludur</u>'), <br>
                  passwordComfirm: <br>
                    yup.string() <br>
                    .oneOf([yup.ref("password")], '<u>Parolalar uyuşmuyor</u>') <br>
                    .required('<u>Doldurulması zorunludur</u>'), <br>
                }); <br><br>

                export default validations;

              </code>
            </p>
          </div>
          <div class="row" id="reactMemo">
            <h1>React.memo</h1>
            <p>
              React içindeki gereksiz render işlemlerini engelleyip performansı arttırmak için kullanılır.
            </p>
            <p>
              React projesinde bir kompanentin içinde yer alan kompanent dış kompanent her render edildiğinde kendisinde bir değişiklik olmasa bile yeniden render ediliyor. Bunu engellemek için export işlemi sırasında React.memo kullanılır. Örn: <br>
              <code>
                export default React.memo(Header)
              </code>
            </p>
            <p>
              Bu durumda Header kompanentinde veya gelen propunda bir değişiklik olmadıkça re-render edilmez.
            </p>
            <h2>Örnek</h2>
            <p>
              Header.js: <br>
              <code>
                import React from 'react' <br><br>

                function Header({number}) { <br>
                    console.log("Header Component Re-Rendered!"); 
              </code> Re-render işlemini konsoldan takip edebilmek için yazıldı. <br>
              <code>
                  return ( <br>
                    &lt;div>Header - {number}&lt;/div> <br>
                  ) <br>
                } <br><br>

                export default React.memo(Header)
              </code> export edilecek fonksiyon React.memo ile sarmalandı.
            </p>
            <p>
              App.js <br>
              <code>
                import './App.css'; <br>
                import { useState } from "react"; <br>
                import Header from './components/Header' <br><br>

                function App() { <br>
                  const [number, setNumber] = useState(0) <br>
                  return ( <br>
                    &lt;div className="App"> <br>
                      &lt;Header number={number &lt; 5 ? 0 : number} />
              </code> Header içine gönderilecek number probu number 5 ten küçük olduğu sürece 0 olarak gönderilecek. <br>
              <code>
                      &lt;hr /> <br>
                      &lt;h1>{number}&lt;/h1> <br>
                      &lt;button onClick={()=>setNumber(number +1)}>Click&lt;/button> <br>

                    &lt;/div> <br>
                  );
                } <br><br>

                export default App;

              </code>
            </p>
            <p>
              Yukarıdaki örnekte number stateti 0 dan başlar ve her butona basıldığında number 1 artar. number değeri 5i geçene kadar gönderilen number propu 0 olarak kalır. Bu nedenle de o ana kadar Header kompanentinde re-render olmaz.
            </p>
            <p>
              Header içinde proptan gelen veri kullanılmasa da değer değiştiğinde re-rendering olur.
            </p>
          </div>
          <div class="row" id="useMemo">
            <h1>useMemo</h1>
            <p>
              Aynı içeriğe sahip object veya array yapılarının denkliği js üzerinden sorgulandığında, arka plandaki referansları farklı olduğundan değer false döner. Bu nedenle prop olarak gönderilen object veya array kompanent içindeyse, içinde olduğu kompanent her render edildiğinde prop da yeni veri göndermiş gibi davranır.
            </p>
            <p>
              Bundan kurtulmak için prop olarak gönderilecek object veya array kompanentin dışında tanımlanabilir.
            </p>
            <p>
              Kompanentin içinde yazılması gerekiyorsa useMemo hooku kullanılır. örn: <br>
              const data = useMemo(()=>{ <br>
                return {name: "Murat"} <br>
              },[])
            </p>
            <p>
              useMemo useEffect gibi davranır. dependence array'e yazılan değer değiştiğinde içerideki değeri tekrar döndürür.
            </p>

            <h2>Örnek 1</h2>
            <p>
              Header.js: <br>
              <code>
                import React from 'react' <br><br>

                function Header({number, data}) { <br>
                    console.log("Header Component Re-Rendered!"); 
                  return ( <br>
                    &lt;div>Header - {number} - {JSON.stringify(data)&lt;/div> <br>
                  ) <br>
                } <br><br>

                export default React.memo(Header)
              </code> export edilecek fonksiyon React.memo ile sarmalandı.
            </p>
            <p>
              App.js <br>
              <code>
                import './App.css'; <br>
                import { useState } from "react"; <br>
                import Header from './components/Header' <br><br>

                function App() { <br>
                  const [number, setNumber] = useState(0) <br>
                  const data = useMemo(()=>{
              </code> data object yapısı useMemo ile tanımlandı. <br>
              <code>
                    return {name: "Murat"}
                  },[])
              </code> [] içine girilen yapı değiştiğinde verinin yeniden gönderimini yapar. [] içi boşsa değeri sabit tutar. <br>
              <code>
                  return ( <br>
                    &lt;div className="App"> <br>
                      &lt;Header number={number &lt; 5 ? 0 : number} />
                      &lt;hr /> <br>
                      &lt;h1>{number}&lt;/h1> <br>
                      &lt;button onClick={()=>setNumber(number +1)}>Click&lt;/button> <br>

                    &lt;/div> <br>
                  );
                } <br><br>

                export default App;

              </code>
            </p>
            <h2>Örnek 2</h2>
            <p>
              Bize değişken olarak verilen değer bir fonksiyonun çıktısıysa ve biz her seferinde bu fonksiyonun çalışmasını istemiyorsak useMemo kullanırız.
            </p>
            <p>
              App.js: <br>
              <code>
                import './App.css'; <br>
                import { useMemo, useState } from "react"; <br>
                import Header from './components/Header' <br><br>

                function App() { <br>
                  const [number, setNumber] = useState(0) <br>
                  const [text, setText] = useState("") <br><br>
                  
                  const data = useMemo(()=>{ <br>
                    return caculateObject() <br>
                  },[]) <br><br>

                  return ( <br>
                    &lt;div className="App"> <br>
                      &lt;Header number={number &lt; 5 ? 0 : number} data={data} /> <br>
                      &lt;hr /> <br>
                      &lt;h1>{number}&lt;/h1> <br>
                      &lt;button onClick={()=>setNumber(number +1)}>Click&lt;/button> <br>
                      &lt;br /> 
                      &lt;br /> <br>
                      &lt;input value={text} onChange={({target}) => setText(target.value)}/> <br>
                    &lt;/div> <br>
                  ); <br><br>

                  function caculateObject(){ 
              </code> Objeyi return edecek fonksiyon. <br>
              <code>
                    console.log("Calculating..."); <br>
                    for(let i=0; i&lt;1000000000; i++){}
              </code> hesaplamanın zaman aldığı bir işlem simüle edildi. <br>
              <code>
                    console.log("Calculating completed!"); <br>

                    return {name: "Murat"} <br>
                  } <br>

                } <br><br>

                export default App;

              </code>
            </p>
            <p>
              Biz burada useMemo kullanmak yerine <code>const data = caculateObject()</code> ile tanımlama yaparsak forma her bir harf girmeye çalıştığımızda yukarıdaki fonksiyon tekrar çalışır ve bizi bekletir.
            </p>
          </div>
          <div class="row" id="useCallback">
            <h1>useCallback</h1>
            <p>
              İç içe kompanent yapısında içteki kompanente prop olarak fonksiyon gönderdiğimizde ve dıştaki kompanent re-render edildiğinde, fonksiyon baştan hesaplandığı için React.memo kullanılsa bile içteki kompanent de re-render ediliyor. Bunu engellemek için <b>useCallback</b> kullanılıyor.
            </p>
            <p>
              Kullanımı useMemo gibi. Fonksiyon useCallback içinde tanımlanır ve prop olarak gönderilir.
            </p>
            <p>
              <code>
                const increment = useCallback(() => { <br>
                  setNumber(number + 1) <br>
                },[number]) <br>
              </code>setNumber(number + 1) fonksiyonunun döndüğü durumda [] içine number yazılmazsa ilk değeri 0 olan number fonksiyonda işlenir ve sonuca sabitlenir. Number güncellendiğinde fonksiyonun tekrar çalışabilmesi için dependence array ("[]") içine yazılır. Ancak bu durmumda da yeni bir fonksiyon tanımlandığından Header re-render edilir. Bunu engellemek için fonksiyon number olmadan yazılmalıdır.
            </p> 
            <p>
              <code>
                const increment = useCallback(() => { <br>
                  setNumber((preState) => preState + 1); <br>
                }, []); 
              </code>
            </p>

            <h2>Örnek</h2>
            <p>
              App.js <br>
              <code>
                import "./App.css"; <br>
                import { useMemo, useState, useCallback } from "react"; <br>
                import Header from "./components/Header"; <br><br>

                function App() { <br>
                  const [number, setNumber] = useState(0); <br>
                  const [text, setText] = useState(""); <br>

                  const increment = useCallback(() => { 
              </code>Fonksiyon useCallback içinde tanımlanır. <br>
              <code>
                    setNumber((preState) => preState + 1); <br>
                  }, []); <br><br>

                  return ( <br>
                    &lt;div className="App"> <br>
                      &lt;Header increment={increment} />
              </code> tanımlanan fonksiyon prop ile gönderilir. <br>
              <code>
                      &lt;hr /> <br>
                      &lt;h1>{number}&lt;/h1> <br>

                      &lt;br /> 
                      &lt;br /> <br>
                      &lt;input value={text} onChange={({ target }) => setText(target.value)} /> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default App;

              </code>
            </p>
            <p>
              Header.js: <br>
              <code>
                import React from 'react' <br><br>

                function Header({number, increment}) { 
              </code> ile prop alındı. <br>
              <code>
                    console.log("Header Component Re-Rendered!"); <br>
                  return ( <br>
                    &lt;div> <br>
                        Header - {number} <br>
                        &lt;br /> 
                        &lt;br /> <br>
                        &lt;button onClick={increment}>Click&lt;/button>
              </code> ile alınan prop kullanıldı. <br>
              <code>
                    &lt;/div> <br>
                  )
                } <br><br>

                export default React.memo(Header)
              </code>
            </p>
          </div>
          <div class="row" id="contextNedir">
            <h1>Context Nedir?</h1>
            <p>
              Elimizdeki datanın tüm kompanentlerde kullanılabilmesini sağlar. Contex içindeki dataya herhangi bir kompanentten ulaşıp manipule edebiliriz.
            </p>
          </div>
          <div class="row" id="contextOlusturmak">
            <h1>Context Oluşturmak</h1>
            <p>
              src/context klasörü içine ThemeContext.js dosyası oluşturulur. <br>
              <code>
                import { createContext } from "react"; <br>

                const ThemeContext = createContext();
              </code> ile context yaratıldı <br>
              <code>

                export default ThemeContext; 
              </code>
            </p>
            <p>
              Context içine veri göndermek için App.js: <br>
              <code>
                import './App.css'; <br>
                import Button from './components/Button'; <br>
                import ThemeContext from "./context/ThemeContext"; 
              </code> ile context import edildi. <br>
              <code><br>

                function App() { <br>
                  return ( <br>
                    &lt;ThemeContext.Provider value="dark">
              </code> ile içine yazılacak tüm kompanentlere veri gönderildi. <br>
              <code>
                      &lt;Button/> <br>
                    &lt;/ThemeContext.Provider> <br>
                  );
                } <br>

                export default App; <br>

              </code>
            </p>
            <p>
              Context içindeki veriyi almak için Button.js içine: <br>
              <code>
                import { useContext } from 'react' <br>
                import ThemeContext from "../context/ThemeContext"; <br><br>

                function Button() { <br>
                    const data = useContext(ThemeContext)
              </code> data ile ThemeContext içinde gönderilen veri değişkene atandı. <br>
              <code>
                    console.log(data); <br>
                  return ( <br>
                    &lt;div>Button ({data})&lt;/div> <br>
                  ) 
                } <br><br>

                export default Button
              </code>
            </p>
          </div>
          <div class="row" id="contextProvider">
            <h1>Context Provider</h1>
            <p>
              Children: bir kompanenti kapalı parantezle değil de html tagi gibi yazarsak arasına yazdığımız değerler prop gibi kompanente gönderilir ve chidren ile yakalanıp kullanılabilir.
            </p>
            <p>
              chidren perspektifinde ThemeContext.Provider etiketi ve ona eklenen veriler ThemeContext.js dosyasına aktarılabilir.
            </p>
            <p>
              ThemeContext.js: <br>
              <code>
                import { createContext, useState } from "react"; <br>

                const ThemeContext = createContext(); <br><br>

                export const ThemeProvider = ({ children }) => {
              </code> ThemeProvider değişkeni kompanent yapısıyla export edilir. İçine yazılacaklar children ile prop olarak alınır.<br>
              <code>
                    const [theme, setTheme] = useState("dark") 
              </code>ile state oluşturuldu. <br>
              <code>
                    const values = { <br>
                        theme, <br>
                        setTheme <br>
                    } 
              </code> ile state değerleri değişkene atandı. <br>
              <code>
                  return &lt;ThemeContext.Provider value={values}>{children}&lt;/ThemeContext.Provider>; 
              </code> ThemeContext.Provider parantezleri, values verisi ve children verisi return edilir. <br>
              <code>
                }; <br><br>

                export default ThemeContext;

              </code>
            </p>
            <p>
              App.js içinde: <br>
              <code>
                import './App.css'; <br>
                import Button from './components/Button'; <br>
                import Header from './components/Header'; <br>
                import {ThemeProvider} from "./context/ThemeContext"; <br><br>

                function App() { <br>
                  return ( <br>
                    &lt;ThemeProvider>
              </code> ile kompanent içinde children olacak şekilde kurgulanır. Buradan gönderilen veri children olarak ThemeContext.js içinde kullanılır ve o perspektifte render edilir. <br>
              <code>
                      &lt;Header/> <br>
                      &lt;hr /> <br>
                      &lt;Button/> 
                    </code> chidren olarak Header ve Button kompanentleri yerleştirilir.<br>
                    <code>
                    &lt;/ThemeProvider> <br>
                  );
                } <br><br>

                export default App;
              </code>
            </p>
            <p>
              Kompanent içinden context içindeki veriyi almak ve manipule etmek için Header.js<br>
              <code>
                import React, { useContext } from 'react' <br>
                import ThemeContext from '../context/ThemeContext' <br><br>

                function Header() { <br>
                    const {theme, setTheme} = useContext(ThemeContext)
              </code> ile ThemeContext içinden gönderilen value yakalandı. <br>
              <code>
                  return ( <br>
                    &lt;div>Header: {theme} &lt;button onClick={()=>setTheme(theme === "dark" ? "light" : "dark")}>Click&lt;/button> <br>
                    &lt;/div> <br>
                  )
                } <br>

                export default Header <br>
              </code>
            </p>
            <p>
              Aynı işlem Button.js içinde de tekrarlanabilir. Her iki buton da theme değerini değiştirir. <br>
              <code>
                import { useContext } from 'react' <br>
                import ThemeContext from "../context/ThemeContext"; <br><br>

                function Button() { <br>
                    const {theme, setTheme} = useContext(ThemeContext) <br>
                  return ( <br>
                    &lt;div> <br>
                      Active Theme: {theme} <br>
                      &lt;button onClick={()=>setTheme(theme === "dark" ? "light": "dark")}>Click&lt;/button> <br>
                    &lt;/div> <br>
                    
                  )
                } <br>

                export default Button 
              </code>
            </p>
          </div>
          <div class="row" id="themeSwitcher">
            <h1>Theme Switcher Yapımı</h1>
            <p>
              Kapsayıcı kompanent olması için Container kompanenti oluşturuldu ve diğer kompanenetler onun içinde kullanıldı. Container kompanenti de App.js içinde import edilip kullanıldı.
            </p>
            <p>
              Daha önce ThemeContext içinde gönderdiğimiz veriyi Container içindeki kapsayıcı div etiketine className vermek için kullandık. Bu className değerini de App.css içinde style ile karşıladık.
            </p>
            <p>
              App.js <br>
              <code>
                import './App.css'; <br>
                import Container from './components/Container'; <br>
                import {ThemeProvider} from "./context/ThemeContext"; <br><br>

                function App() { <br>
                  return ( <br>
                    &lt;ThemeProvider> <br>
                      &lt;Container/> <br>
                    &lt;/ThemeProvider> <br>
                  ); <br>
                } <br><br>

                export default App;
 
              </code>
            </p>
            <p>
              Container.js <br>
              <code>
                import React, { useContext } from "react"; <br>
                import Button from "./Button"; <br>
                import Header from "./Header"; <br>
                import ThemeContext from "../context/ThemeContext"; <br><br>

                function Container() { <br>
                  const { theme } = useContext(ThemeContext); <br>
                  return ( <br>
                    &lt;div className={`app ${theme}`}>
              </code> butona her basıldığında theme değiştiğinden div etiketinin aldığı className de değişiyor. <br>
              <code>
                      &lt;Header /> <br>
                      &lt;hr /> <br>
                      &lt;Button /> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default Container;

              </code>
            </p>
            <p>
              App.css <br>
              <code>
                .app { <br>
                  text-align: center; <br>
                  height: 100vh; <br>
                } <br>
                
                .dark { <br>
                  color: white; <br>
                  background-color: black; <br>
                }
              </code>
            </p>
          </div>
          <div class="row" id="contextProviderSideEffects">
            <h1>Context Provider Side Effects</h1>
            <p>
              theme bilgisini localStorage üzerine ekleyeceğiz. Bu sayede sayfa yenilendiğinde son verdiğimiz hali bize gösterecek.
            </p>
            <p>
              ThemeContext.js içinde: <br>
              <code>
                import { createContext, useEffect, useState } from "react"; <br>

                const ThemeContext = createContext(); <br><br>

                export const ThemeProvider = ({ children }) => { <br>
                  const [theme, setTheme] = useState(localStorage.getItem('theme') || 'light'); 
              </code> localStorage içinde theme keyine ait value varsa getir. yoksa 'light' değerini ata. <br><br>
              <code>

                  useEffect(()=>{ <br>
                    localStorage.setItem("theme", theme) <br>
                  },[theme])
              </code> theme değeri her değiştiğinde yeni değeri localStorage içine theme keyine karşılık ata. <br><br>
              <code>

                  const values = { <br>
                    theme, <br>
                    setTheme, <br>
                  }; <br><br>

                  return ( <br>
                    &lt;ThemeContext.Provider value={values}>{children}&lt;/ThemeContext.Provider> <br>
                  ); <br>
                }; <br><br>

                export default ThemeContext;

              </code>
            </p>
          </div>
          <div class="row" id="multiContext">
            <h1>Multi Context</h1>
            <p>
              Yeni bir context oluşturduk. UserContext.js: <br>
              <code>
                const { createContext, useState } = require("react"); <br><br>

                const UserContext = createContext() <br><br>

                export const UserProvider = ({children})=> { 
              </code>App.js içinde bu contexten gelen veriyi alacak olan kompanentleri sarmalaması için UserProvider tanımlanır. <br>
              <code>
                    const [user, setUser] = useState(null)
              </code> context ile göndermek için state oluşturuldu. <br>
              <code>
                    const values = {
                        user,
                        setUser,
                    } <br><br>

                    return &lt;UserContext.Provider value={values}>{children}&lt;/UserContext.Provider> <br>
                } <br><br>

                export default UserContext
              </code>
            </p>
            <p>
              App.js içinde <br>
              <code>
                import './App.css'; <br>
                import Container from './components/Container'; <br>
                import {ThemeProvider} from "./context/ThemeContext"; <br>
                import { UserProvider } from './context/UserContext'; <br><br>

                function App() { <br>
                  return ( <br>
                    &lt;ThemeProvider> <br>
                      &lt;UserProvider>
              </code> ile Container sarılır. <br>
              <code>
                        &lt;Container/> <br>
                      &lt;/UserProvider> <br>
                    &lt;/ThemeProvider> <br>
                  );
                } <br><br>

                export default App;
 
              </code>
            </p>
            <p>
              Profile.js kompanenti oluşturulur ve Container içine import edilir.
            </p>
            <p>
              Profile.js içinde: <br>
              <code>
                import { useContext, useState } from "react"; <br><br>

                  import UserContext from "../context/UserContext";<br><br>

                  function Profile() { <br>
                    const { user, setUser } = useContext(UserContext); <br>
                    const [loading, setLoading] = useState(false); <br> <br>

                    const handleLogin = () => { <br>
                      setLoading(true); <br>
                      setTimeout(() => { <br>
                        setUser({ <br>
                          id: 1, <br>
                          username: "arslanng", <br>
                          bio: "lorem ipsum dolor", <br>
                        }); <br>
                        setLoading(false); <br>
                      }, 1500); 
              </code> ile süre alan bir işlem simüle edilerek loading yazısı ekranda gösterilmiştir. <br>
              <code>
                    }; <br>
                    return ( <br>
                      &lt;div> <br>
                        {!user && ( <br>
                          &lt;button onClick={handleLogin}> <br>
                            {loading ? "loading..." : "Login"} <br>
                          &lt;/button> <br>
                        )} <br>
                        {JSON.stringify(user)} <br>

                        {user && &lt;button onClick={()=>setUser(null)}>Logout&lt;/button>} <br>

                      &lt;/div> <br><br>
                    ); <br>
                  } <br><br>

                  export default Profile;

              </code>
            </p>
          </div>
          <div class="row" id="customContextHook">
            <h1>Custom Context Hook</h1>
            <p>
              Birden fazla yerde yapılacak context ile ilgili işlemler context içinde tanımlanıp export edilerek kullanılabilir. <br>
              <code>
                useContext(ThemeContext); 
              </code> örneğimizde birden fazla kompanentte kullanılıyor. Kodu sadeleştirmek için bu işlemi kompanentte değil context dosyasında yapabiliriz.
            </p>
            <p>
              ThemeContext.js: <br>
              <code>
                import { createContext, useContext, useEffect, useState } from "react"; <br>

                const ThemeContext = createContext(); <br>

                export const ThemeProvider = ({ children }) => { <br>
                  const [theme, setTheme] = useState(localStorage.getItem("theme") || "light"); <br>

                  useEffect(() => { <br>
                    localStorage.setItem("theme", theme); <br>
                  }, [theme]); <br>

                  const values = { <br>
                    theme, <br>
                    setTheme, <br>
                  }; <br>

                  return ( <br>
                    &lt;ThemeContext.Provider value={values}>{children}&lt;/ThemeContext.Provider> <br>
                  ); <br>
                }; <br><br>

                export const useTheme = () => useContext(ThemeContext);
              </code> ile işlem tanımlanıp export edildi.
            </p>
            <p>
              Button.js içinde: <br>
              <code>
                import { useTheme } from "../context/ThemeContext";
              </code> ile useTheme import edildi. <br>
              <code> <br>

                function Button() { <br>
                  const { theme, setTheme } = useTheme();
              </code> ile fonksiyon kullanıldı ve veriler elde edildi. <br>
              <code>
                  return ( <br>
                    &lt;div> <br>
                      Active Theme: {theme}{" "} <br>
                      &lt;button onClick={() => setTheme(theme === "dark" ? "light" : "dark")}> <br>
                        Click <br>
                      &lt;/button> <br>
                    &lt;/div> <br>
                  ); 
                } <br>

                export default Button; <br>

              </code>
            </p>
            <p>
              Header ve Container için de aynı işlem tekrarlanır.
            </p>
          </div>
          <div class="row" id="contextOdev">
            <h1>Context Ödev Notları</h1>
            <p>
              Verinin yansıtıldığı kompanent içine veri alınamazsa veya alınması zaman alırsa gösterilmesi için if koşulu ile bir loading ifadesi return edilir. Yoksa kod hata veriyor.
            </p>
          </div>
          <div class="row" id="arayuz">
            <h1>Arayüzün Hazırlanması</h1>
            <p>
              Projenin amacı, bir kullanıcı renk seçtiğinde bu seçimin tüm kullanıcıları anlık etkilemesi.
            </p>
            <p>
              Hocanın daha önceden hazırladığı bir backend dosyası ile çalışacağız.
            </p>
            <p>
              Bu backend <a href="https://socket.io/">socket.io</a> kütüphanesini kullanıyor.
            </p>
            <p>
              Backendde olması gereken paketleri yüklemek için terminal backendde iken terminale: <br>
              <code>
                npm i
              </code> yazılır.
            </p>
            <p>
              Terminale <code>npm start</code> yazılarak backend çalıştırılır.
            </p>
            <p>
              paket yükleme işlemi client için de yapılır.
            </p>
            <p>
              client tarafında Palette adında bir kompanent oluşturularak içine bir input [type="color"] ve bir buton ekledik. Bunu App.js içinde kullandık. App.css ile de stil tanımları atadık.
            </p>
          </div>
          <div class="row" id="connectSocketServer">
            <h1>Socket Server'a Bağlanmak</h1>
            <p>
              Client tarafını server'a bağlamak için socket.io-client kullanılır. Terminale: <br>
              <code>
                npm install socket.io-client
              </code>
            </p>
            <p>
              src/socketApi.js dosyası oluşturuldu. içine: <br>
              <code>
                import io from "socket.io-client"; <br><br>

                let socket; <br><br>

                export const init = () => { 
              </code> bizim socket server bağlantı fonksiyonumuz. <br>
              <code>
                    console.log("Sunucuya bağlanılıyor...") <br>
                    socket = io('http://localhost:3001', { 
              </code> backend tarafında belirlenen server ile bağlantı sağlar. <br>
              <code>
                        transports: ["websocket"] <br>
                    }) <br><br>

                    socket.on("connect", () => 
              </code> bağlantı sağlandığında aşağıdaki fonksiyonu çalıştırır. <br>
              <code> 
                    console.log("Sununucuya bağlandı") <br>
                    ); <br>
                }
              </code>
            </p>
            <p>
              App.js içinde bu fonksiyon karşılanır ve kullanılır. <br>
              <code>
                import { useEffect } from 'react'; <br>
                import './App.css'; <br>
                import Palette from './components/Palette'; <br>
                import { init } from './socketApi'; <br><br>

                function App() { <br>
                  useEffect(()=>{ <br>
                    init() <br>
                  },[]) <br>
                  return ( <br>
                    &lt;div className="App"> <br>
                      &lt;Palette/> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default App;

              </code>
            </p>
          </div>
          <div class="row" id="backendVeri">
            <h1>Backend'e Veri İletmek</h1>
            <p>
              Veri iletmek için socketApi.js içine aşağıdaki fonksiyon eklenir: <br>
              <code>
                export const send = (color) => { <br>
                  socket.emit("newColor", color) <br>
                }
              </code>emit metodu clientte isek backende backendde isek cliente veri gönderir. İki parametre alır. Hangi kanal? data ne?. Kanal bilgisi backendden alınır.
            </p>
            <p>
              Bu fonksiyon Palette.js içinde butonda onClick eventinde kullanılır. <br>
              <code>
                import React, { useState } from "react"; <br>
                import { send } from "../socketApi"; <br><br>

                function Palette() { <br>
                  const [color, setColor] = useState('') 
              </code>renk bilgisinin tutulduğu state. <br>
              <code>
                  return ( <br>
                    &lt;div className="palette"> <br>
                      &lt;input type="color" value={color} onChange={(e)=>setColor(e.target.value)} /> <br>
                      &lt;button onClick={()=>send(color)}>Click&lt;/button> <br>
                    &lt;/div> <br>
                  );
                } <br><br>

                export default Palette;

              </code>
            </p>
          </div>
          <div class="row" id="KanalAbone">
            <h1>Bir Kanala Abone Olmak</h1>
            <p>
              Socket io üzerinden veriyi bir kanal aracılığı ile alıyoruz. Aldığımız kanalın adı backend tarafında belirtiliyor.
            </p>
            <p>
              Veriyi almak için SocketApi.js ye aşağıdaki fonksiyonu ekliyoruz. <br>
              <code>
                export const subscribe = (cb) => {
              </code> cb parametresi ile fonksiyon olarak verilen parametre karşılanır. <br>
              <code>
                  socket.on("receive", (color)=>{ <br>
                      console.log(color); <br>
                      cb(color)
              </code> ile karşılanan fonksiyona parametre geçilerek çalıştırılır. <br>
              <code>
                  })
              } <br>
              </code>
            </p>
            <p>
              Tanımlanan fonksiyon App.js içinde uygulanır. <br>
              <code>
                import { useEffect, useState } from 'react'; <br>
                import './App.css'; <br>
                import Palette from './components/Palette'; <br>
                import { init, subscribe } from './socketApi'; <br><br>

                function App() { <br>
                  const [activeColor, setActiveColor] = useState('#969696')
              </code> ile kanaldan çekilecek veri için state oluşturulur. <br>
              <code> <br>

                  useEffect(()=>{ <br>
                    init(); <br>
                    subscribe((color)=>{
              </code> ile ilgili stateti set edecek fonksiyon kanaldan veri çekecek fonksiyona parametre olarak atanır. <br>
              <code>
                      setActiveColor(color) 
              </code> kanaldan gelen veri set edilir. <br>
              <code>
                    }); <br>
                  },[]) <br>
                  return ( <br>
                    &lt;div className="App" style={{backgroundColor: activeColor}}>
              </code> ile kanaldan alınan veri background-color olarak kullanılır. <br>
              <code>
                      &lt;Palette activeColor={activeColor}/>
              </code> ile veri Palette kompanenetine prop olarak gönderilir. <br>
              <code>
                    &lt;/div> <br>
                  ); <br>
                } <br><br>

                export default App;

              </code>
            </p>
            <p>
              background-color değiştiğinde diğer clientlerde inputun da uyumlu olarak değişmesi için prop olarak gönderilen activeColor bilgisi Palette.js içinde input value olarak kullanılır.
            </p>
          </div>
          <div class="row" id="aboutSocket">
            <h1>Socket Io hakkında</h1>
            <p>
              Socket.IO, bir istemci ile bir sunucu arasında düşük gecikmeli, çift yönlü ve olay tabanlı iletişim sağlayan bir kitaplıktır.
            </p>
            <p>
              WebSocket protokolünün üzerine inşa edilmiştir ve HTTP uzun yoklama veya otomatik yeniden bağlanmaya geri dönüş gibi ek garantiler sağlar.
            </p>

            <h2>Socket.IO ne değildir?</h2>
            <p>
              Socket.IO bir WebSocket uygulaması DEĞİLDİR.
            </p>
            <p>
              Socket.IO gerçekten de mümkün olduğunda aktarım için WebSocket kullansa da, her pakete ek meta veriler ekler. Bu nedenle, bir WebSocket istemcisi bir Socket.IO sunucusuna başarılı bir şekilde bağlanamaz ve bir Socket.IO istemcisi de düz bir WebSocket sunucusuna bağlanamaz.
            </p>

            <div class="alert alert-success">
              <h3>Websoket Nedir?</h3>
              <p>
                WebSocket API, bir kullanıcının tarayıcısı ve bir sunucu arasında iki yönlü etkileşimli bir iletişim oturumu açmasını mümkün kılan gelişmiş bir teknolojidir.
              </p>
              <p>
                Websocket durum bilgisi olan bir protokoldür, yani istemci ve sunucu arasındaki bağlantı, taraflardan biri (istemci veya sunucu) tarafından sonlandırılıncaya kadar canlı kalır. İstemci ve sunucudan herhangi biri tarafından bağlantıyı kapattıktan sonra, bağlantı her iki uçtan da sonlandırılır.
              </p>
            </div>
            <p>
              Socket.IO, mobil uygulamalar için bir arka plan hizmetinde kullanılmak üzere tasarlanmamıştır.
            </p>
            <p>
              Socket.IO kitaplığı, sunucuya açık bir TCP bağlantısı tutar ve bu, kullanıcılarınız için yüksek pil tüketimine neden olabilir. Lütfen bu kullanım durumu için FCM gibi özel bir mesajlaşma platformu kullanın.
            </p>
            <p>
              Detay okuma için <a href="https://socket.io/docs/v4/">tıklayınız.</a>
            </p>
          </div>
          <div class="row" id="chatAppGiris">
            <h1>Chat App Giriş</h1>
            <p>
              Uygulamanın çalışması için <a href="https://redis.io/">redis</a> uygulamasını yükleyeceğiz. Bu uygulamada gelen mesajları depolamak ve görüntülemek için kullanacağız.
            </p>
            <p>
              redis kurabilmek için önce <a href="https://learn.microsoft.com/en-us/windows/wsl/install">wsl</a> (The Windows Subsystem for Linux) kurmamız gerekiyor. Alternatif olarak  Microsoft Open Tech‘in 64 bit Windows sürümleri için portlamış olduğu bir Redis sürümü bulunmaktadır. Bunun için <a href="https://github.com/microsoftarchive/redis/releases">tıklayınız</a>
            </p>
            <p>
              redisin çalışması için terminale: <br>
              <code>server-redis</code> yazıyoruz.
            </p>
            <p>
              <a href="https://mennankose.com/windowsta-redis-kullanimi/">mennankose.com/windowsta-redis-kullanimi</a>
            </p>
            <p class="alert alert-success">
              Redis – Remote Dictionary Server (Uzak Sözlük Sunucusu); ilişkisel olmayan anahtar/değer veri tabanlarını ve önbellekleri uygulamak için yaygın olarak kullanılan açık kaynaklı bir bellek içi veri deposudur.
            </p>
            <p>
              Projenin backend tarafı bize hazır verildi. redisin çalışması için bir takım ortam değişkenleri tanımlıyoruz. Bunun için backend dizinine .env dosyası oluşturduk. <br>
              <code>
                REDIS_HOST=localhost
              </code> redisin çalışacağı host: bizim için localhost <br>
              <code>
                REDIS_PORT=6374
              </code> redisin çalışacağı port: 6374 default değerdir. <br>
              <code>
                REDIS_PASS=
              </code> boş bırakıyoruz.
            </p>
            <p>
              backend tarafında gereken node paketlerini yüklemek için terminalde backend açılır ve br:
              <code>
                npm i
              </code> yazılır.
            </p>
            <p>
              Yazılım geliştirirken rahat etmek için projeye nodemon ilave edilebilir. Bu sayede her değişiklikten sonra backend kendini tekrar başlatabilir. terminale: <br>
              <code>
                npm install --save-dev nodemon
              </code>
            </p>
            <p>
              Backend - db - client veri aktarımı için bu projede socket.io kullanılıyor.
            </p>
          </div>
          <div class="row" id="chatContext">
            <h1>Chat Context</h1>
            <p>
              client tarafında src/context/ChatContext.js oluşturuludu ve içinde <br> 
              <code>
                import { createContext, useState } from "react"; <br><br>

                const ChatContext = createContext() <br><br>

                export const ChatProvider = ({children}) => { <br>
                    const [messages, setMessages] = useState([]) <br>
                    const values = { <br>
                        messages, <br>
                        setMessages <br>
                    } <br>
                    return( <br>
                        &lt;ChatContext.Provider value={values}>{children}&lt;/ChatContext.Provider> <br>
                    )
                } <br> <br>

                export default ChatContext;
              </code>
            </p>
            <p>
              client/src/component içinde ChatForm.js ve ChatList.js taslak komponent olarak oluşturuldu ve Container.js komponentinde kullanıldı. <br>
              <code>
                import React from 'react'<br>
                import ChatList from './ChatList'<br>
                import ChatForm from './ChatForm'<br><br>

                function Container() {<br>
                  return (<br>
                    &lt;div><br>
                        &lt;ChatList/><br>
                        &lt;ChatForm/><br>
                    &lt;/div><br>
                  )
                }<br><br>

                export default Container
              </code>
            </p>
            <p>
              client/App.js içinde hepsi birleştirildi: <br>
              <code>
                import './App.css'; <br>
                import Container from './components/Container';<br>
                import {ChatProvider} from './context/ChatContext';<br><br>

                function App() {<br>
                  return (<br>
                      &lt;ChatProvider><br>
                        &lt;Container/><br>
                      &lt;/ChatProvider><br>
                  );
                }<br><br>

                export default App;

              </code>
            </p>
          </div>
          <div class="row" id="chatBilesenler">
            <h1>Temel Bileşenlerin Geliştirilmesi</h1>
            <p>
              components içinde style.module.css oluşturuldu ve içine hazır olarak verilen css bilgisi eklendi.
            </p>
            <p>
              Mesaj gelmesini simüle etmek için context/textContext.js messages stateine iki tane mesaj default olarak girildi. <br>
              <code>
                const [messages, setMessages] = useState([ <br>
                  { message: "Selam" },<br>
                  { message: "Naber" },<br>
                ]);
              </code>
            </p>
            <p>
              ChatList.js içinde alınan mesaj yerleştirildi.<br>
              <code>
                import React from "react"; <br>
                import { useChat } from "../context/ChatContext";<br>
                import ChatItem from "./ChatItem";<br>
                import styles from "./styles.module.css";<br><br>

                function ChatList() {<br>
                  const { messages } = useChat();<br>
                  return (<br>
                    &lt;div className={styles.chatlist}> <br>
                      &lt;div><br>
                        {messages.map((item, key) => (<br>
                          &lt;ChatItem key={key} item={item} /><br>
                        ))}<br>
                      &lt;/div><br>
                    &lt;/div><br>
                  );
                }<br><br>

                export default ChatList;

              </code>
            </p>
            <p>
              Bu yerleştirme sırasında ChatItem kompanenti oluşturuldu ve içine prop olarak gönderilen veri ile kullanıldı. <br>
              <code>
                import React from "react";<br>
                import styles from "./styles.module.css";<br><br>

                function ChatItem({ item }) {<br>
                  return &lt;div className={styles.chatItem}>{item.message}&lt;/div>;<br>
                }<br><br>

                export default ChatItem;

              </code>
            </p>
            <p>
              Chatform.js içinde formdan gelen veriyi alacak bir state oluşturuldu. Forma her veri girdiğinde sayfanın yenilenmemesi için onSubmit için tanımlanan fonksiyona <code>e.preventDefault();</code> kodu eklendi. <br>
              <code>
                import React, { useState } from "react";<br><br>

                import styles from "./styles.module.css";<br><br>

                function ChatForm() {<br>
                  const [message, setMessage] = useState("");<br>
                  const handleSubmit = (e) => {<br>
                    e.preventDefault();
              </code> sayfanın yenilenmesini engeller.<br>
              <code>
                    console.log(message);<br>
                    setMessage("");
              </code> mesajı sıfırlayarak submit sonrası formun temizlenmesini sağlar.<br>
              <code>
                  };<br>
                  return (<br>
                    &lt;div><br>
                      &lt;form onSubmit={handleSubmit}><br>
                        &lt;input<br>
                          className={styles.textInput}<br>
                          value={message}<br>
                          onChange={(e) => setMessage(e.target.value)}<br>
                        /><br>
                      &lt;/form><br>
                    &lt;/div><br>
                  );
                }<br><br>

                export default ChatForm;

              </code>
            </p>
            <p>
              Daha görsel olması için stiller düzenlenir.
            </p>
          </div>
          <div class="row" id="backendBaglanti">
            <h1>Backend Bağlantısı</h1>
            <p>
              Backend de bize hazır gelen socket-io serverı ile bağlanabilmemiz için client tarafında src/socketApi.js oluşturuldu ve içine: <br>
              <code>
                import io from "socket.io-client"; <br><br>

                let socket;<br><br>

                export const init = () => {<br>
                  console.log("Connecting...");<br>
                  socket = io("http://localhost:3000", {
              </code> backendimiz neredeyse onun urlsi girilir. <br>
              <code>
                    transports: ["websocket"],<br>
                  });<br><br>

                  socket.on("connect", () => console.log("Connected"));
              </code> socket connect olduğunda çalışacak fonksiyon. <br>
                }; 

              </code>
            </p>
            <p>
              Yukarıda yazılan init fonksiyonu Container.js içinde karşılanır. <br>
              <code>
                import React, { useEffect } from "react"; <br>
                import ChatList from "./ChatList";<br>
                import ChatForm from "./ChatForm";<br><br>

                import { init } from "../socketApi";<br><br>

                function Container() {<br>
                  useEffect(() => {<br>
                    init();<br>
                  }, []);<br>
                  return (<br>
                    &lt;div className="App"><br>
                      &lt;ChatList /><br>
                      &lt;ChatForm /><br>
                    &lt;/div><br>
                  );
                }<br><br>

                export default Container;

              </code>
            </p>
          </div>
          <div class="row" id="sendMessages">
            <h1>Mesajların İletilmesi</h1>
            <p>
              Stil tanımlarını rahat yapmak için ChatContext içinde messages statei için kullandığımız default mesajla silindi.
            </p>
            <p>
              mesajı göndermek için socketApi.js içinde: <br>
              <code>
                export const sendMessage = (message) => { <br>
                  if(socket) socket.emit("new-message", message); <br>
                } 
              </code> socket.emit() işleminde ilk parametre gönderilecek kanalı ikincisi gönderilecek olan veriyi belirtir.
            </p>
            <p>
              ChatForm.js içinde setMessages statei çekilir. Yazılan mesajın messages değişkenine atanması için kullanılır.
              <code>
                import React, { useState } from "react"; <br><br>

                import styles from "./styles.module.css"; <br>
                import { sendMessage } from "../socketApi";<br>
                import { useChat } from "../context/ChatContext";<br><br>

                function ChatForm() {<br>
                  const { setMessages } = useChat();<br>
                  const [message, setMessage] = useState("");<br><br>

                  const handleSubmit = (e) => { <br>
                    e.preventDefault(); <br>
                    console.log(message); <br>

                    setMessages((prevState) => [...prevState, { message, fromMe: true }]);
              </code> formdan gelen message değişkenini chatContext teki messages değişkenine ekler. forMe parametresi ile de bizden çıkan mesajları işaretler. <br>
              <code>
                    sendMessage(message); 
              </code> ile mesajı gönderir. formMe message değişkenine dahil olmadığı için beckende gönderilmez.<br>
              <code>
                    setMessage(""); <br>
                  };<br>
                  return (<br>
                    &lt;div><br>
                      &lt;form onSubmit={handleSubmit}><br>
                        &lt;input<br>
                          className={styles.textInput}<br>
                          value={message}<br>
                          onChange={(e) => setMessage(e.target.value)}<br>
                        /><br>
                      &lt;/form><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default ChatForm;

              </code>
            </p>
            <p>
              Alınan mesajları listelemek için socketApi.js içinde aşağıdaki fonksiyon yazıldı: <br>
              <code>
                export const subscribeChat = (cb) => { <br>
                  if(!socket) return;<br><br>
                
                  socket.on("receive-message", (message)=>{
              </code> receive-message kanalı dinlenir. Oradan gelen mesaj bilgisi alınır. <br>
              <code>
                    console.log("Yeni mesaj var", message); <br>
                    cb(message) 
              </code> fonksiyonun kullanıldığı yerde parametre olarak belirtilen fonksiyon cb() olarak çekilir ve içine parametre olarak message değişkeni kullanılır. <br>
              <code>
                  }) <br>
                }
              </code>
            </p>
            <p>
              Container.js içinde subscribeChat() fonksiyonu kullanılır. <br>
              <code>
                import React, { useEffect } from "react"; <br>
                import ChatList from "./ChatList";<br>
                import ChatForm from "./ChatForm";<br>
                import { useChat } from "../context/ChatContext";<br><br>

                import { init, subscribeChat } from "../socketApi";<br><br>

                function Container() {<br>
                  const { setMessages } = useChat();<br><br>

                  useEffect(() => {<br>
                    init();<br><br>

                    subscribeChat((message) => {<br>
                      setMessages((prevState) => [...prevState, { message }]);<br>
                    });
              </code> subscribeChat() fonksiyonu ile alınan veri messages değişkenine eklenir. Bu verilerde forMe değeri bulunmaz. <br>
              <code>
                  }, []); <br>
                  return (<br>
                    &lt;div className="App"><br>
                      &lt;ChatList /><br>
                      &lt;ChatForm /><br>
                    &lt;/div><br>
                  );
                }<br><br>

                export default Container;

              </code>
            </p>
            <p>
              ChatItem.js içinde listeleme yaparken forMe varlığı sorgulanır. forMe varsa ilave className alır. Buna bağlı olarak da stili değişir. Bizim gönderdiklerimizde forMe olur. Dışarıdan gelenlerde olmaz. <br>
              <code>
                import React from "react"; <br>
                import styles from "./styles.module.css";<br><br>

                function ChatItem({ item }) {<br>
                  return &lt;div className={`${styles.chatItem} ${item.fromMe ? styles.right : ""}`}>{item.message}&lt;/div>;<br>
                }<br><br>

                export default ChatItem;

              </code>
            </p>
          </div>
          <div class="row" id="listMessages">
            <h1>Mesajların Listelenmesi</h1>
            <p>
              SocketApi.js içine listelenmiş mesajları alması için bir fonksiyon eklendi. <br>
              <code>
                export const subscribeInitialMessages = (cb) => { <br>
                  if (!socket) return; <br><br>
                
                  socket.on("message-list", (messages) => { <br>
                    console.log("Initial", messages); <br>
                    cb(messages); <br>
                  }); <br>
                }; 
              </code> Mesajların gösterilmesi için kullanılan tekniğin aynısı kullanıldı. Sadece kanal adı değiştirildi. 
            </p>
            <p>
              Gelen veri Container.js içinde karşılandı. <br>
              <code>
                import React, { useEffect } from "react"; <br>
                import ChatList from "./ChatList";<br>
                import ChatForm from "./ChatForm";<br>
                import { useChat } from "../context/ChatContext";<br><br>

                import { init, subscribeChat, subscribeInitialMessages } from "../socketApi";<br><br>

                function Container() {<br>
                  const { setMessages } = useChat();<br><br>

                  useEffect(() => {<br>
                    init();<br><br>

                    subscribeInitialMessages((messages) => setMessages(messages))
              </code>backend tarafından alınan mesaj bilgisi messages değişkeni olarak atandı.<br><br>
              <code>
                    subscribeChat((message) => {<br>
                      setMessages((prevState) => [...prevState, { message }]);<br>
                    });<br>
                  }, []);<br>
                  return (<br>
                    &lt;div className="App"><br>
                      &lt;ChatList /><br>
                      &lt;ChatForm /><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Container;

              </code>
            </p>
            <p>
              Geçmiş mesajlar uygulamamız ilk açıldığında messages değişkenine atanıp listeleniyor. Geldiği yere forMe özelliği olmadan gönderildiğinden tüm mesajlar aynı görünüyor. user girişi olmadan bunu değiştirmenin bir yolu yok.
            </p>
          </div>
          <div class="row" id="feedScroll">
            <h1>Feed Scroll</h1>
            <p>
              Bunun için <a href="https://www.npmjs.com/package/react-scrollable-feed">react-scrollable-feed</a> kütüphanesini kullanacağız. 
            </p>
            <p>
              Terminale: <br>
              <code>
                npm i react-scrollable-feed
              </code>
            </p>
            <p>
              Chatlist.js içinde modülü import edip scrollun beslendiği alanı modülle sarmalayacağır. <br>
              <code>
                import React from "react"; <br>
                import { useChat } from "../context/ChatContext";<br>
                import ChatItem from "./ChatItem";<br>
                import styles from "./styles.module.css";<br>
                import ScrollableFeed from "react-scrollable-feed"<br><br>

                function ChatList() {<br>
                  const { messages } = useChat();<br>
                  return (<br>
                    &lt;div className={styles.chatlist}><br>
                      &lt;ScrollableFeed><br>
                        {messages.map((item, key) => (<br>
                          &lt;ChatItem key={key} item={item} /><br>
                        ))}<br>
                      &lt;/ScrollableFeed><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default ChatList;

              </code>
            </p>
          </div>
          <div class="row" id="reactIntl">
            <h1>React Intl - Kurulum</h1>
            <p>
              Lokalization işlemleri yani dil ile alakalı işlemleri gerçekleştirmek.
            </p>
            <p>
              Kullanıcağımız kütüphane <a href="https://formatjs.io/docs/getting-started/installation">React Intl</a> terminale:
              <code>
                npm i react-intl
              </code>
            </p>
            <p>
              App.js içinde import edilir ve kullanılır. <br>
              <code>
                import "./App.css";<br><br>

                import { IntlProvider, FormattedMessage, FormattedNumber } from "react-intl";
              </code> ile kullanılacak ksımlar import edilir. <br>
              <code>
                import { useState } from "react";<br><br>

                const messages = { 
              </code> ile kullanılacak veri oluşturulur. <br>
              <code>
                  "tr-TR": {<br>
                    title: "Merhaba Dünya",<br>
                    description: "3 yeni mesaj",<br>
                  },<br>
                  "en-US": {<br>
                    title: "Hello World",<br>
                    description: "3 new messages"<br>
                  }<br>
                  
                };<br><br>

                function App() {<br>
                  const [lang, setLang] = useState("tr-TR") 
              </code> ile dil değişimi için state tanımlanır. <br>
              <code>
                  return ( <br>
                    &lt;div className="App"> <br>
                      &lt;IntlProvider messages={messages[lang]}>
              </code> ile react-intl kullanılacak alan kaplanır ve yayınlanacak mesajın verildiği obje messages keyi ile belirtilir. <br>
              <code>
                        &lt;FormattedMessage id="title" /> 
              </code> id içinde verilen değer messages objesindeki gösterilmek istenen key değeridir. <br>
              <code>
                        &lt;p> <br>
                        &lt;FormattedMessage id="description" /> <br>
                        &lt;/p><br>
                        &lt;br /> &lt;br /><br>
                        &lt;button onClick={()=>setLang("tr-TR")}>TR&lt;/button><br>
                        &lt;button onClick={()=>setLang("en-US")}>EN&lt;/button><br>
                      &lt;/IntlProvider><br>
                    &lt;/div><br>
                  );
                }<br><br>

                export default App;

              </code>
            </p>

          </div>
          <div class="row" id="defaultLocale">
            <h1>Default Locale</h1>
            <p>
              Açılışta browser dili ile aynı dilin atanmasını ve daha sonra seçilen dilin sayfa yenilendiğinde kalmasını sağlayacağız.
            </p>
            <p>
              navigator arabirimi, kullanıcı aracısının durumunu ve kimliğini temsil eder. Komut dosyalarının onu sorgulamasına ve bazı etkinlikleri yürütmek için kendilerini kaydettirmesine olanak tanır. İleri okuma için <a href="https://developer.mozilla.org/en-US/docs/Web/API/Navigator">tıklayınız.</a>
            </p>
            <p>
              <code>
                import "./App.css"; <br>

                import { IntlProvider, FormattedMessage } from "react-intl";<br>
                import { useEffect, useState } from "react";<br><br>

                const messages = {<br>
                  "tr-TR": {<br>
                    title: "Merhaba Dünya",<br>
                    description: "3 yeni mesaj",<br>
                  },<br>
                  "en-US": {<br>
                    title: "Hello World",<br>
                    description: "3 new messages",<br>
                  },<br>
                };<br><br>

                function App() {<br>
                  const defaultLocale = localStorage.getItem("lang") || navigator.language;
              </code> localStorage içinde lang tanımı varsa onu alır. Yoksa browser default değerini alır. <br>
              <code>
                  const [lang, setLang] = useState(defaultLocale);<br><br>

                  useEffect(()=>{ <br>
                    localStorage.setItem("lang", lang);<br>
                  }, [lang])
              </code> lang değeri değiştiğinde değişen değeri localStorage içine gönderir. <br>
              <code>
                  return (<br>
                    &lt;div className="App"><br>
                      &lt;IntlProvider locale={lang} messages={messages[lang]}><br>
                        &lt;FormattedMessage id="title" /><br>
                        &lt;p><br>
                          &lt;FormattedMessage id="description" /><br>
                        &lt;/p><br>
                        &lt;br /> &lt;br /><br>
                        &lt;button onClick={() => setLang("tr-TR")}>TR&lt;/button><br>
                        &lt;button onClick={() => setLang("en-US")}>EN&lt;/button><br>
                      &lt;/IntlProvider><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default App;

              </code>
            </p>
          </div>
          <div class="row" id="parametreGecmek">
            <h1>Parametre Geçmek</h1>
            <p>
              Kullanılacak veri içine FormattedMessage içinden parametre gönderebiliriz. <br>
              <code>
                import "./App.css"; <br>

                import { IntlProvider, FormattedMessage } from "react-intl";<br>
                import { useEffect, useState } from "react";<br><br>

                const messages = {<br>
                  "tr-TR": {<br>
                    title: "Merhaba Dünya",<br>
                    description: "{count} yeni mesaj", 
              </code> parametrenin alınıp kullanıldığı yer. <br>
              <code>
                  },<br>
                  "en-US": {<br>
                    title: "Hello World",<br>
                    description: "{count} new messages", 
              </code> parametrenin alınıp kullanıldığı yer. <br>
              <code>
                  },<br>
                };<br><br>

                function App() {<br>
                  const defaultLocale = localStorage.getItem("lang") || navigator.language;<br>
                  console.log(defaultLocale);<br>
                  const [lang, setLang] = useState(defaultLocale);<br><br>

                  useEffect(()=>{<br>
                    localStorage.setItem("lang", lang);<br>
                  }, [lang])<br>
                  return (<br>
                    &lt;div className="App"><br>
                      &lt;IntlProvider locale={lang} messages={messages[lang]}><br>
                        &lt;FormattedMessage id="title" /><br>
                        &lt;p><br>
                          &lt;FormattedMessage id="description" values={{count: 5}}/>
              </code> Parametrenin gönderildiği yer. <br>
              <code>
                        &lt;/p><br>
                        &lt;br /> &lt;br /><br>
                        &lt;button onClick={() => setLang("tr-TR")}>TR&lt;/button><br>
                        &lt;button onClick={() => setLang("en-US")}>EN&lt;/button><br>
                      &lt;/IntlProvider><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default App;

              </code>
            </p>
          </div>
          <div class="row" id="nedenTest">
            <h1>Neden Test Yazarız?</h1>
            <p>
              Birden fazla kompanent yazdığımızda ve her birini yazdıktan hemen sonra test ettiğimizde, daha sonra yazdığımız bir kodun daha öncekini bozup bozmadığını bilemeyiz. Bunun için her işlemin sonunda hepsini test etmek gerekir.
            </p>
            <p>
              Bu süreci otomatize etmek için test yazarız.
            </p>
            <p>
              <code>npx create-react-app project</code> ile yeni bir proje oluşturduğumuzda ilk test dosyamız src/App.test.js olarak hazır gelir. terminale <code>npm test</code> yazarak çalıştırılır.
            </p>
            <p>
              Test dosyaları KompanentAdi.test.js olarak yazılır.
            </p>
            <p>
              App.test.js <br>
              <code>
                import { render, screen } from '@testing-library/react'; <br>
                import App from './App';
              </code> tet edilecek kompanent import edildi. <br>
              <code><br>

                test('renders learn react link', () => {<br>
                  render(&lt;App />);
              </code>App kompanentini render ederken<br>
              <code>
                  const linkElement = screen.getByText(/learn react/i);
              </code>Ekranda "learn react" yazısını arar. ve linkElement değişkenine atar.<br>
              <code>
                  expect(linkElement).toBeInTheDocument();
              </code>linkElement değişkenini döküman içinde olma durumunu değerlendirir. True dönerse test olumlu döner.<br>
              <code>
                });

              </code>
            </p>
          </div>
          <div class="row" id="reactTestingLibrary1">
            <h1>React Testing Library Örnek 1</h1>
            <p>
              src/components/Counter dosyası içinde:
            </p>
            <p>
              index.js: <br>
              <code>
                import React, { useState } from "react"; <br><br>

                function Counter() { <br>
                  const [count, setCount] = useState(0);<br>
                  return (<br>
                    &lt;div><br>
                      &lt;h1>{count}&lt;/h1><br>
                      &lt;button onClick={() => setCount(count + 1)}>Increase&lt;/button><br>
                      &lt;button onClick={() => setCount(count - 1)}>Decrease&lt;/button><br>
                    &lt;/div><br>
                  );<br>
                  }
                  <br><br>
                export default Counter;

              </code><br>
              ile test edilecek kompanent yazıldı ve App.js içinde kullanıldı.
            </p>
            <p>
              Aynı klasör içide Counter.test.js: <br>
              <code>
                import { render, screen } from "@testing-library/react";
              </code> "render" kompanent render eder. "screen" DOM üzerindeki nesneyi yakalar. <br>
              <code>

                import userEvent from "@testing-library/user-event"; <br>
                import { act } from "react-dom/test-utils"; <br>
                import Counter from ".";<br><br>

                describe("Counter Test", ()=>{ 
              </code>Her testte ortak olan işlemler için testler bu yapı içine alınır. <br><br>
              <code>

                    let increaseBtn, decreaseBtn, count
              </code>ile ortak kullanılacak değişkenler tanımlanır. <br><br>
              <code>
                    
                    beforeEach(()=>{ 
              </code> Test ifadesi başlamadan önce gereken işlemler burada yazılabilir. Her testten önce çalışır. <br>
              <code>
                        render(<Counter/>); 
              </code> ile counter render edildi <br><br>
              <code>
                    
                        count = screen.getByText("0");<br>
                        increaseBtn = screen.getByText("Increase"); 
              </code> ile içinde "Increase" yazan kompanent bulundu <br>
              <code>
                        decreaseBtn = screen.getByText("Decrease"); 
              </code> ile içinde "Decrease" yazan kompanent bulundu. <br>
              <code>
                        console.log("her testten önce çalışırım");<br>

                    })<br><br>

                    beforeAll(()=>{ 
              </code> Bu ifade beforeEach den farklı olarak her testten önce tekrar çalışma için değil test sırasında testlerden önce bir kere çalışma için kullanılır. <br>
              <code>
                        console.log("en başta bir kere çalışırım"); <br>
                    }) <br><br>

                    afterEach(()=>{ <br>
                        console.log("Her testten sonra çalışırım"); <br>
                    }) <br><br>

                    afterAll(()=>{<br>
                        console.log("en sonda bir kere çalışırım");<br>
                    })<br><br>

                    it('increase btn', ()=>{ 
              </code> test satırı "it" (veya "test") ile başlar. hemen arkasından açıklaması gelir. sonra callback ile test yazılır. <br><br>
              <code>
                    
                        act(()=>{<br>
                            userEvent.click(increaseBtn); 
              </code> ile butona tıklandı <br>
              <code>
                        })<br>
                        expect(count).toHaveTextContent("1")
              </code> ile butona tıklandığında beklenen aksiyon yazıldı. <br>
              <code>
                    }) <br><br>
                    it('decrease btn', ()=>{<br><br>
                        
                        act(()=>{<br>
                            userEvent.click(decreaseBtn);<br>
                        })<br>
                        expect(count).toHaveTextContent("-1")<br>
                    })<br>
                })<br>

              </code>
            </p>
          </div>
          <div class="row" id="reactTestingLibrary2">
            <h1>React Testing Library Örnek 2</h1>
            <p>
              src/components/Todo dosyası içinde: 
            </p>
            <p>
              index.js: <br>
              <code>
                import React, { useState } from 'react' <br>
                const defaultItems = [ 
              </code> ile default değerler atanır. <br>
              <code>
                    {
                        name: "Item A",
                    },<br>
                    {
                        name: "Item B",
                    },<br>
                    {
                        name: "Item C",
                    },<br>
                ]<br><br>

                function Todo() {<br>
                    const [text, setText] = useState("");<br>
                    const [items, setItems] = useState(defaultItems);<br>
                    const addItem = () => {<br>
                        setItems((prevState) => [...prevState, {name: text}]);<br>
                        setText("")<br>
                    }<br>
                  return (<br>
                    &lt;div><br>
                        &lt;label htmlFor='input'>Input&lt;/label><br>
                        &lt;input id="input" value={text} onChange={(e)=> setText(e.target.value)}/><br>
                        &lt;button onClick={addItem}>Add&lt;/button><br>
                        &lt;br />&lt;br /><br>
                        {<br>
                            items.map((item, key)=>(<br>
                                &lt;div key={key}>{item.name}&lt;/div><br>
                            ))<br>
                        }<br>
                    &lt;/div><br>
                  )
                }<br><br>

                export default Todo
              </code>
            </p>
            <p>
              Todo.test.js içinde: <br>
              <code>
                import { render, screen } from "@testing-library/react"; <br>
                import userEvent from "@testing-library/user-event";<br>
                import { act } from "react-dom/test-utils";<br>

                import Todo from ".";
              </code> ile test edilecek kompanent import edilir.<br>
              <code><br>

                describe("Todo testleri", () => { <br>
                  let button, input;<br>
                  beforeEach(() => {<br>
                    render(&lt;Todo />);<br>
                    button = screen.getByText("Add");<br>
                    input = screen.getByLabelText("Input");<br>
                  });
              </code> ile testlerde gerekecek tanımlar hazırlanır. <br>
              <code><br>

                  test("Varsyılanları listele", () => {<br>
                    const items = screen.getAllByText(/Item/i);
              </code>Ekranda Item ile başlayan metinleri bul. <br>
              <code>

                    expect(items.length).toEqual(3);
              </code> Sorgula: bulunan itemlerden oluşan array 3 elemanlı mı? <br>
              <code> 
                  });<br><br>

                  test("input ve buton dökümanda bulunmalı", () => {<br>
                    expect(button).toBeInTheDocument();<br>
                    expect(input).toBeInTheDocument();
              </code> button ve input değişkenine tanımlanmış elemanlar sayfada var mı? <br>
              <code><br>
                  });<br><br>

                  test("inputa string girilip butona basılınca listeye eklemeli.",()=>{<br>
                    const name = "Murat"
              </code> forma yazılacak değişken <br>
              <code>
                    act(()=>{<br>
                        userEvent.type(input, name); 
              </code> input değişkenine atadığımız html varlığına name değişkenini yaz. <br>
              <code>
                        userEvent.click(button);
              </code> ile butona tıkla <br>
              <code>
                    })<br><br>

                    expect(screen.getByText(name)).toBeInTheDocument()
              </code> Sorgula: name değişkeni dökümanda var mı? <br>
              <code>
                  })
                });<br>

              </code>
            </p>
          </div>
          <div class="row" id="createReactLibrary">
            <h1>create-react-library</h1>
            <p>
              Yaptığımız kütüphaneyi npmjs.com üzerinden paylaşmayı öğreneceğiz.
            </p>
            <p>
              Yazacağımız kütüphanenin adı unique olmak zorunda. Bunu da <a href="https://remarkablemark.org/npm-package-name-checker/">buradan</a> kontrol edebiliriz.
            </p>
            <p>
              terminale:
              <code>
                npx create-react-library
              </code> <br>
              veya <br>
              <code>
                npm install -g create-react-library
              </code> ile global kurulur ve <br>
              <code>
                create-react-library
              </code> ile çalıştırılır.
            </p>
            <p>
              Gelen form terminalde doldurulur.
            </p>
            <p>
              Kurulan yapının içinde iki adet çalıştırılacak kompanent var. Önce terminalden kök dizine girilip <code>npm start</code> yapılır. Sonra terminalden example klasörüne girilip <code>npm start</code> yapılır.
            </p>
            <p>
              node.js güncel versiyonda example içinde verilen komut kata veriyor. Bunu önlemek için example/package.json script alanında start keyinin valuesinin sonundaki start kelimesi <q>--openssl-legacy-provider start</q> ile değiştirilir.
            </p>
            <p>
              Oluşturduğumuz kütüphanenin denemesi example içinde import edilmiş olarak verilir. Biz de bunların üzerinde çalışacağız.
            </p>
          </div>
          <div class="row" id="publishislemleri">
            <h1>Publish İşlemleri</h1>
            <p>
              npmjs.org üzerinden paylaşmak için bir önceki konuda oluşturduğumuz yapı üzerinden bir kompanent oluşturacağız.
            </p>
            <p>
              src/index.js içinde: <br>
              <code>
                import React from 'react' <br>
                import styles from './styles.module.css'<br><br>

                export const ExampleComponent = ({ text }) => {<br>
                  return &lt;div className={styles.test}>Example Component: {text}&lt;/div><br>
                }
              </code> bu hazır gelen modül <br>
              <code><br>

                export const Button = (props) => {<br>
                  return(<br>
                    &lt;button {...props}>{props.text}&lt;/button> 
              </code> bu şekilde yazıldığında gönderilen tüm propları alır. <br> 
                  ) <br>
                }<br>
              </code>
            </p>
            <p>
              example/src/App.js içinde: <br>
              <code>
                import React from 'react'<br>

                import { ExampleComponent, Button } from 'ravenui-test'<br>
                import 'ravenui-test/dist/index.css'<br>

                const App = () => {<br>
                  return (<br>
                  &lt;><br>
                    &lt;ExampleComponent text="Create React Library Example 😄" />
              </code> hazır gelen modül. <br>
              <code>
                    &lt;Button text="Click"/> 
              </code> html button etiketinin alacağı özellikleri burada veremeyiz çünkü burada sadece tanımladığımız modülü kullanıyoruz. Bu özellikleri modül tanımı kısmında girerek kullanabiliriz veya prop olarak gönderip kullanabiliriz. <br>
              <code>
                  &lt;/><br>
                  )<br>
                }<br><br>

                export default App

              </code>
            </p>
            <p>
              Yayınlamak için npmjs.org a üye oluyoruz.
            </p>
            <p>
              Terminale <br>
              <code>
                npm login
              </code> yazılıp gelen form doldurulur.
            </p>
            <p>
              terminale: <br>
              <code>
                npm publish
              </code> yazılarak oluşturduğumuz kütüphane upload edilir.
            </p>
            <p>
              Aynı isimde kütüphane var hatası alınırsa package.json dosyasından isim değiştirilebilir.
            </p>
          </div>
          <div class="row" id="sematicVersiyonlama">
            <h1>Semantic Versiyonlama</h1>
            <p>
              Versiyon numarası package.json üzerinden verilir. nokta ile ayrılan 3 sayıdan oluşur. <q>3.0.2</q> gibi.
            </p>
            <p>
              En sondaki sayı ufak hataları, patch işlemlerini vs yaptığımızda değiştirilir.
            </p>
            <p>
              Ortadaki sayı minör değişikliklerde arttırılır.
            </p>
            <p>
              En baştaki sayı major değişiklikleri gösterir. Sistemin tamamen değiştiğini gösterir.
            </p>
            <p>
              Versiyon değişikliği için terminale: <br>
              <code>
                npm version patch --f
              </code> yazılarak sondaki sayı 1 arttırılır. <br>
              <code>
                npm version minor --f
              </code> yazılarak ortadaki sayı 1 arttırılır. <br>
              <code>
                npm version major --f
              </code> yazılarak baştaki sayı 1 arttırılır. <br>
            </p>
            <p>
              soldaki sayı arttığında sağdakiler sıfırlanır.
            </p>
            <p>
              terminale <br>
              <code>
                npm publish 
              </code> ile güncelleme gönderilir.
            </p>
            <p>
              Kütüphanemizi kullanan kullanıcının kendi versiyonunu güncellemesi için terminale: <br>
              <code>
                npm upgrade ravenui
              </code> yazılır.
            </p>
            <p>
              Kullanıcının sistemi güncellemeyi kabul etmezse <br>
              <code>
                npm upgrade ravenui --force
              </code> yazılır.
            </p>
          </div>
          <div class="row" id="surgeSh">
            <h1>Surge.sh</h1>
            <p>
              Demo gösterimleri için ideal. Yetenekleri sınırlı
            </p>
            <p>
              Önce surge.sh bilgisayara global olarak kurulur. Bunun için terminale: <br>
              <code>
                npm install --global surge
              </code>
              <p>
                Sonra deploy etmek istediğimiz dizine gelip terminale: <br>
                <code>
                  surge
                </code> yazılır.
              </p>
              <p>
                Gelen ekrana email ve şifre girilir ve form doldurulur.
              </p>
              <p>
                react projesi deploy edilmeden önce build yapılır. Bunun için terminale: <br> 
                <code>
                  npm run build
                </code> yazılır. <br>
                Daha sonra bu dizine girilip <code>surge</code> komutu çalıştırılır.
              </p>
              <p>
                Her güncelleme sonrası build işlemi tekrar yapılır ve ardından deploy edilir. Deploy sırasında yeni bir domain önerebilir. Biz eski domaini elle girerek mevcut siteyi güncelleyebiliriz.
              </p>
              <p>
                Yukarıdaki işlemi her seferinde tekrar yapmaktansa package.json dosyasına kısa yol girebiliriz. Bunun için package.json>scripts alanına: <br>
                <code>
                  "deploy": "npm run build && surge"
                </code> eklenir. ve gerektiğinde <code>npm run deploy ile çalıştırılır.</code>
              </p>
            </p>
          </div>
          <div class="row" id="netlify">
            <h1>Netlify</h1>
            <p>
              Daha kapsamlı. Küçük ve orat ölçekli projeler için ideal.
            </p>
            <p>
              Kayıt ol. giriş yap.
            </p>
            <p>
              github üzerindeki repodan projeyi çekiyor.
            </p>
            <p>
              React projesini yükleyebilmek için build işlemini netlify kendisi yapıyor.</b>
            </p>
            <p>
              sitede <q>add new site</q> yi tıklayarak ve oradaki yönergeleri takip ederek projemizi deploy edebiliriz.
            </p>
            <p>
              deploy sırasında aldığım bir hata ve çözümi için <a href="https://stackoverflow.com/questions/64468843/netlify-deployment-failed-during-stage-building-site-build-script-returned-n">tıklayınız</a>
            </p>

            <p>
              Bağlı olduğu git reposu güncellendiğinde netlify deploy işlemini tekrar yapar.
            </p>
            <p>
              netlfy üzerinde kullanılan react projelerinde anasayfa dışında sayfa yenilenirse sayfa hata verir. Bu hata sayfa linklerinin backend üzerinde değil client üzerinde var olmasıdır. Bunu düzeltmek için projenin public dizininde <b>_redirects</b> dosyası oluşturulur ve içine <br>
              <code>
                /*    /index.html   200
              </code> yazılır. Bu sayede tüm yönlendirmeler netlify tarafından algılanır.
            </p>

            <h2>Netlify'da Neler Yapabiliriz?</h2>

            <h3>Custom domain</h3>
            <p>site setting>domain management>add custom domain</p>

            <h3>Deploydan önce test kodunu çalıştırmak</h3>
            <p>
              site settings>Build & deploy> Continuous Deployment kısmındaki build command satırını "npm test && npm run build" olarak güncellersek önce testi çalıştırır. Testi geçerse deploy yapar
            </p>

            <h3>Deploy Notifications</h3>
            <p>
              site settings>Build & deploy>Deploy notifications
            </p>

            <h3>Ortam Değişkenini Netlify'de Kullanmak</h3>

            <p>
              Önce ortam değişkeni oluşturuyoruz. bunun için kök dizinde .env dosyası oluşturduk. İçine: <br>
              <code>
                REACT_APP_API_ENDPOINT=https://api.openweathermap.org
              </code> "REACT_APP" muhakkak yazmalı. 
            </p>
            <p>
              Bu şekilde oluşturulan ortam değişkeni proje içinde istenildiği yerde: <br>
              <code>
                process.env.REACT_APP_API_ENDPOINT
              </code> olarak kullanılır.
            </p>
            <p>
              deploy edildiğinde ortam değişkenlerini github a gönderilmez (.gitignore). Bu nedenle Netlify okuyamaz. Bu nedenle bu değişkenleri biz ekleriz.
            </p>
            <p>
              site settings>Build & deploy>Enviroment kısmında ortam değişkenleri eklenir ve proje tetrar deloy edilir.
            </p>

            <h3>Önceki Deployları Görmek</h3>
            <p>
              Deploys ekranında tıklayıp açtığımız deployda permalink veya preview butonu ile daha önceki deploy versiyonlarını görebiliriz.
            </p>
          </div>
          <div class="row" id="awsEc2Deploy">
            <h1>AWS EC2 Üzerine Deploy İşlemleri</h1>
            <p>
              AWS ye üye ol ve giriş yap. Arama ekranına ec2 yaz. Launch instance butonuna bas. Gelen listeden ubuntu server seç. free tier olanı seç.
            </p>
            <p>
              Network setting içinde Create security group kısmında ssh protokolüne bir de http ve https ekle. Her üçü için de "Source type: anywhere" seçilir. 
            </p>
            <p>
              Launch butonuna basılır. Gelen ekranda key-pair oluşturulup bilgisayara indirilir. Bu dosya bizim daha sonra oluşturduğumuz sanal makinaya ulaşmamızı sağlayacak.
            </p>
            <p>
              Instances içinden yeni sanal makinamzı bulup public IP address kopyalanır. Sonra key pairsin olduğu klasörde terminale: <br>
              <code>
                ssh -i react-app.pem ubuntu@13.53.146.5
              </code> yazılır ve gelen soruya <b>yes</b> yazılır.
            </p>
            <p>
              Bu işlem sırasında 
              <q>
                Warning: Permanently added "3.127. 945.215" (ECDSA) to the list of known hosts. <br>
                ubuntu@3.127.145.215: Permission denied (publickey).
              </q> <br>
              hatası alırsak terminale: <br>
              <code>
                chmod 400 react-app.pem
              </code> yazılarak dosyaya izin verilmiş olunur.
            </p> 
            <p>
              terminalde <code>ubuntu@ip-172-31-4-204:</code> yazıyorsa oluşturduğumuz sanal makinaya bağlandığımızı gösterir.
            </p>
            <p>
              terminale <br>
              <code>
                sudo apt-get update
              </code> ile ubuntu paketleri güncellenir.
            </p>
            <p>
              node.js kurmak için terminale: <br>
              <code>
                curl -fsSL https://deb.nodesource.com/setup_14.x | sudo -E bash - &&\ <br>
                sudo apt-get install -y nodejs
              </code> 7komutunu yazdım. <br>
              Bu komutları node.js dökümantasyonundan bulduk. İhtiyaca uygun olanı oradan sağlayabiliriz.
            </p>
            <p>
              terminale: <br>
              <code>
                sudo apg-get install ngnix
              </code> yazarız. Bu aşamada public IP tarayıcıya yazılırsa bizi <q>Welcome to nginx!</q> sayfası karşılar.
            </p>
            <p>
              wiki: "Nginx; yüksek eş zamanlı çalışma kabiliyeti, yüksek performans ve düşük hafıza kullanımına odaklanılarak tasarlanmış bir Web sunucusudur. Aynı zamanda ters vekil sunucusu, yük dengeleyici ve HTTP ön belleği olarak da kullanılabilir."
            </p>
            <p>
              projeyi yüklemek için terminale: <br>
              <code>
                git clone &lt;proje adresi>
              </code>
            </p>
            <p>
              Klonlanma tamamlandıktan sonra terminale: <br>
              <code>
                dir
              </code> yazarak mevcut dosya görüntülenir. <br>
              <code>
                cd &lt;dosya_adı> 
              </code> yazılarak içine girilir. <br>
              <code>
                npm i 
              </code> ile gerekli paketler kurulur.
            </p>
            <p>
              <code>
                npm run build
              </code> ile build oluşturulur.
            </p>
            <p>
              terminale: <br>
              <code>
                sudo vi /etc/nginx/sites-available/default
              </code> yazarak nginx ayar sayfası açıldı. <br>
              sayfanın root kısmına build'imizin adresini yazıyoruz. <br>
              <code>
                root /home/ubuntu/weather2/build;
              </code>
            </p>
            <p>
              <code>
                service nginx reload
              </code> yazılarak nginx terkrar başlatılır.
            </p>
            <p>
              Ortam değişkenlerini de servere yüklemek için terminale: <br>
              <code>
                vi .env
              </code> ile env dosyası oluşturulur. içine <br>
              <code>
                REACT_APP_API_ENDPOINT=https://api.openweathermap.org
              </code> yazıp kaydedip kapatıyoruz (esc -> :wq)
            </p>
            <p>
              tekrar build oluşturuyoruz ve nginx terkrar başlatılır
            </p>
            <p>
              daha önce deploy ettiğimizde sayfa değiştirip yenile yaptığımızda hata alıyorduk. Bu hatayı almamak için: <br>
              <code>
                sudo vi /etc/nginx/sites-available/default
              </code> içindeki <br>
              <code>
                try_files $uri $uri/ =404;
              </code> kodunu <br>
              <code>
                try_files $uri $uri/ =index.html;
              </code> olarak güncellenir ve nginx terkrar başlatılır
            </p>
            <p>
              git reposu güncellendiğinde güncel hali almak için terminale: <br>
              <code>
                sudo git pull
              </code> sonra <br>
              <code>
                npm run build
              </code> ile build oluşturulur.
            </p>
          </div>
          <div class="row" id="tanitim">
            <h1>Uygulama Tanıtımı</h1>
            <p>
              Ürünlerin listelendiği ve sipariş edildiği bir e-ticaret sitesi taslağı yapacağız.
            </p>
            <p>
              Giriş yapılacak, sepete ürün eklenecek ve satın alınacak.
            </p>
            <p>
              Ürünün detay sayfası var.
            </p>
            <p>
              Listede aşağı inildikçe daha fazla seçenek açılacak.
            </p>
            <p>
              Sipariş verince admin tarafına düşecek ve orada yönetilecek.
            </p>
            <p>
              Kullanılacak teknoloji: React Router, React Query, Context, JWT (auth), Chakra (UI), Ant Design (UI), Formik, mongoDB, redis 
            </p>
          </div>
          <div class="row" id="backendeGenelBakis">
            <h1>Backend'e Genel Bakış</h1>
            <p>
              Backend hazır verildi. Terminalde backend dizinine girilip <br>
              <code>npm i</code> ile gerekli modülleri kuruldu. <br>
              <code>npm i -D nodemon</code> ile nodemon kuruldu <br>
              <code>npm dev</code> ile başlatıldı.
            </p>
            <p>
              Backendin çalışması için mondoDB ve redis yüklü olmalı.
            </p>
            <p>
              redisin çalışması için terminale: <br>
              <code>server-redis</code> yazıyoruz.
            </p>
            <p>
              src içine .env oluşturup içine: <br>
              <code>
                MONGO_URI=mongodb://localhost:27017
              </code> tanımı girilir.
            </p>
            <p>
              mongoDB içinde test adında bir database oluşturulup orders, users ve products koleksiyonları oluşturulur ve hazır veriler buralara eklenir.
            </p>
            <p>
              Postman kullanılarak backend test edilebilir. Gönderilen işleme nasıl bir geri dönüş sağladığını görebiliyoruz.
            </p>
            <p>
              Login işlemi sırasında bir accessToken ve refreshToken oluşturuluyor. Bu veriler local storage üzerinde tutulabilir ve kullanıcı bir güncelleme yapmak istediğinde auth işlemi için kullanılabilir. accessToken'ın ömrü kısa. Bu ömür bittiğinde refreshToken üzerinden yenilenir. refreshToken da yoksa tekrar login ister. Bu kısmın düzgün çalışması için ortam değişkeni olarak .env dosyasına <br>
              <code>
                JWT_SECRET=sdgkMKEVlm3v23kl_n423vGG3b_YVnm234xnv23 <br>
                JWT_REFRESH_SECRET=rerv1jv15v1CVBnasd23jnv1j3123nvrqwr23
              </code> eklenir. keyler aynı kalmak koşuluyla value istediğimiz gibi girilebilir.
            </p>
          </div>
          <div class="row" id="chakraUI">
            <h1>Chakra UI Kurulumu</h1>
            <p>
              <code>
                npx create-react-app client
              </code>
            </p>
            <p>
              <code>
                npm install react-router-dom
              </code> ile react router v6 kuruldu ve App.js içinde yerleştirildi.
            </p>
            <p>
              App.js içinde <br>
              <code>
                import "./App.css" <br>
                import { BrowserRouter as Router, Link, Route, Routes } from "react-router-dom"; <br>
                import Navbar from "./components/Navbar";<br><br>

                function App() {<br>
                  return (<br>
                    &lt;Router><br>
                      &lt;h1>Welcome&lt;/h1><br>
                      &lt;Navbar/><br>
                      &lt;div id="content"><br>
                      &lt;Routes><br>
                        &lt;Route path="/" element={&lt;Home />} /><br>
                      &lt;/Routes><br>
                      &lt;/div><br>
                    &lt;/Router><br>
                  );<br>
                }<br><br>

                function Home() {<br>
                  return &lt;h2>Home&lt;/h2><br>
                }<br><br>

                export default App;

              </code>
            </p>
            <p>
              App.css içine aşağıdaki tanım girildi: <br>
              <code>
                #content{<br>
                  padding: 15px;<br>
                }
              </code>
            </p>
            <p>
              src/components/Navbar içine index.js ve styles.module.css dosyası oluşturuldu. <br>
              index.js içine: <br>
              <code>
                import styles from "./styles.module.css";<br>
                import { Link } from "react-router-dom";<br><br>

                function Navbar() {<br>
                  return (<br>
                    &lt;div><br>
                      &lt;nav className={styles.nav}><br>
                        &lt;div className={styles.left}><br>
                          &lt;div className="logo"><br>
                            &lt;Link to="/">eCommance&lt;/Link><br>
                          &lt;/div><br>
                          &lt;ul className={styles.menu}><br>
                            &lt;li><br>
                              &lt;Link>Products&lt;/Link><br>
                            &lt;/li><br>
                          &lt;/ul><br>
                        &lt;/div><br><br>

                        &lt;div className="right">right&lt;/div><br>
                      &lt;/nav><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Navbar;

              </code> <br>
              styles.module.css içine:
              <code>             
                .nav{<br>
                  padding: 13px;<br>
                  display: flex;<br>
                  justify-content: space-between;<br>
                  border-bottom: solid 1px #e2e8f0;<br>
                  line-height: 2px;<br>
                  align-items: center; <br>
                }<br><br>

                .nav .left{<br>
                  display: flex;<br>
                }<br>

                .nav .left .menu{<br>
                  display: flex;<br>
                  margin-left: 40px;<br>
                }<br><br>

                .nav .left .menu li a {<br>
                  color: #4a5568;<br>
                  text-decoration: none;<br>
                  font-size: 1.1rem;<br>
                  padding: 3px 16px;<br>
                  display: block;<br>
                  font-size: 16px;<br>
                }<br><br>

                .nav .left .menu li a:hover {<br>
                  color: black;<br>
                }
              </code> itil tanımları girilir.
            </p>
            <p>
              Default stil tanımlarından kurtulmak için <a href="https://meyerweb.com/eric/tools/css/reset/">reset css</a> içindeki tanımlar kök dizinde reset.css dosyasına eklenir. Bu dosya kök dizindeki index.js dosyasına en alttaki stil tanımı olacak şekilde eklenir.
            </p>
            
            <h2>Chakra UI</h2>
            <p>
              Terminale <br>
              <code>
                npm i @chakra-ui/react @emotion/react @emotion/styled framer-motion
              </code>
            </p>
            <p>
              Tüm kompanentleri <code>&lt;ChakraProvider>&lt;/ChakraProvider></code> ile sarmalıyoruz. Bunu index.js veya App.js üzerinden yapabiliriz.
            </p>
            <p>
              Chakra UI için kullandığımzı yapılar için <a href="https://chakra-ui.com/getting-started">dökümantasyon sayfasını</a> kullanıyoruz.
            </p>
            <p>
              components/Navbar içine buton eklemek için önce butonu import ediyoruz. <br>
              <code>
                import { Button, ButtonGroup } from "@chakra-ui/react";
              </code> <br>
              Sonra bu butonu Link etiketi ile sarmalayıp kullanıyoruz. <br>
              <code>
                &lt;div className={styles.right}><br>
                  &lt;Link to="/singup"><br>
                    &lt;Button colorScheme="pink">Register&lt;/Button><br>
                  &lt;/Link><br>
                  &lt;Link to="/singin"><br>
                    &lt;Button colorScheme="pink">Login&lt;/Button><br>
                  &lt;/Link><br>
                &lt;/div>
              </code>
            </p>
            <p>
              Butonların bitişik olmaması için Navbar/styles.module.css dosyasına: <br>
              <code>
                .nav .right a:first-child {<br>
                  margin-right: 5px;<br>
                }
              </code> eklenir.
            </p>
            <p>
              Singin ve Singup kompanentlerinin şimdilik yerini tutmaları için components/pages/Auth klasörü içinde Singin ve Singup klasöründe index.js oluşturulup örnek kompanentler yapıldı. 
            </p>
            <p>
              Bu kompanentlere yönlendirme yapılması için App.js içinde yönlendirilecek kompanentler import edildi: <br>
              <code>
                import Singin from "./pages/Auth/Singin";<br>
                import Singup from "./pages/Auth/Singup";
              </code> <br>
              Routes etiketi içinde yönlendirmeler yapıldı. <br>
              <code>
                &lt;Routes><br>
                  &lt;Route path="/" element={&lt;Home />} /><br>
                  &lt;Route path="/singin" element={&lt;Singin/>} /><br>
                  &lt;Route path="/singup" element={&lt;Singup />} /><br>
                &lt;/Routes>
              </code>  
            </p>
          </div>
          <div class="row" id="productEkrani">
            <h1>Products Ekranının Hazırlanması</h1>
            <p>
              App.js üzerinde Routes altında <code>&lt;Route path="/" element={&lt;Products />} /></code> yönlendirmesi yapıldı.
            </p>
            <p>
              Components/Navbar içinde <code>&lt;Link to="/">Products&lt;/Link></code> yönlendirmesi yapıldı.
            </p>
            <p>
              src/pages/Products klasöründe index.js oluşturuldu. İçinde kullanmak için components/Card klasörü içinde index.js oluşturuldu: <br>
              <code>
                import { Box, Image, Button } from "@chakra-ui/react";<br>
                import { Link } from "react-router-dom";<br><br>

                function Card() {<br>
                  return (<br>
                    &lt;Box borderWidth="1px" borderRadius="lg" overflow="hidden" p="3">
              </code> Box chakra-ui kompanentidir. Tüm yapı Box ile sarıldı. <br>
              <code>
                      &lt;Link to="#/">
              </code> Yapı link haline getirildi. <br>
              <code>
                        &lt;Image src="https://picsum.photos/400/200" alt="product" /><br>

                        &lt;Box p="6"><br>
                          &lt;Box d="plex" alignItems="baseline"><br>
                            27/03/2023<br>
                          &lt;/Box><br>

                          &lt;Box mt="1" fontWeight="semibold" as="h4" lineHeight="tight"><br>
                            MacBook Pro<br>
                          &lt;/Box><br>
                          &lt;Box>100 TL&lt;/Box><br>
                        &lt;/Box><br>
                      &lt;/Link><br>

                      &lt;Button colorScheme="pink"><br>
                        Add to basket<br>
                      &lt;/Button><br>
                    &lt;/Box><br>
                  );<br>
                }<br><br>

                export default Card;

              </code> <br>
              Card taslağı Products/index.js içinde (şimdilik) yer tutucu olarak kullanıldı. <br>
              <code>
                import { Grid } from "@chakra-ui/react"; <br>
                import Card from "../../components/Card"; <br><br>

                function Products() {<br>
                  return (<br>
                    &lt;div><br>
                      &lt;Grid templateColumns="repeat(3, 1fr)" gap={4}>
              </code> Grid yapısı chakra-uı kompanentidir. gap boşluk miktarını repaet kaç kolon oduğunu verir. <br>
              <code>
                        &lt;Card /><br>
                        &lt;Card /><br>
                        &lt;Card /><br>
                        &lt;Card /><br>
                        &lt;Card /><br>
                      &lt;/Grid><br>
                    &lt;/div><br>
                  );<br>
                }<br>

                export default Products;

              </code>
              ve Product App.js içine import edildi.
            </p>
          </div>
          <div class="row" id="reactQuery">
            <h1>React Query</h1>
            <p>
              State yönetim aracı. Dökümantasyon için <a href="https://tanstack.com/query/latest/docs/react/overview">tıklayınız</a>
            </p>
            <p>
              Terminale: <br>
              <code>
                npm i @tanstack/react-query
              </code>
            </p>
            <p>
              src/index.js içinde import edilir ve <br>
              <code>
                import React from "react"; <br>
                import ReactDOM from "react-dom/client";<br>
                import "./index.css";<br>
                import "./reset.css";<br><br>

                <u>import { QueryClient, QueryClientProvider } from "@tanstack/react-query";</u><br><br>

                import { ChakraProvider } from "@chakra-ui/react";<br>
                import App from "./App";<br>
                import reportWebVitals from "./reportWebVitals";<br><br>

                <u>const queryClient = new QueryClient();</u>
              </code> ile yeni sorgu istemcisi oluşturulur. <br><br>
              <code> 

                const root = ReactDOM.createRoot(document.getElementById("root"));<br>
                root.render(<br>
                  &lt;React.StrictMode><br>
                    &lt;QueryClientProvider client={queryClient}>
              </code> ile tüm kompanentleri QueryClientProvider ile sarıyoruz. istemci olarak da yukaarıda oluşturduğumuz sorgu istemcisini gösteriyoruz. <br>
              <code>
                      &lt;ChakraProvider><br>
                        &lt;App /><br>
                      &lt;/ChakraProvider><br>
                    &lt;/QueryClientProvider><br>
                  &lt;/React.StrictMode><br>
                );
              </code>
            </p>
            <p>
              src/pages/Products/index.js içinde veriyi çekip map fonksiyonu ile kullanıyoruz. <br>
              <code>
                import { Grid } from "@chakra-ui/react";<br>
                import { useQuery } from "@tanstack/react-query";
              </code> ile react query içinden ihtiyaç duyduğumuz kısmı import ettik. <br>
              <code><br>

                import { fetchProductList } from "../../api";
              </code> ile fetch işlemini başka bir dosyada yapıp import ettik. <br>
              <code>
                import Card from "../../components/Card";<br><br>

                function Products() {<br>
                  const { isLoading, error, data } = useQuery({<br>
                    queryKey: ['products'], 
              </code> daha sonra lazım olacak. <br>
              <code>
                    queryFn: fetchProductList,
              </code> fetch işlemi yapılan fonksiyon. Bu kısımda fonksiyonun kendisi de yazılabilirdi. <br>
              <code>
                  })<br><br>

                  if (isLoading) return 'Loading...'
              </code> yükleme devam ediyorsa çalışır. <br><br>
              <code>

                  if (error) return 'An error has occurred: ' + error.message
              </code> hata varsa çalışır. <br><br>
              <code>
                  return (<br>
                    &lt;div><br>
                      &lt;Grid templateColumns="repeat(3, 1fr)" gap={4}><br>
                        {<br>
                          data.map((item, key) => &lt;Card key={key} item={item}/>)
              </code> Card kompanentine prop olarak item gönderildi. <br>
                        }<br>
              <code>
                      &lt;/Grid><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Products;<br>

              </code>
            </p>
            <p>
              src/api.js içinde fetch işlemi yapıldı. Bunun için axios kullanıldı. <br>
              terminale: <br>
              <code>
                npm i axios
              </code><br>
              api.js içine: <br>
              <code>
                import axios from "axios";<br>
                export const fetchProductList = async() =>{<br>
                    const {data} = await axios.get("http://localhost:4000/product")<br>

                    return data<br>
                }
              </code>
            </p>

            <p>
              Prop olarak Products dosyasından gelen veri Card kompanentinde ilgili yerlere yerleştirildi. Tarih bilgisinin formatını ayarlamak için moment paketi kullanıldı. <br>
              terminale: <br>
              <code>
                npm i moment
              </code><br>
              Card/index.js dosyasına: <br>
              <code>
                import { Box, Image, Button } from "@chakra-ui/react";<br>
                import moment from "moment";<br>
                import { Link } from "react-router-dom";<br><br>

                function Card({item}) {<br>
                  return (<br>
                    &lt;Box borderWidth="1px" borderRadius="lg" overflow="hidden" p="3"><br>
                      &lt;Link to="#/"><br>
                        &lt;Image src={item.photos[0]} alt="product" /><br>

                        &lt;Box p="6"><br>
                          &lt;Box d="plex" alignItems="baseline"><br>
                            {moment(item.createdAt).format("DD/MM/YYYY")}
              </code> moment ile tarih istenilen formatta yazıldı. <br>
              <code>
                          &lt;/Box><br>

                          &lt;Box mt="1" fontWeight="semibold" as="h4" lineHeight="tight"><br>
                            {item.title}<br>
                          &lt;/Box><br>
                          &lt;Box>{item.price} TL&lt;/Box><br>
                        &lt;/Box><br>
                      &lt;/Link><br>

                      &lt;Button colorScheme="pink"><br>
                        Add to basket<br>
                      &lt;/Button><br>
                    &lt;/Box><br>
                  );<br>
                }<br><br>

                export default Card;<br>

              </code>
            </p>
            
          </div>
          <div class="row" id="reactQueryDevTools">
            <h1>React Query Dev Tools</h1>
            <p>
              React Query nin geliştirme aşamasında bize yardımcı olması için verdiği bir geliştirme aracı.
            </p>
            <p>
              Eski sürümlerde React Query içindeymiş. Şimdi haricen yükleniyor. <br>
              terminale <br>
              <code>
                npm i @tanstack/react-query-devtools
              </code>
            </p>
            <p>
              QueryClientProvider yapısını kurduğumuz kısımda (örneğimizde kök dizindeki index.js) QueryClientProvider yapısının kapanış parantezinin hemen üstüne eklenerek çaıştırılır. <br>
              <code>
                ... <br>
                &lt;ReactQueryDevtools initialIsOpen={false} />
                &lt;/QueryClientProvider>
              </code>
            </p>
            <p>
              Bunun sonucunda web sayfası sol altta bir logo belirir ve tıklandığında geliştirme aracını açar.
            </p>
            <p>
              pages/Products/index.js içinde Product fonksiyonunda kullandığımız <code>queryKey: ['products']</code> ifadesi bu geliştirme aracı için gereklidir.
            </p>
          </div>
          <div class="row" id="urunDetay">
            <h1>Ürün Detay Sayfasının Geliştirilmesi</h1>
            <p>
              App.js içinde yönlendirme yapılır: <br>
              <code>
                &lt;Route path="/product/:product_id" element={&lt;ProductDetail />} />
              </code> <br>
              Yönlendirmenin yapıldığı ProductDetail kompanenti import edilir.
            </p>
            <p>
              Product sayfasında kullanılan Card kompanentindeki link düzenlenir: <br>
              <code>
                &lt;Link to={`product/${item._id}`}>
              </code>
            </p>
            <p>
              ProductDetail kompanenti için resim galerisi paketi kuruldu.
            </p>
            <p>
              Terminale: <br>
              <code>
                npm i react-image-gallery
              </code>
            </p>
            <p>
              ProductDetail/index.js içine: <br>
              <code>
                import { useQuery } from "@tanstack/react-query";
                import { useParams } from "react-router-dom";
                import { fetchProduct } from "../../api";
                import { Box, Text, Button } from "@chakra-ui/react";
                import moment from "moment";
                import ImageGallery from 'react-image-gallery';

                function ProductDetail() {
                  const { product_id } = useParams(); 
              </code> alınan veri router üzerinde gönderilen ad (product_id) ile alınır.<br><br>
              <code>

                  const { isLoading, isError, data } = useQuery(["product", product_id], () => <br>
                    fetchProduct(product_id) <br>
                  );
              </code> Products sayfasındaki işlemin farklı yazılmışı. <br><br>
              <code>

                  if (isLoading) { <br>
                    return &lt;div>Loading...&lt;/div>; <br>
                  }<br>

                  if (isError) {<br>
                    return &lt;div>Error!&lt;/div>;<br>
                  }<br><br>

                  const images = data.photos.map((url) => ({ original: url})) 
              </code> array olarak verilen veri array içinde object olarak düzenlendi <br><br>
                  
                  return &lt;div><br>
                    &lt;Button colorScheme="pink"><br>
                      Add to basket<br>
                    &lt;/Button><br>
                    &lt;Text as="h2" fontSize="2xl"><br>
                      {data.title}<br>
                    &lt;/Text><br>
                    &lt;Text><br>
                      {moment(data.createdAt).format("DD/MM/YYYY")}<br>
                    &lt;/Text><br>
                    &lt;p><br>
                      {data.description}<br>
                    &lt;/p><br>

                    &lt;Box margin="10"><br>
                      &lt;ImageGallery items={images} /><br>
                    &lt;/Box><br>
                  &lt;/div>;<br>
                }<br><br>

                export default ProductDetail;

              </code>
            </p>
            <p>
              ImageGallery kompanentinin düzgün çalışması için herhangi index.css içine <code>@import "~react-image-gallery/styles/css/image-gallery.css";</code> girilir.
            </p>
            <p>
              api.js içindeki fertch işlemleri için client kök dizinindeki .env dosyasına: <code>REACT_APP_BASE_ENDPOINT=http://localhost:4000 </code> lokal değişkeni tanımlandı.
            </p>
            <p>
              api.js içinde ProductDetail içine kullanılacak fetch işlemi eklendi. <br>
              <code>
                export const fetchProduct = async(product_id) =>{ <br>
                  const {data} = await axios.get(`${process.env.REACT_APP_BASE_ENDPOINT}/product/${product_id}`)<br>
              
                  return data<br>
                }
              </code>
            </p>
          </div>
          <div class="row" id="useInfiniteQuery">
            <h1>useInfiniteQuery</h1>
            <p>
              Bu kısımda sayfanın en altına buton koyup daha fazla ürün getirme işlemini yapacağız.
            </p>
            <p>
              api.js üzerindeki fetchProductList fonksiyonu düzenlendi: <br>
              <code>
                export const fetchProductList = async ({ pageParam = 1 }) => { <br>
                  const { data } = await axios.get( <br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/product?page=${pageParam}` <br>
                  );<br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              pages/Products/index.js aşağıdaki gibi tekrar düzenlendi. <br>
              <code>
                import { Box, Grid, Flex, Button } from "@chakra-ui/react";<br>
                import { useInfiniteQuery } from "@tanstack/react-query";<br>
                import React from "react";<br><br>

                import { fetchProductList } from "../../api";<br>
                import Card from "../../components/Card";<br><br>

                function Products() {<br>
                  const {
              </code> Bu kısımdaki tanımlar useInfiniteQuery fonkisyonunda tanımlı. <br>
              <code>
                    data,<br>
                    error,<br>
                    fetchNextPage,<br>
                    hasNextPage,<br>
                    isFetching,<br>
                    isFetchingNextPage,<br>
                    status,<br>
                  } = useInfiniteQuery(["products"], fetchProductList,<br>
                    {<br>
                    getNextPageParam: (lastGroup, allGroup) => {<br>
                      const morePagesExist = lastGroup?.length === 12;
              </code> son getirilen grup var mı? eleman sayısı 12 mi? Buradaki 12 sayısı backend tarafında bir sayfada görünecek maksimum ürün sayısına atıftır. <br>
              <code>
                      if (!morePagesExist) {<br>
                        return;<br>
                      }<br>

                      return allGroup.length + 1;
              </code> allGroup.length 1 olarak başlar. morePagesExist true döndüğü her seferinde 1 arttırılır. <br>
              <code>
                    },
                  }
                  );<br><br>

                  if (status === "loading") return "Loading...";<br><br>

                  if (status === "error") return "An error has occurred: " + error.message;<br><br>

                  return (<br>
                    &lt;div><br>
                      &lt;Grid templateColumns="repeat(3, 1fr)" gap={4}><br>
                        {<br>
                          data.pages.map((group, i) => (<br>
                            &lt;React.Fragment key={i}><br>
                              {<br>
                                group.map((item) => (<br>
                                  &lt;Box w="100" key={item._id}><br>
                                    &lt;Card item={item} /><br>
                                  &lt;/Box><br>
                                ))<br>
                              }<br>
                            &lt;/React.Fragment><br>
                          ))<br>
                        }<br>

                      &lt;/Grid><br><br>

                      &lt;Flex mt="10" justifyContent="center"><br>
                        &lt;Button<br>
                          onClick={() => fetchNextPage()}<br>
                          isLoading={isFetchingNextPage}<br>
                          disabled={!hasNextPage || isFetchingNextPage}<br>
                        ><br>
                          {isFetchingNextPage<br>
                            ? "Loading more..."<br>
                            : hasNextPage<br>
                            ? "Load More"<br>
                            : "Nothing more to load"}<br>
                        &lt;/Button><br>
                        &lt;div>{isFetching && !isFetchingNextPage ? "Fetching..." : null}&lt;/div><br>
                      &lt;/Flex><br>
                    &lt;/div>
                  );
                }<br><br>

                export default Products;

              </code>
            </p>
            <p>
              Kurulan yapı useInfiniteQuery fonkisyonuna özgüdür. Kalıp olarak kullanıldığından fazla bir açıklama yer almamaktadır.
            </p>
          </div>
          <div class="row" id="userRegister">
            <h1>Kullanıcı Kayıt İşlemleri</h1>
            <p>
              Formik ve yup'u kuracağız. <br>
              <code>
              npm i formik yup
              </code>
            </p>
            <p>
              api.js dosyası içinde register işlemi için gereken fetch işlemi tanımlanır. <br>
              <code>
                export const fetchRegister = async (input) => { <br>
                  const { data } = await axios.post(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/register`,<br>
                    input<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              src/pages/Auth/Singup/index.js dosyası aşağıdaki şekilde düzenlenir. <br>
              <code>
                import React from "react";<br>
                import {<br>
                  Flex,<br>
                  Box,<br>
                  Heading,<br>
                  FormControl,<br>
                  FormLabel,<br>
                  Input,<br>
                  Button,<br>
                  Alert,<br>
                } from "@chakra-ui/react";<br>
                import { useFormik } from "formik";<br>
                import validations from "./validation";
              </code> validation.js içindeki validations tanımı import edilir ve kullanılır. Bu tanımlar aşağıda verildi. <br>
              <code>
                import { fetchRegister } from "../../../api"; 
              </code> ile yukarıda tanımlanan fetch işlemi import edildi. <br><br>
              <code>

                function Singup() {<br>
                  const formik = useFormik({<br>
                    initialValues: {<br>
                      email: "",<br>
                      password: "",<br>
                      passwordConfirm: "",<br>
                    },<br>
                    onSubmit: async (values, bag) => {
              </code> values: formdaki datalar, bag: formda yapılabilecek bir takım işlemler (formu resetlemek gibi). biz yeni hata mesajı oluşturmak için kullandık. <br>
              <code>
                      try {<br>
                        const registerResponse = await fetchRegister({<br>
                          email: values.email,<br>
                          password: values.password,<br>
                        });
              </code> passwordComfirm backend tarafında yok. Bunu göndermemek için values'in tamamı değil backend tarafından beklenen kısmı gönderilir.<br>
              <code>
                      } catch (e) {<br>
                        bag.setErrors({ general: e.response.data.message === "This e-mail already using." ? "Bu mail zaten kullanılıyor": e.response.data.message });<br>
                      }<br>
                    },<br>
                    validationSchema: validations,
              </code> import edilen validasyon tanımları kullanıldı. <br>
              <code>
                  });<br>
                  return (<br>
                    &lt;div><br>
                      &lt;Flex align="center" justifyContent="center" width="full"><br>
                        &lt;Box pt={10}><br>
                          &lt;Box textAlign="center"><br>
                            &lt;Heading>Sing Up&lt;/Heading><br>
                          &lt;/Box><br>
                          &lt;Box my={5}><br>
                            {formik.errors.general && (<br>
                              &lt;Alert status="error">{formik.errors.general}&lt;/Alert><br>
                            )}<br>
                          &lt;/Box><br>
                          &lt;Box my={5} textAlign="left"><br>
                            &lt;form onSubmit={formik.handleSubmit}><br>
                              &lt;FormControl><br>
                                &lt;FormLabel>E-mail&lt;/FormLabel><br>
                                &lt;Input<br>
                                  name="email"<br>
                                  onChange={formik.handleChange}<br>
                                  onBlur={formik.handleBlur}<br>
                                  value={formik.values.email}<br>
                                  isInvalid={formik.touched.email && formik.errors.email}
              </code> true olduğunda yapı geçersiz demektir ve input farklı renk alır.<br>
              <code>
                                /><br>
                                {formik.errors.email && formik.touched.email && (<br>
                                  &lt;div><br>
                                    &lt;br /><br>
                                    &lt;Alert status="error">{formik.errors.email}&lt;/Alert><br>
                                  &lt;/div><br>
                                )}<br>
                              &lt;/FormControl><br>
                              &lt;FormControl mt={4}><br>
                                &lt;FormLabel>Password&lt;/FormLabel><br>
                                &lt;Input<br>
                                  name="password"<br>
                                  type="password"<br>
                                  onChange={formik.handleChange}<br>
                                  onBlur={formik.handleBlur}<br>
                                  value={formik.values.password}<br>
                                  isInvalid={formik.errors.password && formik.touched.password}<br>
                                /><br>
                                {formik.errors.password && formik.touched.password && (<br>
                                  &lt;div><br>
                                    &lt;br /><br>
                                    &lt;Alert status="error">{formik.errors.password}&lt;/Alert><br>
                                  &lt;/div><br>
                                )}<br>
                              &lt;/FormControl><br>
                              &lt;FormControl mt={4}><br>
                                &lt;FormLabel>Password Confirm&lt;/FormLabel><br>
                                &lt;Input<br>
                                  name="passwordConfirm"<br>
                                  type="password"<br>
                                  onChange={formik.handleChange}<br>
                                  onBlur={formik.handleBlur}<br>
                                  value={formik.values.passwordConfirm}<br>
                                  isInvalid={<br>
                                    formik.errors.passwordConfirm &&<br>
                                    formik.touched.passwordConfirm<br>
                                  }<br>
                                /><br>
                                {formik.errors.passwordConfirm &&<br>
                                  formik.touched.passwordConfirm && (<br>
                                    &lt;div><br>
                                      &lt;br /><br>
                                      &lt;Alert status="error">{formik.errors.passwordConfirm}&lt;/Alert><br>
                                    &lt;/div><br>
                                  )}<br>
                              &lt;/FormControl><br><br>

                              &lt;Button mt={4} width="full" type="submit"><br>
                                Sing Up<br>
                              &lt;/Button><br>
                            &lt;/form><br>
                          &lt;/Box><br>
                        &lt;/Box><br>
                      &lt;/Flex><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Singup;

              </code>
            </p>
            <p>
              Validasyon tanımı için Singup/validation.js içine: <br>
              <code>
                import * as yup from "yup";<br><br>

                const validations = yup.object().shape({<br>
                  email: yup.string().email("Geçerli bir email girin").required("Zorunlu alan"),<br>
                  password: yup<br>
                    .string()<br>
                    .min(5, "Parolanız en az 5 karakter olmalıdır")<br>
                    .required("Zorunlu alan"),<br>
                  passwordConfirm: yup<br>
                    .string()<br>
                    .oneOf([yup.ref("password")], "Parolalar uyuşmuyor")<br>
                    .required("Zorunlu alan"),<br>
                });<br><br>

                export default validations;

              </code>
            </p>
            <h2>Giriş Yapıldığı Verisinin Sayfada Kullanılması</h2>
            <p>
              Giriş sırasında bilginin tutulması için src/context/AuthContext.js dosyası oluşturuldu: <br>
              <code>
                import { useState, createContext, useEffect, useContext } from "react"; <br><br>

                const AuthContext = createContext();<br><br>

                const AuthProvider = ({ children }) => {<br>
                  const [user, setUser] = useState(null);<br>
                  const [loggedIn, setLoggedIn] = useState(false);<br><br>

                  const login = (data) => {<br>
                    setLoggedIn(true);<br>
                    setUser(data.user);<br>
                  };<br><br>

                  const values = {<br>
                    loggedIn,<br>
                    user,<br>
                    login,<br>
                  };<br>
                  return &lt;AuthContext.Provider value={values}>{children}&lt;/AuthContext.Provider>;<br>
                };<br><br>

                const useAuth = () => useContext(AuthContext);<br><br>

                export { AuthProvider, useAuth };

              </code>
            </p>
            <p>
              Kök dizinde AuthProvider import edildi ve &lt;App /> kompanentini sarmak için kullanıldı. <br>
              <code>
                import { AuthProvider } from "./contexts/AuthContext";<br>
                ...<br>
                ...<br>
                &lt;AuthProvider><br>
                  &lt;App /><br>
                &lt;/AuthProvider><br>
                ...<br>
              </code>
            </p>
            <p>
              Singup/index.js içinde useAuth() fonksiyonu import edildi ve kullanıldı. <br>
              <code>
                ...<br>
                import { useAuth } from "../../../contexts/AuthContext";<br>
                ...<br>
                function Singup() {<br>
                  const { login } = useAuth();<br>
                  ...<br>
                  try {
                    const registerResponse = await fetchRegister({<br>
                      email: values.email,<br>
                      password: values.password,<br>
                    });<br>
                    login(registerResponse)<br>
                    ...<br>
              </code>
            </p>
            <p>
              Navbar/index.js içinde useAuth() fonksiyonu import edildi ve kullanıldı. <br>
              <code>
                import { useAuth } from "../../contexts/AuthContext";<br><br>
                function Navbar() {<br>
                  const { loggedIn } = useAuth();<br>
                  ...<br>
                  &lt;div className={styles.right}>
                    {!loggedIn && (
                      &lt;>
                        &lt;Link to="/singup">
                          &lt;Button colorScheme="pink">Register&lt;/Button>
                        &lt;/Link>
                        &lt;Link to="/singin">
                          &lt;Button colorScheme="pink">Login&lt;/Button>
                        &lt;/Link>
                      &lt;/>
                    )}
                    {
                      loggedIn && (
                        &lt;>
                        &lt;Link to="/profile">
                          &lt;Button>Profile&lt;/Button>
                        &lt;/Link>
                      &lt;/>
                      )
                    }
          
                  &lt;/div>
                  ...<br>
              </code>
            </p>

            <h2>Login Durumunun Sayfa Yenilendikten Sonra Korunması</h2>
            <p>
              Bu durum backend tarafında korunur ancak şu anki hali ile client tarafı bu veriyi alamaz. Alması için fetch işlemi yapağız. Bunun için de header ile access-token göndermemiz gerekiyor. Bu işlemi bazı sorgularımızda yapacağız. İşlemi otomatikleştirmek için axios paketinin bir fonksiyonu var. Onu api.js dosyasının baş kısmına giriyoruz. <br>
              <code>
                // Add a request interceptor <br>
                axios.interceptors.request.use(<br>
                  function (config) {<br>
                    // Do something before request is sent<br>
                    const { origin } = new URL(config.url);<br><br>

                    const allowedOrigin = [process.env.REACT_APP_BASE_ENDPOINT];
              </code> hangi endpointlere istek yapılırken bu düzenlemenin geçerli olduğunu belirttik. <br>
              <code>
                    const token = localStorage.getItem("access-token")<br><br>

                    if(allowedOrigin.includes(origin)){<br>
                      config.headers.authorization = token<br>
                    }<br><br>

                    return config;<br>
                  },<br>
                  function (error) {<br>
                    // Do something with request error<br>
                    return Promise.reject(error);<br>
                  }<br>
                );
              </code> <br>
              Detaylı okuma için <a href="https://axios-http.com/docs/interceptors">tıklayınız.</a>
            </p>
            <p>
              Backendden gelecek profil bilgisi için api.js içinde fetch işlemi yapılır. <br>
              <code>
                export const fetchMe = async () => {<br>
                  const { data } = await axios.get(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/me`<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              fetch ile gelen veri contexts/AuthContext.js içinde yakalanır ve kullanılır. <br>
              <code>
                import { useState, createContext, useEffect, useContext } from "react";<br>
                import { fetchMe } from "../api";
              </code> fetchMe fonksiyonu import edildi. <br>
              <code>
                import { Flex, Spinner } from "@chakra-ui/react";
              </code> veri alınana kadar gelen loading kısmı için gereklidir.<br><br>
              <code>

                const AuthContext = createContext();<br><br>

                const AuthProvider = ({ children }) => {<br>
                  const [user, setUser] = useState(null);<br>
                  const [loggedIn, setLoggedIn] = useState(false);<br>
                  const [loading, setLoading] = useState(true);
              </code> başlangıçta true alır. fetchMe fonksiyonu ile veri alnınca false a döner. Veri alınırlen çıkan loading yapısını kullanmayı sağlar. <br><br>
              <code>
                  useEffect(() => {<br>
                    (async () => {
              </code> işlemlerin asenkron olabilmesi için bir fonksiyonla tanımlanması gerekiyor. Bu fonksiyonun okunur okunmaz çalışması için anonim fonksiyon yapısı kullanıldı. <br>
              <code>
                      try {<br>
                        const me = await fetchMe();
              </code>fetchMe fonksiyonundan veri gelene kadar bekler. <br>
              <code>
                        setLoggedIn(true);<br>
                        setUser(me);<br>
                        setLoading(false);<br>
                        console.log("me", me);<br>
                      } catch (e) {<br>
                        setLoading(false);<br>
                      }<br>
                    })();<br>
                  }, []);<br><br>

                  const login = (data) => {<br>
                    setLoggedIn(true);<br>
                    setUser(data.user);<br><br>

                    localStorage.setItem("access-token", data.accessToken);<br>
                    localStorage.setItem("refresh-token", data.refreshToken);
                  </code> login işlemi sırasında access-token ve refresh-token ibarelerini localStorage üzerine kaydeder. <br>
                  <code>
                  };<br><br>

                  const values = {<br>
                    loggedIn,<br>
                    user,<br>
                    login,<br>
                  };<br><br>

                  if (loading) { 
                  </code>Loading true iken görülecek olan spiner.<br>
                  <code>
                    return (<br>
                      &lt;Flex justifyContent="center" alignItems="center" height="100vh"><br>
                        &lt;Spinner<br>
                          thickness="4px"<br>
                          speed="0.65s"<br>
                          emptyColor="gray.200"<br>
                          size="xl"<br>
                          color="red.500"<br>
                        /><br>
                      &lt;/Flex><br>
                    );<br>
                  }<br><br>

                  return &lt;AuthContext.Provider value={values}>{children}&lt;/AuthContext.Provider>;<br>
                };<br><br>

                const useAuth = () => useContext(AuthContext);<br><br>

                export { AuthProvider, useAuth };

              </code>
            </p>
            <p>
              Giriş işlemi olduktan sonra ortaya çıkan Profile butonuna yer tutucu bir kompanent hazırlandı ve App.js üzerinden yönlendirmesi yapıldı.
            </p>
          </div>
          <div class="row" id="userLogout">
            <h1>Çıkış İşlemleri</h1>
            <p>
              api.js içinde logout için fetch işlemi tanımlanır. <br>
              <code>
                export const fetchLogout = async () => {<br>
                  const { data } = await axios.post(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/logout`,<br>
                    {<br>
                      refresh_token: localStorage.getItem("refresh-token"),<br>
                    }<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              AuthContext.js içinde logout fonksiyonu tanımlanır ve values ile gönderilir. <br>
              <code>
                const logout = async(cb) => {<br>
                  setLoggedIn(false);<br>
                  setUser(null);<br><br>
              
                  await fetchLogout()<br>
                  
                  localStorage.removeItem("access-token")<br>
                  localStorage.removeItem("refresh-token")<br><br>
              
                  cb()
              </code> parametre olarak alınan cb çalıştırılır. Tanımı logout fonksiyonunun kullanıldığı yerde yapıldı. <br>
              <code>
                }<br><br>

                const values = {<br>
                  loggedIn,<br>
                  user,<br>
                  login,<br>
                  logout,<br>
                };
              </code>
            </p>
            <p>
              Profile/index.js içinde logout butonu konuldu. <br>
              <code>
                import { useAuth } from "../../contexts/AuthContext";<br>
                import { useNavigate } from "react-router-dom";<br><br>

                import { Text, Button } from "@chakra-ui/react";<br><br>

                function Profile() {<br>
                  const { user, <u>logout</u> } = useAuth();<br><br>

                  let navigate = useNavigate(); <br>
              </code>react-router-dom içinden alınan useNavigate() tanımı değişkene atandı. <br>
              <code>
                  const handleLogout = async () => {<br>
                    logout(() => {<br>
                      navigate("../");
              </code> tanımlanan değişken sayfa yönlendirmek için kullanılır. <br>
              <code> 
                    });<br>
                  };<br><br>

                  return (<br>
                    &lt;div><br>
                      &lt;code><br>
                        &lt;Text fontSize={22}>Profile&lt;/Text><br>
                        {JSON.stringify(user)}<br>
                        &lt;br /><br>
                        &lt;br /><br>
                        &lt;Button colorScheme="pink" variant="solid" onClick={handleLogout}><br>
                          Logout<br>
                        &lt;/Button><br>
                      &lt;/code><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Profile;

              </code>
            </p>
          </div>
          <div class="row" id="protectedRoutes">
            <h1>Protected Routes</h1>
            <p>
              Derste react-router-dom v5 üzerinden anlatılıyor. v6 için <a href="https://medium.com/@dennisivy/creating-protected-routes-with-react-router-v6-2c4bbaf7bc1c">tıklayın.</a>
            </p>
            <p>
              pages/ProtectedRoute.js dosyası oluşturuldu ve içine <br>
              <code>
                import {Navigate, Outlet} from 'react-router-dom'<br><br>

                import { useAuth } from '../contexts/AuthContext'<br><br>

                function ProtectedRoute() {<br>
                    const {loggedIn} = useAuth()<br>
                  return (<br>
                    loggedIn ? &lt;Outlet/> : &lt;Navigate to ='/'/><br>
                  )<br>
                }<br><br>

                export default ProtectedRoute
              </code>
            </p>
            <p>
              ProtectedRoute kompanenti app.js içine import edildi ve Routes>Route olarak kullanıldı. Korunmak istenen link de Outlet olarak yazıldı. <br>
              <code>
                &lt;Routes><br>
                  &lt;Route path="/" element={&lt;Products />} /><br>
                  &lt;Route path="/product/:product_id" element={&lt;ProductDetail />} /><br>
                  &lt;Route path="/singin" element={&lt;Singin />} /><br>
                  &lt;Route path="/singup" element={&lt;Singup />} /><br>
                  <u>
                    &lt;Route element={&lt;ProtectedRoute/>}><br>
                      &lt;Route path="/profile" element={&lt;Profile />} /><br>
                    &lt;/Route><br>
                  </u>
                &lt;/Routes>
              </code>
            </p>
          </div>
          <div class="row" id="userLogin">
            <h1>Login İşlemleri</h1>
            <p>
              api.js içinde login işlemi için gereken fetch işlemi tanımlanır. <br>
              <code>
                export const fetchLogin = async (input) => {<br>
                  const { data } = await axios.post(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/auth/login`,<br>
                    input<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              Auth/Singin/index.js dosyası Singup/index.js dosyası referans alınarak oluşturuldu ve  modifiye edildi. <br>
              <code>
                import React from "react";<br>
                import {<br>
                  Flex,<br>
                  Box,<br>
                  Heading,<br>
                  FormControl,<br>
                  FormLabel,<br>
                  Input,<br>
                  Button,<br>
                  Alert,<br>
                } from "@chakra-ui/react";<br>
                import { useFormik } from "formik";<br>
                import validations from "./validation";<br>
                import { fetchLogin } from "../../../api";<br>
                import { useNavigate } from "react-router-dom";<br><br>

                import { useAuth } from "../../../contexts/AuthContext";<br><br>

                function <u>Singin()</u> {<br>
                  const { login } = useAuth();<br>

                  const navigate = useNavigate();<br>

                  const formik = useFormik({<br>
                    initialValues: {<br>
                      email: "",<br>
                      password: "",<br>
                    },<br>
                    onSubmit: async (values, bag) => {<br>
                      console.log(values);<br>
                      try {<br>
                        const loginResponse = await <u>fetchLogin</u>({<br>
                          email: values.email,<br>
                          password: values.password,<br>
                        });<br>
                        login(loginResponse);<br>

                        navigate("../profile");<br>
                        console.log("res", loginResponse);<br>
                      } catch (e) {<br>
                        bag.setErrors({<br>
                          general:<br>
                            <u>e.response.data.message === "email or password not correct"<br>
                              ? "email veya parola hatalı"<br>
                              : e.response.data.message === "The email address was not found."<br>
                              ? "email bulunamadı"<br>
                              : e.response.data.message,<br></u>
                        });<br>
                      }<br>
                    },<br>
                    validationSchema: validations,<br>
                  });<br>
                  return (<br>
                    &lt;div><br>
                      &lt;Flex align="center" justifyContent="center" width="full"><br>
                        &lt;Box pt={10}><br>
                          &lt;Box textAlign="center"><br>
                            &lt;Heading>Sing In&lt;/Heading><br>
                          &lt;/Box><br>
                          &lt;Box my={5}><br>
                            {formik.errors.general && (<br>
                              &lt;Alert status="error">{formik.errors.general}&lt;/Alert><br>
                            )}<br>
                          &lt;/Box><br>
                          &lt;Box my={5} textAlign="left"><br>
                            &lt;form onSubmit={formik.handleSubmit}><br>
                              &lt;FormControl><br>
                                &lt;FormLabel>E-mail&lt;/FormLabel><br>
                                &lt;Input<br>
                                  name="email"<br>
                                  onChange={formik.handleChange}<br>
                                  onBlur={formik.handleBlur}<br>
                                  value={formik.values.email}<br>
                                  isInvalid={formik.touched.email && formik.errors.email}<br>
                                /><br>
                                {formik.errors.email && formik.touched.email && (<br>
                                  &lt;div><br>
                                    &lt;br /><br>
                                    &lt;Alert status="error">{formik.errors.email}&lt;/Alert><br>
                                  &lt;/div><br>
                                )}<br>
                              &lt;/FormControl><br>
                              &lt;FormControl mt={4}><br>
                                &lt;FormLabel>Password&lt;/FormLabel><br>
                                &lt;Input<br>
                                  name="password"<br>
                                  type="password"<br>
                                  onChange={formik.handleChange}<br>
                                  onBlur={formik.handleBlur}<br>
                                  value={formik.values.password}<br>
                                  isInvalid={formik.errors.password && formik.touched.password}<br>
                                /><br>
                                {formik.errors.password && formik.touched.password && (<br>
                                  &lt;div><br>
                                    &lt;br /><br>
                                    &lt;Alert status="error">{formik.errors.password}&lt;/Alert><br>
                                  &lt;/div><br>
                                )}<br>
                              &lt;/FormControl><br>

                              &lt;Button mt={4} width="full" type="submit"><br>
                                <u>Sing In</u><br>
                              &lt;/Button><br>
                            &lt;/form><br>
                          &lt;/Box><br>
                        &lt;/Box><br>
                      &lt;/Flex><br>
                    &lt;/div><br>
                  );<br>
                }<br>

                export default Singin;

              </code>
            </p>
          </div>
          <div class="row" id="addToBasket">
            <h1>Sepete Atma İşlemleri</h1>
            <p>
              contexts/BasketContext.js dosyası oluşturuldu ve içine <br>
              <code>
                import { useState, createContext, useContext, useEffect } from "react";<br>

                const BasketContext = createContext();<br><br>

                const BasketProvider = ({ children }) => {<br>
                  const [items, setItems] = useState([]);<br><br>

                  const addToBasket = (data, findBasketItem) => {
              </code> data ile ürün verisi, findBasketItem ile de ürünün sepette olma durumu alınır. <br>
              <code>
                    if (!findBasketItem) {<br>
                      return setItems((prev) => [...prev, data]);<br>
                    }<br>
                    const filtered = items.filter((item) => item._id !== findBasketItem._id);<br>
                    setItems(filtered);<br>
                  };<br><br>

                  const values = {<br>
                    items,<br>
                    setItems,<br>
                    addToBasket,<br>
                  };<br>
                  return (<br>
                    &lt;BasketContext.Provider value={values}>{children}&lt;/BasketContext.Provider><br>
                  );<br>
                };<br><br>

                const useBasket = () => useContext(BasketContext);<br>

                export { BasketProvider, useBasket };

              </code>
            </p>
            <p>
              Bu contexti kullanabilmek için kök dizindeki index.js içindeki App kompanenti BasketProvider ile sarmalanır.
            </p>
            <p>
              Navbar/index.js içinde giriş yapıldıya se sepette ürün varsa Basket adında bir buton görünmesi ve bu butonda sepetteki ürün sayısının da yazılması sağlanır. <br>
              <code>
                &lt;div className={styles.right}><br>
                  {!loggedIn && (<br>
                    &lt;><br>
                      &lt;Link to="/singup"><br>
                        &lt;Button colorScheme="pink">Register&lt;/Button><br>
                      &lt;/Link><br>
                      &lt;Link to="/singin"><br>
                        &lt;Button colorScheme="pink">Login&lt;/Button><br>
                      &lt;/Link><br>
                    &lt;/><br>
                  )}<br>
                  {loggedIn && (<br>
                    &lt;><br>
                    <u>
                      {<br>
                        items.length > 0 && (<br>
                          &lt;Link to="/basket"><br>
                            &lt;Button colorScheme="pink" variant="outline"><br>
                              Basket ({items.length})<br>
                            &lt;/Button><br>
                          &lt;/Link><br>
                        )<br>
                      }<br>
                    </u>
                      &lt;Link to="/profile"><br>
                        &lt;Button>Profile&lt;/Button><br>
                      &lt;/Link><br>
                    &lt;/><br>
                  )}<br>
                &lt;/div>
              </code>
            </p>
            <p>
              pages/ProductDetail/index.js dosyasındaki Add to basket butonu için gerekli düzenleme yapıldı. <br>
              <code>
                ... <br>
                <u>import { useBasket } from "../../contexts/BasketContext";<br></u>
                ...<br>
                function ProductDetail() {<br>
                  const { product_id } = useParams();<br>
                  <u>const { addToBasket, items } = useBasket();<br></u>
                  ...<br>
                  <u>const findBasketItem = items.find((item) => item._id === product_id);<br><br></u>

                  return (<br>
                    &lt;div><br>
                      <u>
                        &lt;Button colorScheme={findBasketItem ? "pink": "green"} onClick={() => addToBasket(data, findBasketItem)}><br>
                        {findBasketItem ? "Remove to basket" : "Add to basket"}<br>
                      &lt;/Button><br>
                      </u>
                      &lt;Text as="h2" fontSize="2xl"><br>
                        ...
              </code>
            </p>
            <p>
              Product sayfasındaki ürünlerin altındaki Add to basket butonunu aktifleştirmek için ykarıdakine benzer bir işlem uygulanır: <br>
              <code>
                import { useBasket } from "../../contexts/BasketContext"; <br>
                ...<br>
                function Card({ item }) {<br>
                  const { addToBasket, items } = useBasket();<br><br>
                
                  const findBasketItem = items.find(<br>
                    (basket_item) => basket_item._id === item._id<br>
                  );<br>
                  return (<br>
                    ...<br>
                    &lt;Button<br>
                    colorScheme={findBasketItem ? "pink" : "green"}<br>
                    variant="solid"<br>
                    onClick={() => addToBasket(item, findBasketItem)}<br>
                  ><br>
                    {findBasketItem ? "Remove from basket" : "Add to basket"}<br>
                  &lt;/Button><br>
                  ...
              </code>
            </p>
            <p>
              Sepete alınan ürünlerin görüntüleneceği ve işlenebileceği Basket sayfası pages/Basket/index.js içinde oluşturulur.
              <code>
                import React from "react";<br>
                import { useBasket } from "../../contexts/BasketContext";<br>
                import { Alert, Box, Button, Image, Text } from "@chakra-ui/react";<br>
                import { Link } from "react-router-dom";<br><br>

                function Basket() {<br>
                  const { items, removeToBasket } = useBasket();
              </code> burada çağırılan removeToBasket fonksiyonu aşağıda anlatılacak. <br><br>
              <code>

                  const total = items.reduce((acc, obj) => acc + obj.price, 0); 
              </code> acc o anki toplam. obj items içindeki nesne. 0 da başlangıç değeri.<br>
              <code>
                  return (<br>
                    &lt;Box padding={5}><br>
                      {items.length &lt; 1 && (<br>
                        &lt;Alert status="warning">You have not any items in your basket!&lt;/Alert><br>
                      )}<br>
                      {items.length > 0 && (<br>
                        &lt;><br>
                          &lt;ul style={{listStyleType: "decimal"}}><br>
                            {items.map((item) => (<br>
                              &lt;li key={item._id} style={{ marginBottom: 15 }}><br>
                                &lt;Link to={`/product/${item._id}`}><br>
                                  &lt;Text fontSize={18}><br>
                                  {item.title} - {item.price} TL<br>
                                  &lt;/Text><br>
                                  &lt;Image
                                    htmlWidth={200}
                                    src={item.photos[0]}
                                    loading="lazy"
                                    alt="basket item"
                                  /><br>
                                &lt;/Link><br>
                                &lt;Button
                                  mt={2}
                                  size="sm"
                                  colorScheme="pink"
                                  onClick={() => removeToBasket(item._id)}
                                >
                                  Remove from basket
                                &lt;/Button><br>
                              &lt;/li><br>
                            ))}<br>
                          &lt;/ul><br>
                          &lt;Box mt={10}><br>
                            &lt;Text fontSize={22}>Total: {total} TL&lt;/Text><br>
                          &lt;/Box><br>
                        &lt;/><br>
                      )}<br>
                    &lt;/Box><br>
                  );
                }<br><br>

                export default Basket;

              </code>
            </p>
            <p>
              contexts/BasketContext.js içinde <q>removeToBasket</q> fonksiyonu tanımlanır ve value olarak gönderilir. <br>
              <code>
                const removeToBasket = (item_id) => {<br>
                  const filtered = items.filter((item) => item._id !== item_id);<br>
                  setItems(filtered);<br>
                };<br>
                const values = {<br>
                  items,<br>
                  setItems,<br>
                  addToBasket,<br>
                  removeToBasket,<br>
                };
              </code>
            </p>
            <p>
              Sayfa yönlendirmesi için app.js Routes içinde <q>ProtectedRoute</q> altına <q>Basket</q> elementi yerleştirilir. <br>
              <code>
                &lt;Routes><br>
                  &lt;Route path="/" element={&lt;Products />} /><br>
                  &lt;Route path="/product/:product_id" element={&lt;ProductDetail />} /><br>
                  &lt;Route path="/singin" element={&lt;Singin />} /><br>
                  &lt;Route path="/singup" element={&lt;Singup />} /><br>
                  &lt;Route element={&lt;ProtectedRoute />}><br>
                    &lt;Route path="/profile" element={&lt;Profile />} /><br>
                    <u>&lt;Route path="/basket" element={&lt;Basket />} /><br></u>
                  &lt;/Route><br>
                  &lt;Route path="*" element={&lt;Error404 />} />
              </code> path tanımı yukarıdakilerin hiçbirine uymuyorsa bu kısım devreye girer ve Error404 sayfasına yönlendirir.<br>
              <code>
                &lt;/Routes>
              </code> 
            </p>
            <p>
              <q>Error 404</q> sayfası için pages/Error404/index.js oluşturulur. İçine <br>
              <code>
                import React from "react";<br>
                import {
                  Alert,
                  AlertIcon,
                  AlertTitle,
                  AlertDescription,
                } from "@chakra-ui/react";<br><br>

                function Error404() {<br>
                  return (<br>
                    &lt;div><br>
                      &lt;Alert status="error"><br>
                        &lt;AlertIcon /><br>
                        &lt;AlertTitle>Error 404&lt;/AlertTitle><br>
                        &lt;AlertDescription><br>
                          This page was not found<br>
                        &lt;/AlertDescription><br>
                      &lt;/Alert><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Error404;

              </code>
            </p>
          </div>
          <div class="row" id="createOrder">
            <h1>Sipariş Oluşturma İşlemleri</h1>
            <p>
              pages/Basket/index.js içinde bir modal yerleştirildi ve siparişlerin database e gönderilmesinde kullanıldı. <br>
              <code>
                import React, { useState } from "react"; <br>
                import { useBasket } from "../../contexts/BasketContext";<br>
                import {
                  Alert,
                  Box,
                  Button,
                  Image,
                  Text,<br>
                  Modal, 
                  ModalOverlay,
                  ModalContent,
                  ModalHeader,
                  ModalFooter,
                  ModalBody,
                  ModalCloseButton,
                  useDisclosure,
                  FormControl,
                  FormLabel,
                  Textarea,
              </code> modal ve içindeki bileşenler için gereken parçalar chakraUI üzerinden çekildi. <br>
              <code>
                } from "@chakra-ui/react";<br>
                import { Link } from "react-router-dom";<br>
                import { postOrder } from "../../api"; 
              </code>api.js içinde gereken işlem tanımlandı ve import edildi. İşlem detayı aşağıda. <br>
              <code><br>

                function Basket() {<br>
                  const [address, setAddress] = useState("");<br><br>

                  const { isOpen, onOpen, onClose } = useDisclosure();<br>
                  const initialRef = React.useRef(null); 
              </code> Bu iki tanım chakraUI modal tanımında kullanılıyor. <br>
              <code><br>

                  const { items, removeToBasket, emptyBasket } = useBasket();
              </code> emptybasket BasketContext içinde, sepeti işlem sonunda boşaltmak için oluşturuldu. Detayı aşağıda. <br>
              <code>
                  const total = items.reduce((acc, obj) => acc + obj.price, 0);<br><br>

                  const handleSubmitForm = async () => { 
              </code> Modal içindeki formu göndermek için tanımlanan fonksiyon. <br>
              <code>
                    const itemIds = items.map((item) => item._id);<br><br>

                    const input = {
              </code>api.js üzerinden database e gönderilecek veri. <br>
              <code>
                      address,<br>
                      items: JSON.stringify(itemIds),<br>
                    };<br><br>

                    await postOrder(input);<br>
                    emptyBasket();<br>
                    onClose(); 
              </code> modalı işlemin sonunda kapatan fonksiyon. <br>
              <code>
                  };<br>
                  return (<br>
                    &lt;Box padding={5}><br>
                      {items.length &lt; 1 && (<br>
                        &lt;Alert status="warning">You have not any items in your basket!&lt;/Alert><br>
                      )}<br>
                      {items.length > 0 && (<br>
                        &lt;><br>
                          &lt;ul style={{ listStyleType: "decimal" }}><br>
                            {items.map((item) => (<br>
                              &lt;li key={item._id} style={{ marginBottom: 15 }}><br>
                                &lt;Link to={`/product/${item._id}`}><br>
                                  &lt;Text fontSize={18}><br>
                                    {item.title} - {item.price} TL<br>
                                  &lt;/Text><br>
                                  &lt;Image
                                    htmlWidth={200}
                                    src={item.photos[0]}
                                    loading="lazy"
                                    alt="basket item"
                                  /><br>
                                &lt;/Link><br>
                                &lt;Button
                                  mt={2}
                                  size="sm"
                                  colorScheme="pink"
                                  onClick={() => removeToBasket(item._id)}
                                >
                                  Remove from basket
                                &lt;/Button><br>
                              &lt;/li><br>
                            ))}<br>
                          &lt;/ul><br>
                          &lt;Box mt={10}><br>
                            &lt;Text fontSize={22}>Total: {total} TL&lt;/Text><br>
                          &lt;/Box><br><br>

                          &lt;Button mt={2} size="sm" colorScheme="green" onClick={onOpen}>
                            Order <br>
                          &lt;/Button> 
              </code> modalı açan buton. <br>
              <code><br>
                          &lt;Modal initialFocusRef={initialRef} isOpen={isOpen} onClose={onClose}>
              </code>Modalın başlangıcı <br>
              <code>
                            &lt;ModalOverlay /><br>
                            &lt;ModalContent><br>
                              &lt;ModalHeader>Order&lt;/ModalHeader><br>
                              &lt;ModalCloseButton /><br>
                              &lt;ModalBody pb={6}><br>
                                &lt;FormControl><br>
                                  &lt;FormLabel>Address&lt;/FormLabel><br>
                                  &lt;Textarea<br>
                                    ref={initialRef}<br>
                                    placeholder="Address"<br>
                                    value={address}<br>
                                    onChange={(e) => setAddress(e.target.value)}<br>
                                  /><br>
                                &lt;/FormControl><br>
                              &lt;/ModalBody><br><br>

                              &lt;ModalFooter><br>
                                &lt;Button colorScheme="blue" mr={3} onClick={handleSubmitForm}>
              </code> Formu gönderme işlemi yapan buton. <br>
              <code>
                                  Save<br>
                                &lt;/Button><br>
                                &lt;Button onClick={onClose}>Cancel&lt;/Button><br>
                              &lt;/ModalFooter><br>
                            &lt;/ModalContent><br>
                          &lt;/Modal><br>
                        &lt;/><br>
                      )}<br>
                    &lt;/Box><br>
                  );<br>
                }<br><br>

                export default Basket;

              </code>
            </p>
            <p>
              api.js içinde gerekli fetch işlemi yapıldı ve import edildi. <br>
              <code>
                export const postOrder = async (input) => {<br>
                  const { data } = await axios.post(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/order`,<br>
                    input<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              BasketContext/index.js içinde emptyBasket fonksiyonu tanımlandı ve value olarak gönderildi. <br>
              <code>
                const emptyBasket = () => setItems([]);
              </code>
            </p>
          </div>
          <div class="row" id="adminRouting">
            <h1>Admin: Routing İşlemleri</h1>
            <p>
              Önce bir kullanıcın rolünü database üzerinden admin yapıyoruz. Hoca dersi react-router-dom v5 üzerinden anlatmış. Biz v6 ya göre düzenledik.
            </p>
            <p>
              Navbar kompanentine kullanıcı admin ise görülecek bir buton yerleştirildi. Navbar/index.js <br>
              <code>
                ...<br>
                return (<br>
                  ...<br>
                  {loggedIn && (<br>
                    <><br>
                    ...<br>
        
                    {<br>
                      user?.role === "admin" && (<br>
                        &lt;Link to="/admin"><br>
                          &lt;Button colorScheme="pink" variant="ghost">Admin&lt;/Button><br>
                        &lt;/Link><br>
                      )<br>
                    }<br>
                    ...
              </code>
            </p>
            <p>
              pages/Admin/index.js dosyası oluşturuldu ve içine: <br>
              <code>
                import React from "react";<br>
                import { Link, Outlet } from "react-router-dom";<br>
                import styles from "./styles.module.css";<br>
                import { Box } from "@chakra-ui/react";<br><br>

                function Admin() {<br>
                  return (<br>
                    &lt;div><br>
                      &lt;nav><br>
                        &lt;ul className={styles.adminMenu}><br>
                          &lt;li><br>
                            &lt;Link to="/admin">Home&lt;/Link><br>
                          &lt;/li><br>
                          &lt;li><br>
                            &lt;Link to="/admin/orders">Orders&lt;/Link><br>
                          &lt;/li><br>
                          &lt;li><br>
                            &lt;Link to="/admin/products">Products&lt;/Link><br>
                          &lt;/li><br>
                        &lt;/ul><br>
                      &lt;/nav><br><br>

                      &lt;Box mt={10}><br>
                        &lt;Outlet /><br>
                      &lt;/Box><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Admin;

              </code>
            </p>
            <p>
              Admin/styles.module.css içine stil tanımları yapıldı. <br>
              <code>
                .adminMenu{<br>
                  display: flex;<br>
                  padding: 0;<br>
                  margin: 0;<br>
              }<br>
              
              .adminMenu li{<br>
                  padding: 0 10px;<br>
              }
              </code>
            </p>
            <p>
              Admin olmayan kullanıcıların admin alanına ulaşamamalı için link korumalı olarak yazılmalı. Bunun için pages/ProtectedAdmin.js dosyası oluşturuldu. içine:<br>
              <code>
                import { Navigate, Outlet } from "react-router-dom";<br>

                import { useAuth } from "../contexts/AuthContext";<br><br>

                function ProtectedAdmin() {<br>
                  const { loggedIn, user } = useAuth();<br>
                  return loggedIn && user.role === "admin" ? &lt;Outlet /> : &lt;Navigate to="/" />;<br>
                }<br><br>

                export default ProtectedAdmin;

              </code>
            </p>
            <p>
              Oluşturulan ProtectedAdmin kompanenti Add.js Routes alanında kullanıldı. <br>
              <code>
                &lt;Routes><br>
                  ...<br>
                  &lt;Route element={&lt;ProtectedAdmin />}><br>
                    &lt;Route path="/admin" element={&lt;Admin />}><br>
                      &lt;Route path="" element={&lt;Home />} /><br>
                      &lt;Route path="orders" element={&lt;Orders />} /><br>
                      &lt;Route path="products" element={&lt;AdminProducts />} /><br>
                    &lt;/Route><br>
                  &lt;/Route><br>
                  ...<br>
                &lt;/Routes>
              </code>
            </p>
            <p>
              Routes alanında admin pathi içinde de nest yapısı kuruldu. Burası için linkler pages/Admin/index.js içinde verilmişti. Elementlerin <q>Outlet</q> yapısı da aynı sayfada.
            </p>
            <p>
              admin altında yuvalanmış linkler için gereken kompanentler Admin klasöründe oluşturuldu. İçeriği daha sonra düzenlenecek.
            </p>
          </div>
          <div class="row" id="adminOrder">
            <h1>Admin: Order Sayfası</h1>
            <p>
              api.js içinde gerekli fetch fonksiyonu tanımlanır. <br>
              <code>
                export const fetchOrders = async () => {<br>
                  const { data } = await axios.get(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/order`<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              Alınan veri reactQuery yapısı ve chakraUI tablo görselleri ile pages/Admin/Orders.index.js dosyasında kullanılır. (Order detail kısmını modal olarak ben tasarladım :D )<br>
              <code>
                import React, { useState } from "react";<br>
                import { useQuery } from "@tanstack/react-query";<br>
                import {
                  Table,
                  Thead,
                  Tbody,
                  Tr,
                  Th,
                  Td,
                  TableCaption,
                  Text,
                  Modal,
                  ModalOverlay,
                  ModalContent,
                  ModalHeader,
                  ModalFooter,
                  ModalBody,
                  ModalCloseButton,
                  useDisclosure,
                  Button,
                } from "@chakra-ui/react";<br><br>

                import { fetchOrders } from "../../../api";<br>
                import { Link } from "react-router-dom";<br><br>

                function Orders() {<br>
                  const [order, setOrder] = useState([]);
              </code> modal içinde gönderilecek verinin statei <br>
              <code>
                  const total = order.reduce((acc, obj) => acc + obj.price, 0);
              </code> modal içinde kullanılacak verinin toplama işlemi <br>
              <code>
                  const { isOpen, onOpen, onClose } = useDisclosure();
              </code> modal için gereken tanımlar. <br>
              <code>
                  const getDetail = (orderData) => {<br>
                    onOpen();<br>
                    setOrder(orderData);<br>
                  };<br><br>

                  const { isLoading, isError, data, error } = useQuery(<br>
                    ["admin:orders"],<br>
                    fetchOrders<br>
                  );<br><br>

                  if (isLoading) {<br>
                    return &lt;div>Loading...&lt;/div>;<br>
                  }<br><br>

                  if (isError) {<br>
                    return &lt;div>Error {error.message}&lt;/div>;<br>
                  }<br><br>

                  console.log("data", data);<br>
                  return (<br>
                    &lt;div><br>
                      &lt;Text fontSize="2xl" padding={5}>
                        Orders
                      &lt;/Text><br><br>

                      &lt;Table variant="simple"><br>
                        &lt;TableCaption>Order Page - Total order(s) = {data.length}&lt;/TableCaption><br>
                        &lt;Thead><br>
                          &lt;Tr><br>
                            &lt;Th>User&lt;/Th><br>
                            &lt;Th>Address&lt;/Th><br>
                            &lt;Th isNumeric>Items&lt;/Th><br>
                            &lt;Th>&lt;/Th><br>
                          &lt;/Tr><br>
                        &lt;/Thead><br>
                        &lt;Tbody><br>
                          {data.map((item) => (<br>
                            &lt;Tr key={item._id}><br>
                              &lt;Td>{item.user.email}&lt;/Td><br>
                              &lt;Td>{item.adress}&lt;/Td><br>
                              &lt;Td isNumeric>{item.items.length}&lt;/Td><br>
                              &lt;Td><br>
                                &lt;Button onClick={() => getDetail(item.items)}>Detail&lt;/Button><br>
                              &lt;/Td><br>
                            &lt;/Tr><br>
                          ))}<br>
                        &lt;/Tbody><br>
                      &lt;/Table><br><br>

                      &lt;Modal isOpen={isOpen} onClose={onClose}>
              </code> Buradan itibaren benim tasarladığım modal başlıyor. <br>
              <code>
                        &lt;ModalOverlay /><br>
                        &lt;ModalContent><br>
                          &lt;ModalHeader>Modal Title&lt;/ModalHeader><br>
                          &lt;ModalCloseButton /><br>
                          &lt;ModalBody><br>
                            Order Detail: {order.length} &lt;br />v
                            &lt;Table variant="simple"><br>
                              &lt;TableCaption>Order Total Price = {total}&lt;/TableCaption><br>
                              &lt;Thead><br>
                                &lt;Tr><br>
                                  &lt;Th>Item&lt;/Th><br>
                                  &lt;Th isNumeric>Price&lt;/Th><br>
                                  &lt;Th>&lt;/Th><br>
                                &lt;/Tr><br>
                              &lt;/Thead><br>
                              &lt;Tbody><br>
                                {order &&<br>
                                  order.map((item) => (<br>
                                      &lt;Tr key={item._id}><br>
                                        &lt;Td>{item.title}&lt;/Td><br>
                                        &lt;Td>{item.price} TL&lt;/Td><br>
                                        &lt;Td><br>
                                          &lt;Button><br>
                                            &lt;Link to={`../../product/${item._id}`}><br>
                                              item detail<br>
                                            &lt;/Link><br>
                                          &lt;/Button><br>
                                        &lt;/Td><br>
                                      &lt;/Tr><br>
                                  ))}<br>
                              &lt;/Tbody><br>
                            &lt;/Table><br>
                          &lt;/ModalBody><br>

                          &lt;ModalFooter><br>
                            &lt;Button colorScheme="blue" mr={3} onClick={onClose}><br>
                              Close<br>
                            &lt;/Button><br>
                            &lt;Button variant="ghost">Secondary Action&lt;/Button><br>
                          &lt;/ModalFooter><br>
                        &lt;/ModalContent><br>
                      &lt;/Modal><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Orders;

              </code>
            </p>
          </div>
          <div class="row" id="adminProducts">
            <h1>Admin: Products Sayfası</h1>
            <p>
              Bu kısımda UI aracı olarak <a href="https://ant.design/">ant design</a> kullanılacak. Terminale: <br>
              <code>
                npm install antd
              </code>
            </p>
            <p>
              Yorumlarda material UI önerilmiş. İncelemekte fayda var.
            </p>
            <p>
              Delete işlemi için gereken fetch işlemi api.js üzerinde tanımlandı. <br>
              <code>
                export const deleteProduct = async (product_id) => {<br>
                  const { data } = await axios.delete(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/product/${product_id}`<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              Admin/AdminProducts/index.js içinde ant design üzerindeki tablo yapısı ile veriler ve edit - delete butonları tanımlandı. Delete için api.js de yazılan fonksiyon kullanıldı. <br>
              <code>
                import { useMemo } from "react";<br>
                import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"; 
              </code> useMutation veri manupilasyonu için kullanılıyor. <br>
              <code><br>

                import { fetchProductList, deleteProduct } from "../../../api";<br><br>

                import { Link } from "react-router-dom";<br>
                import { Text } from "@chakra-ui/react";<br>
                import { Table, Popconfirm } from "antd";<br><br>

                function Products() {<br>
                  const queryClient = useQueryClient(); 
              </code> kök dizindeki index.js içindeki queryClient yapısına ulaşmayı sağlar.<br>
              <code><br>

                  const { isLoading, isError, data, error } = useQuery(<br>
                    ["admin:products"],<br>
                    fetchProductList<br>
                  );<br><br>

                  const deleteMutation = useMutation(deleteProduct, {<br>
                    onSuccess: () => queryClient.invalidateQueries("admin:products"),
              </code> useQuery kullanırken tanımlanan "admin:products" bileşeninin queryClient içinde verilen tanımdan muaf olması sağlanır.<br>
              <code>
                  }); 
              </code> ilk parametrede işlem için gereken fetch fonksiyonu, ikinci parametrede options(işlemden önce, sonra yapılacak işlemler, tekrardan refetch yapılacak mı vs) girilir. <br>
              <code><br>

                  const columns = useMemo(() => { 
              </code> kolonların her seferinde refetch olmaması için useMemo() kullanıldı. <br>
              <code>
                    return [<br>
                      {<br>
                        title: "Title",<br>
                        dataIndex: "title",<br>
                        key: "title",<br>
                      },<br>
                      {<br>
                        title: "Price",<br>
                        dataIndex: "price",<br>
                        key: "price",<br>
                      },<br>
                      {<br>
                        title: "Created At",<br>
                        dataIndex: "createdAt",<br>
                        key: "createdAt",<br>
                      },<br>
                      {<br>
                        title: "Action",<br>
                        key: "action",<br>
                        render: (text, record) => (
              </code> record o satıra denk gelen veriyi temsil eder<br>
              <code>
                          &lt;><br>
                            &lt;Link to={`/admin/products/${record._id}`}>Edit&lt;/Link><br><br>

                            &lt;Popconfirm 
              </code> ant design içindeki popconfirm kullanıldı. <br>
              <code>
                              title="Are you sure?"<br>
                              onConfirm={() => { 
              </code> onaylanması durumunda çalışacak fonksiyon. <br>
              <code>
                                deleteMutation.mutate(record._id, {<br>
                                  onSuccess: () => { 
              </code> onay işlemini başarılı olması durumunda çalışacak fonksiyon. <br>
              <code>
                                    console.log("success");<br>
                                  },<br>
                                });<br>
                              }}<br>
                              onCancel={() => console.log("iptal edildi")}
              </code> işlemi kullanıcının onaylamaması durumunda çalışacak fonksiyon. <br>
              <code>
                              okText="Yes"<br>
                              cancelText="No"<br>
                              placement="left"
              </code> popconfirm yerleşim şekli. <br>
              <code>
                            ><br>
                              &lt;Link style={{marginLeft: 10}}>Delete&lt;/Link><br>
                            &lt;/Popconfirm><br>
                          &lt;/><br>
                        ),<br>
                      },<br>
                    ];<br>
                  }, []);<br><br>

                  if (isLoading) {<br>
                    return <div>Loading...</div>;<br>
                  }<br><br>

                  if (isError) {<br>
                    return <div>Error {error.message}</div>;<br>
                  }<br><br>
                  
                  return (<br>
                    &lt;div><br>
                      &lt;Text fontSize="2xl" p="5"><br>
                        Products<br>
                      &lt;/Text><br>
                      &lt;Table dataSource={data} columns={columns} rowKey="_id" />;
              </code> yukarıda tanımlanan tablonun yerleşimi. Return edilen datayı ve tanımlanan kolon yapısını kullanır. <br>
              <code>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default Products;

              </code>
            </p>
          </div>
          <div class="row" id="adminProductUpdate">
            <h1>Admin: Product Update İşlemleri</h1>
            <p>
              App.js içinde admin/product sayfasındaki edit butonunda verilen bağlantı için routing yapıldı: <br>
              <code>
                &lt;Routes> <br>
                  ...<br>
                  &lt;Route element={&lt;ProtectedAdmin />}><br>
                    &lt;Route path="/admin" element={&lt;Admin />}><br>
                      ...<br>
                      <u>&lt;Route path="products/:product_id" element={&lt;AdminProductDetail />} /><br></u>
                    &lt;/Route><br>
                  &lt;/Route><br>
                  ...<br>
                &lt;/Routes><br>
              </code>
            </p>
            <p>
              api.js içinde adminProductDetail içindeki düzenlemeyi databasee gönderecek fetch işlemi tanımlandı <br>
              <code>
                export const updateProduct = async (input, product_id) => {<br>
                  const { data } = await axios.put(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/product/${product_id}`,<br>
                    input<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              pages/Admin/AdminProductDetail/index.js içine <br>
              <code>
                import React from "react";<br><br>

                import { useParams } from "react-router-dom";<br>
                import { fetchProduct, updateProduct } from "../../../api";
              </code> ürün detayını getiren ve yapılan güncellemeyi databasee iletecek fonksiyonlar import edildi. <br>
              <code>
                import { useQuery } from "@tanstack/react-query";<br>
                import {
                  Box,
                  Button,
                  FormControl,
                  FormLabel,
                  Input,
                  Text,
                  Textarea,
                } from "@chakra-ui/react";
              </code> Form bileşenlerinin görsel tasarımları için chakra-ui kullanıldı.<br>
              <code>
                import { message } from "antd";
              </code> form submit edildiğinde çıkan spiner için ant-design kullanıldı. <br>
              <code>
                import { Formik, FieldArray } from "formik";
              </code> client tarafında arrayi düzenlemek için FieldArray import edildi. <br>
              <code>
                import validationSchema from "./validations";
              </code>validasyon işlemleri: aşağıda taımlandı.<br>
              <code><br>

                function AdminProductDetail() {<br>
                  const { product_id } = useParams();<br>
                  const { isLoading, isError, data, error } = useQuery(<br>
                    ["admin:product", product_id],<br>
                    () => fetchProduct(product_id)<br>
                  );<br>
                  if (isLoading) {<br>
                    return &lt;div>Loading...&lt;/div>;<br>
                  }<br><br>

                  if (isError) {<br>
                    return &lt;div>Error {error.message}&lt;/div>;<br>
                  }<br><br>

                  const handleSubmit = async (values, bag) => {
              </code> form tarafında submit için kullanılacak fonksiyon. <br>
              <code>
                    console.log("submitted");<br>
                    message.loading({ content: "Loading...", key: "product_update" }); 
              </code> ant-design tarafında çekilen spinner tanımı. <br>
              <code><br>

                    try {<br>
                      await updateProduct(values, product_id);<br><br>
                      message.success({
              </code>işlemin başarılması durumunda spinner durumunda yapılacak güncelleme<br>
              <code>
                        content: "The product successfully updated.",<br>
                        key: "product_update",<br>
                        duration: 2,<br>
                      });<br>
                    } catch (e) {<br>
                      message.error({
              </code>işlemin başarısız olma durumunda spinner durumunda yapılan güncelleme<br>
              <code>
                        content: "The product does not updated!",<br>
                        key: "product_update",<br>
                      });<br>
                    }<br>
                  };<br><br>

                  return (<br>
                    &lt;div><br>
                      &lt;Text fontSize="2xl">Edit&lt;/Text><br><br>

                      &lt;Formik<br>
                        initialValues={{<br>
                          title: data.title,<br>
                          description: data.description,<br>
                          price: data.price,<br>
                          photos: data.photos,<br>
                        }}<br>
                        validationSchema={validationSchema}<br>
                        onSubmit={handleSubmit}<br>
                      ><br>
                        {({<br>
                          handleSubmit,
              </code>formik içinde kullanılan tanımlar.<br>
              <code>
                          errors,<br>
                          touched,<br>
                          handleChange,<br>
                          handleBlur,<br>
                          values,<br>
                          isSubmitting,<br>
                        }) => (<br>
                          &lt;><br>
                            &lt;Box><br>
                              &lt;Box my={5} textAlign="left"><br>
                                &lt;form onSubmit={handleSubmit}><br>
                                  &lt;FormControl><br>
                                    &lt;FormLabel>Title&lt;/FormLabel><br>
                                    &lt;Input<br>
                                      name="title"<br>
                                      onChange={handleChange}<br>
                                      onBlur={handleBlur}<br>
                                      value={values.title}<br>
                                      disabled={isSubmitting}<br>
                                      isInvalid={touched.title && errors.title}<br>
                                    /><br>
                                    {touched.title && errors.title && (<br>
                                      &lt;Text color="red">{errors.title}&lt;/Text><br>
                                    )}<br>
                                  &lt;/FormControl><br>
                                  &lt;FormControl mt={4}><br>
                                    &lt;FormLabel>Description&lt;/FormLabel><br>
                                    &lt;Textarea<br>
                                      name="description"<br>
                                      onChange={handleChange}<br>
                                      onBlur={handleBlur}<br>
                                      value={values.description}<br>
                                      disabled={isSubmitting}<br>
                                      isInvalid={touched.description && errors.description}<br>
                                    /><br>
                                    {touched.description && errors.description && (<br>
                                      &lt;Text color="red">{errors.description}&lt;/Text><br>
                                    )}<br>
                                  &lt;/FormControl><br>
                                  &lt;FormControl mt={4}><br>
                                    &lt;FormLabel>Price&lt;/FormLabel><br>
                                    &lt;Input<br>
                                      name="price"<br>
                                      onChange={handleChange}<br>
                                      onBlur={handleBlur}<br>
                                      value={values.price}<br>
                                      disabled={isSubmitting}<br>
                                      isInvalid={touched.price && errors.price}<br>
                                    /><br>
                                    {touched.price && errors.price && (<br>
                                      &lt;Text color="red">{errors.price}&lt;/Text><br>
                                    )}<br>
                                  &lt;/FormControl><br>

                                  &lt;FormControl mt={4}><br>
                                    &lt;FormLabel>Photos&lt;/FormLabel><br>
                                    &lt;FieldArray<br>
                                      name="photos" 
              </code> initualValues üzerinden gelen tanım<br>
              <code>
                                      render={(arrayHelpers) => (<br>
                                        &lt;div><br>
                                          {values.photos &&<br>
                                            values.photos.map((photo, index) => (<br>
                                              &lt;div key={index}><br>
                                                &lt;Input<br>
                                                  name={`photos.${index}`}<br>
                                                  value={photo}<br>
                                                  disabled={isSubmitting}<br>
                                                  onChange={handleChange}<br>
                                                  width="3xl"<br>
                                                /><br><br>

                                                &lt;Button<br>
                                                  ml={4}<br>
                                                  type="button"<br>
                                                  colorScheme="red"<br>
                                                  onClick={() => arrayHelpers.remove(index)}
              </code>FieldArray>arrayHelpers yardımıyla remove işlemi yapıldı.<br>
              <code>
                                                  isLoading={isSubmitting}<br>
                                                ><br>
                                                  Remove<br>
                                                &lt;/Button><br>
                                              &lt;/div><br>
                                            ))}<br><br>

                                          &lt;Button<br>
                                            mt={5}<br>
                                            onClick={() => arrayHelpers.push("")}
              </code>FieldArray>arrayHelpers yardımıyla boş element ekleme işlemi yapıldı.<br>
              <code>
                                            isLoading={isSubmitting}<br>
                                          ><br>
                                            Add a photo<br>
                                          &lt;/Button><br>
                                        &lt;/div><br>
                                      )}<br>
                                    /><br>
                                  &lt;/FormControl><br>
                                  &lt;Button<br>
                                    mt={4}<br>
                                    width="full"<br>
                                    type="submit"
              </code>formikin mevcut değişiklikle submit etmesi sağlanır.<br>
              <code>
                                    isLoading={isSubmitting}<br>
                                  ><br>
                                    Update<br>
                                  &lt;/Button><br>
                                &lt;/form><br>
                              &lt;/Box><br>
                            &lt;/Box><br>
                          &lt;/><br>
                        )}<br>
                      &lt;/Formik><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default AdminProductDetail;

              </code>
            </p>
            <p>
              pages/Admin/AdminProductDetail/validations.js içine validasyon tanımları yapıldı.<br>
              <code>
                import * as yup from "yup";<br><br>

                const editScheme = yup.object().shape({<br>
                    title: yup.string().required(),<br>
                    description: yup.string().min(5).required(),<br>
                    price: yup.number().required(),<br>
                })<br><br>

                export default editScheme;
              </code>
            </p>
          </div>
          <div class="row" id="adminNewProduct">
            <h1>Admin: Yeni Ürün Eklemek</h1>
            <p>
              App.js içinde gerekli routing yapıldı. <br>
              <code>
                &lt;Routes><br>
                  ...<br>
                  &lt;Route element={&lt;ProtectedAdmin />}><br>
                    &lt;Route path="/admin" element={&lt;Admin />}><br>
                      ...<br>
                      &lt;Route path="products" element={&lt;AdminProducts />} /><br>
                      &lt;Route path="products/new" element={&lt;NewProduct />} /><br>
                      ...<br>
                    &lt;/Route><br>
                  &lt;/Route><br>
                  ...<br>
                &lt;/Routes>
              </code>
            </p>
            <p>
              api.js içinde gereken fetch fonksiyonu tanımlanır. <br>
              <code>
                export const postProduct = async (input) => {<br>
                  const { data } = await axios.post(<br>
                    `${process.env.REACT_APP_BASE_ENDPOINT}/product/`,<br>
                    input<br>
                  );<br><br>
                
                  return data;<br>
                };
              </code>
            </p>
            <p>
              pages/Admin/AdminProducts/index.js içinde <q>New Product</q> butonu yerleştirilir. <br>
              <code>
                ...<br>
                return (<br>
                      &lt;div><br>
                        &lt;Flex justifyContent="space-between" alignItems="center"><br>
                          &lt;Text fontSize="2xl" p="5"><br>
                            Products<br>
                          &lt;/Text><br>

                         <u>
                          &lt;Link to={"/admin/products/new"}><br>
                          &lt;Button>New Product&lt;/Button><br>
                        &lt;/Link><br>
                         </u>
                        &lt;/Flex><br>
                        &lt;Table dataSource={data} columns={columns} rowKey="_id" />;<br>
                      &lt;/div><br>
                    );<br>
                  }<br>
                  ...
              </code>
            </p>
            <p>
              pages/Admin/AdminProducts/new.js dosyası oluşturulur. İçindeki çoğu eleman pages/Admin/AdminProductDetail/index.js ve pages/Admin/AdminProducts/index.js dosyasından kopyalandı. <br>
              <code>
                import React from "react";<br><br>

                import { postProduct } from "../../../api";<br>
                import { useMutation, useQueryClient } from "@tanstack/react-query";<br>
                import {
                  Box,
                  Button,
                  FormControl,
                  FormLabel,
                  Input,
                  Text,
                  Textarea,
                } from "@chakra-ui/react";<br>
                import { message } from "antd";<br>
                import { Formik, FieldArray } from "formik";<br>
                import validationSchema from "./validations";<br><br>

                function NewProduct() {<br>
                  const queryClient = useQueryClient();<br><br>

                  const newProductMutation = useMutation(postProduct, {
              </code> ile fetch fonksiyonu yerleştirilir ve kullanılır.<br>
              <code>
                    onSuccess: () => queryClient.invalidateQueries("admin:products"),<br>
                  });<br><br>

                  const handleSubmit = async (values, bag) => {<br>
                    console.log(values);<br>
                    message.loading({ content: "Loading...", key: "product_update" });<br><br>

                    const newValues = {
              </code>photos arrayi databasee stringfy edilerek gönderiliyor<br>
              <code>
                      ...values,
              </code>tüm değerleri alır.<br>
              <code>
                      photos: JSON.stringify(values.photos),
              </code>photos değerini stingfy şekliyle değiştirir.<br>
              <code>
                    };<br><br>

                    newProductMutation.mutate(newValues, {<br>
                      onSuccess: () => {<br>
                        console.log("success");<br><br>

                        message.success({<br>
                          content: "The product successfully updated.",<br>
                          key: "product_update",<br>
                          duration: 2,<br>
                        });<br>
                      },<br>
                    });<br>
                  };
                  <br><br>
                  return (<br>
                    &lt;div><br>
                      &lt;Text fontSize="2xl">New Product&lt;/Text><br><br>

                      &lt;Formik<br>
                        initialValues={{<br>
                          title: "",<br>
                          description: "",<br>
                          price: "",<br>
                          photos: [],<br>
                        }}<br>
                        validationSchema={validationSchema}<br>
                        onSubmit={handleSubmit}<br>
                      ><br>
                        {({<br>
                          handleSubmit,<br>
                          errors,<br>
                          touched,<br>
                          handleChange,<br>
                          handleBlur,<br>
                          values,<br>
                          isSubmitting,<br>
                        }) => (<br>
                          &lt;><br>
                            &lt;Box>
              </code>Form yapısı AdminProductDetail/index.js nin aynısı<br>
              <code>
                              &lt;Box my={5} textAlign="left"><br>
                                &lt;form onSubmit={handleSubmit}><br>
                                  &lt;FormControl><br>
                                    &lt;FormLabel>Title&lt;/FormLabel><br>
                                    &lt;Input<br>
                                      name="title"<br>
                                      onChange={handleChange}<br>
                                      onBlur={handleBlur}<br>
                                      value={values.title}<br>
                                      disabled={isSubmitting}<br>
                                      isInvalid={touched.title && errors.title}<br>
                                    /><br>
                                    {touched.title && errors.title && (<br>
                                      &lt;Text color="red">{errors.title}&lt;/Text><br>
                                    )}<br>
                                  &lt;/FormControl><br>
                                  &lt;FormControl mt={4}><br>
                                    &lt;FormLabel>Description&lt;/FormLabel><br>
                                    &lt;Textarea<br>
                                      name="description"<br>
                                      onChange={handleChange}<br>
                                      onBlur={handleBlur}<br>
                                      value={values.description}<br>
                                      disabled={isSubmitting}<br>
                                      isInvalid={touched.description && errors.description}<br>
                                    /><br>
                                    {touched.description && errors.description && (<br>
                                      &lt;Text color="red">{errors.description}&lt;/Text><br>
                                    )}<br>
                                  &lt;/FormControl><br>
                                  &lt;FormControl mt={4}><br>
                                    &lt;FormLabel>Price&lt;/FormLabel><br>
                                    &lt;Input<br>
                                      name="price"<br>
                                      onChange={handleChange}<br>
                                      onBlur={handleBlur}<br>
                                      value={values.price}<br>
                                      disabled={isSubmitting}<br>
                                      isInvalid={touched.price && errors.price}<br>
                                    /><br>
                                    {touched.price && errors.price && (<br>
                                      &lt;Text color="red">{errors.price}&lt;/Text><br>
                                    )}<br>
                                  &lt;/FormControl><br><br>

                                  &lt;FormControl mt={4}><br>
                                    &lt;FormLabel>Photos&lt;/FormLabel><br>
                                    &lt;FieldArray<br>
                                      name="photos"<br>
                                      render={(arrayHelpers) => (<br>
                                        &lt;div><br>
                                          {values.photos &&<br>
                                            values.photos.map((photo, index) => (<br>
                                              &lt;div key={index}><br>
                                                &lt;Input<br>
                                                  name={`photos.${index}`}<br>
                                                  value={photo}<br>
                                                  disabled={isSubmitting}<br>
                                                  onChange={handleChange}<br>
                                                  width="3xl"<br>
                                                /><br>

                                                &lt;Button<br>
                                                  ml={4}<br>
                                                  type="button"<br>
                                                  colorScheme="red"<br>
                                                  onClick={() => arrayHelpers.remove(index)}<br>
                                                  isLoading={isSubmitting}<br>
                                                ><br>
                                                  Remove<br>
                                                &lt;/Button><br>
                                              &lt;/div><br>
                                            ))}<br><br>

                                          &lt;Button<br>
                                            mt={5}<br>
                                            onClick={() => arrayHelpers.push("")}<br>
                                            isLoading={isSubmitting}<br>
                                          ><br>
                                            Add a photo<br>
                                          &lt;/Button><br>
                                        &lt;/div><br>
                                      )}<br>
                                    /><br>
                                  &lt;/FormControl><br>
                                  &lt;Button<br>
                                    mt={4}<br>
                                    width="full"<br>
                                    type="submit"<br>
                                    isLoading={isSubmitting}<br>
                                  ><br>
                                    Save<br>
                                  &lt;/Button><br>
                                &lt;/form><br>
                              &lt;/Box><br>
                            &lt;/Box><br>
                          &lt;/><br>
                        )}<br>
                      &lt;/Formik><br>
                    &lt;/div><br>
                  );<br>
                }<br><br>

                export default NewProduct;

              </code>
            </p>
            <p>
              validasyon dosyası Admin/AdminProductDetail/validations.js içinden kopyalanarak düzenlendi. <br>
              <code>
                import * as yup from "yup";<br><br>

                const NewProductScheme = yup.object().shape({<br>
                    title: yup.string().required(),<br>
                    description: yup.string().min(5).required(),<br>
                    price: yup.number().required(),<br>
                })<br><br>

                export default NewProductScheme;
              </code>
            </p>
          </div>
          <div class="row" id="MyModif">
            <h1>Projeye Benim Katkım</h1>
            <p>
              Admin/Product sayfasında sadece 12 ürün görünüyor. Tüm ürünleri göstermek için backend tarafına müdahale ettim. routes/index sayfasında yeni bir yönlendirme yazıldı. <br>
              <code>
                router.use('/product-all', productAll);
              </code>
              <p>
                Bu yönlendirmeyi almak için routes/productAll.js dosyası oluşturuldu. <br>
                <code>
                  import express from "express";<br>
                  import ProductAll from "../controllers/productAll";<br><br>
                  
                  const router = express.Router();<br><br>

                  router.get("/", ProductAll.GetList);<br><br>

                  export default router;
                </code>
              </p>
              <p>
                Bu yönlendirmeye response oluşturması için controllers/productAll/index.js dosyası oluşturuldu ve içine <br>
                <code>
                  import Product from "../../models/product";<br><br>

                  const GetList = async (req, res, next) => {<br>
                    try {<br>
                      const products = await Product.find({}).sort({ createdAt: -1 });<br>

                      res.json(products);<br>
                    } catch (e) {<br>
                      next(e);<br>
                    }<br>
                  };
                  <br><br>
                  export default {<br>
                    GetList,<br>
                  };

                </code>
              </p>
              <p>
                buradan gelen yönlendirme client tarafında api.js içinde yakalandı. <br>
                <code>
                  export const fetchProductAllList = async ({ pageParam = 0 }) => {<br>
                    const { data } = await axios.get(<br>
                      `${process.env.REACT_APP_BASE_ENDPOINT}/product-all`<br>
                    );<br>
                  
                    return data;<br>
                  };
                </code>
              </p>
              <p>
                Bu fonksiyon pages\Admin\AdminProducts\index.js içinde import edilip fetchProductList yerine kullanıldı.
              </p>
              <p>
                Admin/Home sayfası düzenlendi.
              </p>
            </p>
          </div>
        </div>
      </div>
    </div>
    <!-- JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-OERcA2EqjJCMA+/3y+gxIOqMEjwtxJY7qPCqsdltbNJuaOe923+mo//f6V8Qbsw3" crossorigin="anonymous"></script>
</body>
</html>